<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Tracker ‚Äì Planned &amp; Consumed Hours</title>
  <style>
    /* =======================
       Estilos Originais
       ======================= */
    #comparisonPanelContent {
      display: flex;
      flex-direction: column;
      height: 90%;
      gap: 12px;
    }
    .comparison-row {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .comparison-row h4 {
      margin: 0 0 8px 0;
      font-size: 1.1em;
      text-align: center;
    }
    #ecomComparisonChart,
    #retailComparisonChart {
      width: 100% !important;
      height: 100% !important;
      max-height: 88% !important;
    }

    #comparisonPanel {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 97vh;
      background: #fff;
      box-shadow: 0 8px 40px rgba(0,0,0,0.17);
      padding: 18px 38px 30px 38px;
      overflow-y: auto;
      z-index: 2000;
    }
    #closeComparisonPanel {
      position: absolute;
      top: 10px;
      right: 18px;
      font-size: 34px;
      background: none;
      border: none;
      color: #c1121f;
      cursor: pointer;
      z-index: 3001;
      line-height: 1;
      padding: 2px 8px;
      border-radius: 50%;
      transition: background 0.15s;
    }
    #closeComparisonPanel:hover {
      background: #f9d3d3;
      box-shadow: 0 2px 7px #eee;
    }
    #dashboard.pdf-scale {
      transform: scale(0.74);
      transform-origin: top left;
      width: 1438px !important;
      min-width: unset !important;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background-color: #f4f7f9;
      color: #333;
    }
    #controlsAccordion summary {
      list-style: none;
      cursor: pointer;
      font-weight: bold;
      background: #004d99;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
    }
    #controlsAccordion {
      margin-top: -10px;
    }
    #controlsAccordion summary::-webkit-details-marker {
      display: none;
    }
    #controlsAccordion summary::marker {
      display: none;
    }
    #controlsAccordion summary::before {
      content: "‚ñº ";
    }
    #controlsAccordion[open] summary {
      background: #007acc;
    }
    #controlsAccordion > div#controls {
      background: #f9f9f9;
      padding: 12px;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 4px 4px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 6px;
      padding: 4px 0;
    }
    #controls input[type="file"],
    #controls input[type="date"],
    #controls button {
      font-size: 0.85rem;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background: #fff;
      color: #333;
      cursor: pointer;
    }
    #controls input[type="file"]::-webkit-file-upload-button {
      padding: 4px 8px;
      font-size: 0.85rem;
      border: none;
      background: #f0f0f0;
    }
    #controls input[type="date"] {
      width: 100px;
    }
    #controls button:hover {
      background-color: #eaeaea;
    }
    #controls input[type="file"] {
  width: auto !important;
  max-width: 75px;
  font-size: 0.75rem;
  padding: 2px 4px;
  line-height: 1;
  border: 1px solid #ccc;
  background: #fff;
  color: #333;
  cursor: pointer;
  box-shadow: none;
}
#controls input[type="file"]::-webkit-file-upload-button {
  padding: 2px 4px;
  font-size: 0.75rem;
  line-height: 0.2;
  border: none;
  background: #f0f0f0;
  margin: 0;
  cursor: pointer;
}
    .top-bar {
      background-color: #004d99;
      color: white;
      padding: 10px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      position: relative;
    }
    .bottom-right {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #ddd;
      font-size: 12px;
    }
    .highlight-number {
      font-weight: bold;
    }
    #headcountCount {
      font-size: 1em !important;
    }
    #totalConsumed,
    #totalPlanned {
      font-size: 1em !important;
      font-weight: bold;
      color: #c1121f;
    }
    #main-content {
      padding: 10px;
      margin-top: -10px;
    }
    #controls input[type="file"],
    #controls button,
    #budgetControls input,
    #dateControls input {
      padding: 8px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s, box-shadow 0.3s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .filter-button {
      background-color: #e0e0e0;
      border: 1px solid #ccc;
      color: #333;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }
    .filter-button:hover {
      background-color: #d0d0d0;
    }
    .filter-input {
      padding: 6px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
   #controls input[type="file"] {
  background: linear-gradient(45deg, #00bfae, #009688);
  color: #fff;
  min-width: 180px; /* largura m√≠nima maior */
  width: auto;      /* cresce com o conte√∫do / container */
}
    #controls input[type="file"]::-webkit-file-upload-button {
      background: linear-gradient(45deg, #00bfae, #009688);
      color: #fff;
      border: none;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #controls input[type="file"]::-webkit-file-upload-button:hover {
      background: linear-gradient(45deg, #00a79d, #008b8b);
    }
    #controls button:hover {
      background-color: #003366;
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    .nav-tabs {
      display: flex;
      justify-content: center;
      background-color: #f1f1f1;
      padding: 10px;
      border-bottom: 2px solid #ddd;
      gap: 5px;
    }
    .nav-tabs button {
      background-color: #004d99;
      color: white;
      border: none;
      padding: 8px 20px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-size: 16px;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .nav-tabs button.active {
      background-color: #007acc;
    }
    .nav-tabs button:hover {
      background-color: #005f99;
    }
    .tab-content {
      display: none;
      padding: 20px;
      background-color: #fff;
      border: none;
      margin-top: 10px;
    }
    .tab-content.active {
      display: block;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   regra gen√©rica para todas as c√©lulas
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
th, td {
  padding: 12px;
  text-align: left;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   corpo da #budgetTable mais compacto
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
#budgetTracker #budgetTable tbody td {
  padding: 4px 6px;   /* vertical / horizontal  */
  line-height: 0.8;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1¬™ linha do cabe√ßalho ‚Äì continua no topo
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
#budgetTracker #budgetTable thead tr:first-child th {
  position: sticky;     /* garante que fique fixa               */
  top: 0;               /* encostada no topo da tabela/viewport */
  z-index: 3;           /* acima da 2¬™ linha                    */

  padding: 2px 6px;
  line-height: 1;
  font-size: 0.90rem;   /* se quiser outro tamanho, ajuste aqui */
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   2¬™ linha do cabe√ßalho ‚Äì fixa logo abaixo
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
#budgetTracker #budgetTable thead tr:nth-child(2) th {
  position: sticky;     /* tamb√©m fixa                           */
  top: 34px;            /* altura da 1¬™ linha  ‚Üí ajuste se mudar */
  z-index: 2;           /* um n√≠vel abaixo da 1¬™                 */

  padding: 2px 6px;
  line-height: 1;
  font-size: 0.80rem;   /* ou 0.90rem, conforme preferir         */
}


/* NOVO ‚Äì s√≥ a 1¬™ c√©lula (Task) de cada linha */
#budgetTracker #budgetTable tbody td:first-child {
  font-size: 0.90rem;   /* ou 0.8rem, 12px‚Ä¶ ajuste √† vontade */
  white-space: nowrap;  /* opcional: evita quebra de linha   */
}
    th {
      background-color: #004d99;
      color: #fff;
      position: sticky;
      top: 0;
      z-index: 2;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    tr:hover {
      background-color: #d9d9d9;
    }
        #resultTable {
      table-layout: fixed;
      width: 100%;
    }
    #resultTable th,
    #resultTable td {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding: 6px 8px;
      font-size: 0.85rem;
    }

    /* 1 = Employee */
    #resultTable th:nth-child(1),
    #resultTable td:nth-child(1) {
      width: 150px;
    }

    /* 2 = TYPE (CORE / AGY J&T / AGY 247) */
    #resultTable th:nth-child(2),
    #resultTable td:nth-child(2) {
      width: 90px;
    }

    /* 3 = Person Number */
    #resultTable th:nth-child(3),
    #resultTable td:nth-child(3) {
      width: 100px;
    }

    /* 4 = Role */
    #resultTable th:nth-child(4),
    #resultTable td:nth-child(4) {
      width: 80px;
    }

    /* 5 = Date */
    #resultTable th:nth-child(5),
    #resultTable td:nth-child(5) {
      width: 100px;
    }

    /* 6 = Week */
    #resultTable th:nth-child(6),
    #resultTable td:nth-child(6) {
      width: 60px;
    }

    /* 7 = Month */
    #resultTable th:nth-child(7),
    #resultTable td:nth-child(7) {
      width: 80px;
    }

    /* 8 = Labour Account */
    #resultTable th:nth-child(8),
    #resultTable td:nth-child(8) {
      width: 180px;
    }

    /* 9 = Dep. */
    #resultTable th:nth-child(9),
    #resultTable td:nth-child(9) {
      width: 60px;
    }

    /* 10 = Task */
    #resultTable th:nth-child(10),
    #resultTable td:nth-child(10) {
      width: 150px;
    }

    /* 11 = Total Hours */
    #resultTable th:nth-child(11),
    #resultTable td:nth-child(11) {
      width: 80px;
    }

    /* 12 = Pay Code */
    #resultTable th:nth-child(12),
    #resultTable td:nth-child(12) {
      width: 105px;
    }

    #employeeFilter {
      width: 95px;
      padding: 4px;
      font-size: 0.8rem;
    }
    #labourAccountFilter {
      width: 60px;
      padding: 4px;
      font-size: 0.8rem;
    }
    #taskFilter {
      width: 100px;
      padding: 4px;
      font-size: 0.8rem;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: #fefefe;
      padding: 20px;
      border: 1px solid #888;
      width: 300px;
      border-radius: 8px;
      text-align: center;
    }
    /* ‚úÖ aplica 80% s√≥ para inputs "normais" (n√£o checkbox) */
.modal-content input:not([type="checkbox"]),
.modal-content select {
  width: 80%;
  padding: 5px;
  margin: 5px 0;
  border-radius: 4px;
  border: 1px solid #ccc;
}

/* ‚úÖ checkboxes sempre com tamanho normal */
.modal-content input[type="checkbox"]{
  width: auto !important;
  margin: 0 !important;
}

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .confirm-button {
      background-color: #28a745;
      color: white;
    }
    .cancel-button {
      background-color: #dc3545;
      color: white;
    }
    #controls, #budgetControls, #dateControls {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      text-align: center;
    }
    #slicer {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }
    #slicer button {
      padding: 8px 16px;
      border: 1px solid #004d99;
      border-radius: 4px;
      background-color: #fff;
      color: #004d99;
      font-weight: bold;
      cursor: pointer;
    }
    #slicer button.active {
      background-color: #004d99;
      color: #fff;
    }
    #weekDropdown, #monthDropdown {
      display: inline-block;
    }
    #weekDropdown select, #monthDropdown select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #004d99;
      background-color: #004d99;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
    }
    #slicer, #secondaryButtons {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    #slicer button, #secondaryButtons button {
      min-width: 180px;
    }
    .totals-labels {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 10px;
      text-align: center;
    }
    #totalsBox {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 10px;
      text-align: center;
    }
    #grossHours,
    #loggedHours,
    #depTotalHours {
      font-weight: bold;
    }
    #totalEcom,
    #totalRetail,
    #totalBreak {
      font-weight: bold;
    }
    .kpi-card {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.08);
      padding: 2px 20px 12px 20px;
      text-align: center;
      min-width: 130px;
      margin: 0 8px;
      transition: box-shadow 0.2s;
    }
    .kpi-label {
  color: #555;
  font-size: 1em;
  margin-bottom: 0px;
  font-weight: 500;
}
.kpi-value {
  color: #004d99;
  font-size: 1.5em;
  font-weight: bold;
}

/* ‚Äî‚Äî‚Äî Mant√©m todas as KPI-cards sempre na mesma linha ‚Äî‚Äî‚Äî */
#kpiCards {
  display: flex;
  gap: 20px;
  justify-content: center;
  flex-wrap: nowrap;    /* impede quebra autom√°tica */
  overflow-x: auto;     /* adiciona scroll se ultrapassar a largura */
}

/* ‚Äî‚Äî‚Äî Trunca apenas o texto de ‚ÄúPlanned Hours‚Äù ‚Äî‚Äî‚Äî */
#dashboardPlannedLabel {
  display: inline-block;   /* para respeitar largura m√°xima */
  max-width: 120px;        /* ajuste conforme seu design */
  white-space: nowrap;     /* sem quebras de linha */
  overflow: hidden;        /* esconde o excesso */
  text-overflow: ellipsis; /* mostra "..." no fim */
}

    #toggleValues span {
      opacity: 0;
      transition: opacity 0.2s;
    }
    #toggleValues {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 16px;
      height: 16px;
      background: transparent;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
      z-index: 10;
    }
    #tasksBarContainer:hover #toggleValues span,
    #toggleValues:hover span {
      opacity: 1 !important;
    }
    #toggleValues:hover {
      background: rgba(0,0,0,0.05);
    }
    #ecomTaskFilter,
    #retailTaskFilter {
      width: auto;
      min-width: 150px;
      max-width: 300px;
      max-height: calc(1.6em * 4);
      overflow-y: auto;
      min-height: 1.6em;
      font-size: 0.9rem;
      padding: 2px 4px;
      vertical-align: middle;
      cursor: pointer;
      border: 1px solid #ccc;
      background-color: #fafafa;
    }

    /* =======================
       CSS PARA OS MODAIS DE FILTRO
       ======================= */
    .modal-filter {
      display: none;
      position: fixed;
      z-index: 3000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-filter .modal-content {
      background-color: #fff;
      padding: 20px;
      border-radius: 6px;
      width: 350px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .modal-filter .modal-header {
      font-weight: bold;
      margin-bottom: 12px;
      font-size: 1.1em;
    }
    .modal-filter .modal-footer {
      margin-top: 12px;
      text-align: right;
    }
    .modal-filter .modal-footer button {
      padding: 6px 12px;
      margin-left: 8px;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      cursor: pointer;
    }
    .modal-filter .modal-footer button.confirm {
      background-color: #007acc;
      color: #fff;
      border-color: #007acc;
    }
    .modal-filter .modal-footer button.cancel {
      background-color: #f0f0f0;
      color: #333;
    }
   .modal-filter .modal-content > div {
  display: flex;
  flex-direction: column;
  padding: 0;          /* remove espa√ßamentos extras */
  margin: 0;           /* remove espa√ßamentos extras */
}

/* 2) Cada label vira flex‚Äêcontainer, alinhando checkbox e texto */
/* ================================
   Alinhamento vertical e horizontal
   para cada checkbox + texto
   ================================ */
.modal-filter .modal-content > div {
  display: flex;
  flex-direction: column;
  padding: 0;
  margin: 0;
}

.modal-filter label {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  cursor: pointer;
}

.modal-filter label input[type="checkbox"] {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
  margin: 0;
}

.modal-filter label span {
  margin: 0;
  flex: 1;
}
/* ‚îÄ‚îÄ‚îÄ Encolhe toda a aba Budget Tracker para caber na tela ‚îÄ‚îÄ‚îÄ */
#budgetTracker {
  /* Chrome, Edge e Safari */
  zoom: 0.85;               
  /* Firefox (fallback) */
  transform: scale(0.85);
  transform-origin: top left;
  /* Corrige a largura para que o container ocupe 100% ajustado */
  width: calc(100% / 0.855);
}
/* ============================= */
/* Estilo para todas as budget-item */
/* ============================= */
#budgetLabels .budget-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 100px;  /* largura m√≠nima uniforme */
  gap: 4px;          /* espa√ßo entre label e valor */
}

/* Label: texto em <strong> */
#budgetLabels .budget-item > strong {
  font-size: 0.9rem;
  font-weight: bold;
}

/* Valor: horas em <span> */
#budgetLabels .budget-item > span {
  font-size: 1em !important;
  font-weight: bold !important;
}
/* ============================= */
/* Agrupa Planned e Budget juntos */
/* ============================= */
#budgetLabels {
  /* caso queira, pode mover o display e margin para c√°, mas n√£o √© obrigat√≥rio */
  display: flex;
  justify-content: space-between;
  margin: 10px 0;
  gap: 40px;  /* espa√ßamento entre os 3 grupos */
}

#budgetLabels .budget-group {
  display: flex;
  flex-direction: row;    /* agora ficam lado a lado */
  align-items: center;    /* verticalmente alinhados */
  gap: 16px;              /* espa√ßo entre Planned e Diff */
}
/* Diminui a fonte da coluna ‚ÄúTask‚Äù no modal de Planned Hours */
#plannedHoursModal table#weeklyPlannedTable th:first-child,
#plannedHoursModal table#weeklyPlannedTable td:first-child {
  font-size: 0.8rem;
}

/* =========================================================
   ‚òÖ NOVO: caixinha flutuante ‚ÄúMissing Budgets‚Äù
   ========================================================= */
#missingBudgetBox {
  display: none;                 /* come√ßa invis√≠vel            */
  position: fixed;
  top: 120px;                    /* ponto inicial na tela       */
  right: 40px;
  width: 320px;
  max-height: 60vh;              /* scroll interno se crescer   */
  overflow: auto;
  background: #fff;
  border: 1px solid #bbb;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  cursor: grab;                  /* indicador de arrastar       */
  z-index: 3100;                 /* acima dos gr√°ficos          */
}
#missingBudgetBox.grabbing { cursor: grabbing; }

#missingBudgetBox .mb-header {
  background: #004d99;
  color: #fff;
  padding: 6px 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
  border-radius: 8px 8px 0 0;
}

#missingBudgetBox .mb-header button {
  border: none;
  background: transparent;
  color: #fff;
  font-size: 16px;
  cursor: pointer;
}

#missingBudgetBox table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.82rem;
}

#missingBudgetBox th,
#missingBudgetBox td {
  border: 1px solid #ddd;
  padding: 4px 6px;
  text-align: left;
}

/* cabe√ßalho mais escuro */
#missingBudgetBox th {
  background: #004d99;   /* azul-escuro igual ao topo da caixinha  */
  color: #fff;           /* texto branco para contraste            */
  position: sticky;
  top: 0;
}
#resultTable {
  table-layout: auto;
  width: 100%;
}
/* Garantir que todas as c√©lulas da tabela n√£o quebrem linha */
#resultTable th,
#resultTable td {
  white-space: nowrap;
  padding: 4px 6px;
}

/* Colunas pequenas (auto-ajustadas para m√≠nimo poss√≠vel) */
#resultTable th:nth-child(11),  /* Hours Dec */
#resultTable td:nth-child(11),
#resultTable th:nth-child(12),  /* Total Hours */
#resultTable td:nth-child(12),
#resultTable th:nth-child(13),  /* Pay Code */
#resultTable td:nth-child(13) {
  width: 110px;       /* tamanho ideal para estes campos */
  max-width: 110px;
  text-align: center;
}
/* ‚úÖ alinha checkbox + texto bonitinho */
#comparisonPanel label {
  display: flex;
  align-items: center;
  gap: 6px;
}

#comparisonPanel label input[type="checkbox"] {
  flex: 0 0 auto;
}
/* =========================================================
   HOME TABLE: COLUMN WIDTH CONTROL (ajustar aqui)
   Colunas (#resultTable):
   1 Employee | 2 Type | 3 Person | 4 Worker Type | 5 Supervisor
   6 Role | 7 Date | 8 Week | 9 Month | 10 Labour | 11 Dep.
   12 Task | 13 Hours Dec. | 14 Total Hours | 15 Pay Code
   ========================================================= */

#resultTable{
  table-layout: fixed !important;  /* ‚úÖ for√ßa a respeitar widths */
}

/* ‚úÖ Ajusta s√≥ estes n√∫meros */
#resultTable{
  --c1: 162px;  /* Employee */
  --c2: 105px;   /* Type */
  --c3: 88px;  /* Person Number */
  --c4: 70px;  /* Worker Type */
  --c5: 95px;  /* Supervisor */
  --c6: 60px;   /* Role */
  --c7: 105px;  /* Date */
  --c8: 30px;   /* Week */
  --c9: 55px;   /* Month */
  --c10: 155px; /* Labour Account */
  --c11: 40px;  /* Dep. */
  --c12: 160px; /* Task (a tua ‚Äúcoluna rainha‚Äù) */
  --c13: 60px;  /* Hours Dec. */
  --c14: 65px;  /* Total Hours */
  --c15: 80px;  /* Pay Code */
}

/* aplica as larguras */
#resultTable th:nth-child(1),  #resultTable td:nth-child(1)  { width: var(--c1); }
#resultTable th:nth-child(2),  #resultTable td:nth-child(2)  { width: var(--c2); }
#resultTable th:nth-child(3),  #resultTable td:nth-child(3)  { width: var(--c3); }
#resultTable th:nth-child(4),  #resultTable td:nth-child(4)  { width: var(--c4); }
#resultTable th:nth-child(5),  #resultTable td:nth-child(5)  { width: var(--c5); }
#resultTable th:nth-child(6),  #resultTable td:nth-child(6)  { width: var(--c6); }
#resultTable th:nth-child(7),  #resultTable td:nth-child(7)  { width: var(--c7); }
#resultTable th:nth-child(8),  #resultTable td:nth-child(8)  { width: var(--c8); text-align:center; }
#resultTable th:nth-child(9),  #resultTable td:nth-child(9)  { width: var(--c9); }
#resultTable th:nth-child(10), #resultTable td:nth-child(10) { width: var(--c10); }
#resultTable th:nth-child(11), #resultTable td:nth-child(11) { width: var(--c11); text-align:center; }
#resultTable th:nth-child(12), #resultTable td:nth-child(12) { width: var(--c12); }
#resultTable th:nth-child(13), #resultTable td:nth-child(13) { width: var(--c13); text-align:center; }
#resultTable th:nth-child(14), #resultTable td:nth-child(14) { width: var(--c14); text-align:center; }
#resultTable th:nth-child(15), #resultTable td:nth-child(15) { width: var(--c15); }

/* (opcional) se o bot√£o "Pay Code ‚ñæ" estiver a ‚Äúempurrar‚Äù a coluna */
#openPayCodePanel{
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* ‚úÖ Diminui a fonte s√≥ do corpo da tabela (n√£o mexe no cabe√ßalho) */
#resultTable tbody td {
  font-size: 0.80rem;   /* ajusta: 0.75 / 0.8 / 0.85 */
}

  </style>
</head>
<body>
  <div class="top-bar">
    Budget Tracker ‚Äì Planned &amp; Consumed Hours
    <div class="bottom-right">Victor Ribeiro &reg; (Solutions) &copy;</div>
  </div>

  <div id="main-content">
    <!-- Nav Tabs -->
    <div class="nav-tabs">
      <button data-tab="home" class="active">Home</button>
      <button data-tab="budgetTracker">Budget Tracker</button>
      <button data-tab="dashboard">Dashboard</button>
    </div>

    <!-- Home Tab -->
<div id="home" class="tab-content active">
  <details id="controlsAccordion">
    <summary>Show/Hide Data Controls</summary>

    <div id="controls">

      <!-- ‚úÖ AGY OT MODE TOGGLE (antes do Choose File) -->
      <div id="agyOtModeWrap" style="display:flex; align-items:center; gap:10px; margin:8px 0;">
        <span style="font-weight:700;">AGY OT:</span>

        <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
          <input type="radio" name="agyOtMode" id="agyOtWeekly" value="weekly">
          <span>Weekly</span>
        </label>

        <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
          <input type="radio" name="agyOtMode" id="agyOtPeriod" value="period">
          <span>Period</span>
        </label>

        <span id="agyOtModeHint" style="opacity:.75; font-size:.9em;"></span>
      </div>
      <!-- ‚úÖ END AGY OT MODE TOGGLE -->

      <input type="file" id="fileInput">

      <button id="processFileButton">Process File</button>
      <button id="clearDataButton">Clear Data</button>

      <!-- ‚úÖ Employee Master (FT/PT) -->
      <div style="margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
        <div style="font-weight:700; margin-bottom:6px;">Employee Master (FT/PT)</div>

        <input type="file" id="employeeMasterInput" accept=".csv,.txt">
        <button type="button" id="employeeMasterUploadBtn">Upload Master</button>

        <div id="employeeMasterStatus" style="margin-top:6px; font-size:0.85rem; color:#555;">
          No master file loaded.
        </div>
      </div>
      <!-- ‚úÖ END Employee Master -->

      <div id="dateControls">
        <input type="date" id="startDate">
        <input type="date" id="endDate">
        <button id="filterByDateButton">Filter by Date</button>
      </div>

      <div id="budgetControls">
        <input type="number" id="budgetInput"
               placeholder="Enter Planned Budget"
               oninput="updateResult()">
      </div>

    </div>
  </details>
  <div class="totals-labels">
    <div>Gross Hours: <span id="grossHours">0:00</span></div>
    <div>Logged Hours: <span id="loggedHours">0:00</span></div>
    <div>Missing Task Hours: <span id="depTotalHours">0:00</span></div>
    <div>
      Over Time: 
      <span id="overtimeHours">0:00</span>
      (<span id="overtimePercent">0%</span>)
    </div>
  </div>


      <div id="slicer">
        <button class="filter-button" data-department="Ecom">Ecom</button>
        <button class="filter-button" data-department="Retail">Retail</button>
        <button class="filter-button" data-department="Break" id="filterByBreakButton">Break</button>
        <button class="filter-button active" data-department="All">All</button>
        <div id="weekDropdown">
          <select id="selectWeek">
            <option value="">Select Week</option>
          </select>
        </div>
        <div id="monthDropdown">
          <select id="selectMonth">
            <option value="">Select Month</option>
          </select>
        </div>
        <button class="filter-button" id="toggleResultButton">Show/Hide Result</button>
        <div id="codeFilterContainer" style="display: inline-block; margin-left: 10px;">
          <select id="codeFilter" style="padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">
            <option value="all">All</option>
            <option value="missingTask">Missing Task</option>
            <option value="manager">Manager</option>
            <option value="operative">Operative</option>
            <option value="overtime">OT > 40h (Week)</option>
            <option value="fulltime">Full Time</option>
            <option value="parttime">Part Time</option>

          </select>
        </div>
      </div>

      <div id="secondaryButtons">
        <div id="headcountLabel" style="display:inline-block; margin-right:20px;">
          <strong>Headcount:</strong>
          <span id="headcountCount">0</span>
        </div>
        <button class="filter-button" id="downloadExcelButton" style="background-color: #28a745; color: white;">
          Download Excel Report Between Dates
        </button>
        <button class="filter-button" id="clearHistoryButton">C. History</button>
        <div id="missingTaskLabel" style="display:inline-block; margin-left:20px;">
  <strong>Missing Task:</strong>
  <span id="missingTaskCount" class="highlight-number">0</span>
  <span id="missingTaskHours" style="margin-left:8px;">0:00 (0.00%)</span>
</div>

      </div>

      <!-- Password Modal -->
      <div id="passwordModal" class="modal">
        <div class="modal-content">
          <p>Enter Password</p>
          <input type="password" id="passwordInput">
          <div class="modal-buttons">
            <button id="confirmPasswordButton" class="confirm-button">OK</button>
            <button id="cancelPasswordButton" class="cancel-button">Cancel</button>
          </div>
          <p id="errorMessage" style="color: red; display: none;">Incorrect password. Please try again.</p>
        </div>
      </div>

      <!-- Date Modal -->
      <div id="dateModal" class="modal">
        <div class="modal-content">
          <p>Select Date Range to Clear History</p>
          <input type="date" id="clearStartDate">
          <input type="date" id="clearEndDate">
          <div class="modal-buttons">
            <button id="confirmDateButton" class="confirm-button">OK</button>
            <button id="cancelDateButton" class="cancel-button">Cancel</button>
          </div>
        </div>
      </div>

      <div id="resultBox"></div>

<div id="result">
  <table id="resultTable">
    <thead>
  <tr>
    <!-- 1) Employee + filtro por nome + OT>40h -->
    <th>
  <div style="display:flex; align-items:center; gap:3px; justify-content:flex-start;">
    <span>Employee</span>
    <input class="filter-input" type="text" id="employeeFilter" placeholder="Filter" style="flex:1; min-width:0;">
  </div>
</th>



    <!-- 2) TYPE -->
    <th>
      <div style="display:flex; align-items:center; justify-content:space-between; gap:3px;">
        <span>Type</span>
        <select id="typeFilter"
                style="font-size:0.8rem; padding:2px; width:80px; flex-shrink:0;">
          <option value="">All</option>
          <option value="CORE">CORE</option>
          <option value="AGY J&T">AGY J&T</option>
          <option value="AGY 247">AGY 247</option>
        </select>
      </div>
    </th>


    <!-- 3) resto igual ao original, apenas ‚Äúdeslocado‚Äù para a frente -->
    <th>Person Number</th>
<th>Worker Type</th>
<th>Supervisor</th>
<th>Role</th>

    <th>
      <div style="display: flex; align-items: center; gap:3px; justify-content: flex-start;">
        <span>Date</span>
        <select id="dateFilter"style="font-size: 0.8rem; padding: 2px; width: 90px; flex-shrink: 0;">

          <option value="">All</option>
        </select>
      </div>
    </th>
    <th>Week</th>
    <th>Month</th>
    <th>
  <div style="display: flex; align-items: center; gap:3px; justify-content: flex-start;">
    <span>Labour Account</span>
    <input class="filter-input" type="text" id="labourAccountFilter" placeholder="Filter" style="flex:1; min-width:0;">
  </div>
</th>

    <th>Dep.</th>
    <th>
  <div style="display: flex; align-items: center; gap:3px; justify-content: flex-start;">
    <span>Task</span>
    <input class="filter-input" type="text" id="taskFilter" placeholder="Filter" style="width: 95px;">
  </div>
</th>


<!-- NOVO: coluna de horas em decimal -->
<th>Hours Dec.</th>

<th>Total Hours</th>

<th style="overflow: visible;">
  <div style="display: flex; align-items: center; gap: 3px; justify-content: flex-start; position: relative;">



  <!-- üîπ Bot√£o passa a ser o ‚Äúcabe√ßalho‚Äù Pay Code -->
  <button
    id="openPayCodePanel"
    style="
      font-size: 0.75rem;
      padding: 2px 6px;
      cursor: pointer;
      flex-shrink: 0;
      white-space: nowrap;
    "
  >
    Pay Code ‚ñæ
  </button>

    <!-- üîπ Dropdown ORIGINAL (agora escondido s√≥ para l√≥gica interna) -->
  <select
    id="payCodeFilter"
    style="display:none;"
  >
    <option value="">All</option>
  </select>

  <!-- üîπ Painel MULTI-SELE√á√ÉO de Pay Codes ‚Äì estilo Selfridges Gold -->
  <div id="payCodeMultiPanel"
       style="
         display:none;
         position:absolute;
         top:22px;
         right:0;
         left:auto;
         z-index:999999;

         background:#000000;
         color:#f5d10d;
         border:1px solid #f5d10d;
         box-shadow:0 4px 12px rgba(0,0,0,0.4);
         border-radius:8px;
         padding:10px 12px;
         max-height:320px;
         width:220px;
         font-size:0.8rem;
       ">

    <!-- Cabe√ßalho dourado -->
    <div style="
          font-weight:bold;
          margin:-10px -12px 8px -12px;
          padding:6px 10px;
          background:linear-gradient(90deg,#000000,#222222);
          color:#f5d10d;
          border-radius:8px 8px 0 0;
          border-bottom:1px solid #f5d10d;
        ">
      Select Pay Codes
    </div>

    <!-- Corpo com lista de checkboxes -->
    <div id="payCodeMultiBody"
         style="
           display:flex;
           flex-direction:column;
           gap:4px;
           max-height:230px;
           overflow-y:auto;
           background:#111111;
           border:1px solid #333333;
           padding:6px;
           border-radius:4px;
         ">
      <!-- checkboxes s√£o criados via JS -->
    </div>

    <!-- Rodap√© com bot√µes -->
    <div style="
          display:flex;
          justify-content:space-between;
          align-items:center;
          margin-top:10px;
        ">
      <button id="payCodeMultiClear"
              style="
                padding:4px 8px;
                font-size:0.75rem;
                border-radius:4px;
                border:1px solid #f5d10d;
                background:transparent;
                color:#f5d10d;
                cursor:pointer;
              ">
        Clear
      </button>

      <div>
        <button id="payCodeMultiCancel"
                style="
                  padding:4px 8px;
                  font-size:0.75rem;
                  border-radius:4px;
                  border:1px solid #666666;
                  background:#222222;
                  color:#f5d10d;
                  cursor:pointer;
                  margin-right:4px;
                ">
          Cancel
        </button>
        <button id="payCodeMultiOk"
                style="
                  padding:4px 10px;
                  font-size:0.75rem;
                  border-radius:4px;
                  border:1px solid #f5d10d;
                  background:#f5d10d;
                  color:#000000;
                  font-weight:bold;
                  cursor:pointer;
                ">
          OK
        </button>
      </div>
    </div>

  </div>


           <tbody>
            <!-- Rows ser√£o adicionadas dinamicamente -->
          </tbody>
        </table>
      </div>

      <div id="totalsBox">
        <div>Total Hours Ecom: <span id="totalEcom">0:00</span></div>
        <div>Total Hours Retail: <span id="totalRetail">0:00</span></div>
        <div>Total Hours Paid Break: <span id="totalBreak">0:00</span></div>
      </div>

    </div> <!-- ‚úÖ FECHA A TAB HOME AQUI (div id="home") -->

    <!-- Budget Tracker Tab -->
    <div id="budgetTracker" class="tab-content">
      <button id="openPlannedHoursModal" class="filter-button">Set Weekly Planned Hours</button>
      <input type="text" id="modalTaskFilter" placeholder="Filter task" class="filter-input" style="margin-left:10px;">
      <button id="openEditHoursModal" class="filter-button" style="margin-left:10px;">Edit Hours</button>
      <button id="downloadBudgetReport" class="filter-button" style="margin-left:10px;">
       Download Budget Report</button>
       <div id="budgetLabels" style="display:flex; justify-content:space-between; margin:10px 0;">
  <!-- 1) Total Consumed isolado -->
  <div class="budget-item">
    <strong>Total Consumed:</strong>
    <span id="totalConsumed">0:00</span>
  </div>

  <!-- 2) Grupo Planned -->
  <div class="budget-group">
    <div class="budget-item">
      <strong id="plannedLabel">Planned Hours</strong>
      <span id="totalPlanned">443:00</span>
    </div>
    <div class="budget-item">
      <strong>Planned Diff.:</strong>
      <span id="totalDifference">+18036:15:36</span>
    </div>
  </div>


  <!-- 3) Grupo Budget -->
  <div class="budget-group">
    <div class="budget-item">
      <strong>Budget (Logged Tasks):</strong>
      <span id="totalBudget">650:00</span>
    </div>
    <div class="budget-item">
      <strong>Budget Diff.:</strong>
      <span id="totalBudgetDifference">+17829:15:36</span>
    </div>
  </div>
</div>



      <table id="budgetTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Day of Week</th>
            <th>Task</th>
            <th>Consumed Hours</th>
            <th>Planned Hours</th>
            <th>Difference</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows ser√£o geradas dinamicamente -->
        </tbody>
      </table>
    </div>

    <!-- Dashboard -->
    <div id="dashboard" class="tab-content">
      <div style="text-align: right; margin-bottom: 10px; display: flex; justify-content: flex-end; gap: 12px;">
        <button id="downloadPdfDashboard"
          style="
            background: #fff;
            color: #004d99;
            border: 1.5px solid #004d99;
            padding: 7px 18px;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.18s, color 0.18s, border-color 0.18s;
          "
          onmouseover="this.style.background='#004d99';this.style.color='#fff';"
          onmouseout="this.style.background='#fff';this.style.color='#004d99';"
        >
          &#128190; Download PDF
        </button>
        <button 
          id="toggleComparisonPanel"
          style="
            background: #eee;
            color: #1c2340;
            border: 1.5px solid #bbb;
            padding: 7px 14px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-left: 4px;
            box-shadow: 0 2px 7px rgba(0,0,0,0.09);
            transition: background 0.15s, color 0.18s, border-color 0.18s;
            display: flex; align-items: center; gap: 6px;
          "
          title="Show/Hide Ecom vs Retail Panel"
        >
          <span id="toggleIcon" style="font-size:17px;">&#128200;</span>
          <span>Comparison Panel</span>
        </button>
      </div>

      <div id="kpiCards" style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin-bottom: 25px;">
  <div class="kpi-card">
    <div class="kpi-label">Consumed Hours</div>
    <div class="kpi-value" id="kpiConsumed">0:00</div>
  </div>

  <div class="kpi-card">
    <div class="kpi-label" id="dashboardPlannedLabel">Planned Hours</div>
    <div class="kpi-value" id="kpiPlanned">0:00</div>
  </div>
 <div class="kpi-card" style="position:relative;">
  <div class="kpi-label" id="kpiBudgetLabel">Budget Total</div>
  <div class="kpi-value" id="kpiBudgetTotal">0:00</div>

  <!-- √≠cone toggle -->
  <button id="toggleBudgetMode"
          title="Mostrar only vis√≠veis / total"
          style="position:absolute; top:6px; right:6px;
                 border:none; background:transparent; cursor:pointer;
                 font-size:16px; line-height:1;">
    üîÑ
  </button>

  <!-- ‚òÖ NOVO bot√£o lupa ‚Äì tasks com budget, 0 h no CSV -->
  <button id="showMissingBudgets"
          title="Listar tasks com budget mas sem consumo"
          style="position:absolute; top:28px; right:6px;
                 border:none; background:transparent; cursor:pointer;
                 font-size:16px; line-height:1;">
    üîç
  </button>
</div>


  <!-- ‚òÖ NOVO cart√£o: Budget (fica logo depois de Planned Hours) -->
  <div class="kpi-card">
    <div class="kpi-label">Budget Remaining</div>
    <!-- valor vem via JS ‚Äì mesmo estilo das outras KPI-values -->
    <div class="kpi-value" id="kpiBudget">0:00</div>
  </div>

  <div class="kpi-card">
    <div class="kpi-label">Utilization</div>
    <div class="kpi-value" id="kpiUtil">0%</div>
  </div>

  <div class="kpi-card">
    <div class="kpi-label">Headcount</div>
    <div class="kpi-value" id="kpiHeadcount">0</div>
  </div>

  <div class="kpi-card">
    <div class="kpi-label">Missing Task</div>
    <div class="kpi-value" id="kpiMissing">0</div>
  </div>
</div>


      <div style="display: flex; flex-wrap: wrap; gap: 25px; justify-content: center;">
        <div style="flex: 1; min-width: 350px;">
          <canvas id="trendChart" height="160"></canvas>
        </div>
        <div style="flex: 1; min-width: 350px;">
          <canvas id="deptChart" height="160"></canvas>
        </div>
        <div style="flex: 1; min-width: 350px;">
          <canvas id="tasksChart" height="160"></canvas>
        </div>
      </div>

      <div id="tasksBarContainer" style="position: relative; width: 100%; margin-top: 30px;">
        <canvas id="tasksBarChart" style="width: 100%; height: 260px;"></canvas>
        <button id="toggleValues" title="Mostrar valores"
                style="position: absolute; top: 8px; left: 8px; width: 20px; height: 20px;
                       background: transparent; border: none; cursor: pointer;
                       transition: border 0.2s, background 0.2s; z-index: 10;">
          <span style="font-size: 14px; color: #666; opacity: 0; transition: opacity 0.2s;">‚Ä¢</span>
        </button>
      </div>
    </div>
    <!-- /fecha #dashboard -->

    <!-- In√≠cio do painel de compara√ß√£o (com dropdown de dias) -->
<div id="comparisonPanel"
     style="position: fixed; top: 0; left: 0; width: 100vw; height: 97vh;
            background: #fff; box-shadow: 0 8px 40px rgba(0,0,0,0.17);
            padding: 18px 14px 30px 18px; overflow-y: auto; z-index: 2000;">
  <div style="position: relative; width: 100%; margin-bottom: 10px; height: 28px;">
    <h3 style="
          margin: 0;
          position: absolute;
          left: 61%;
          transform: translateX(-50%);
          top: 50%;
          transform-origin: center;
          translate: -50% -50%;
        ">
      Ecom vs Retail: Consumed vs Planned
    </h3>

    <!-- ‚Üì Dropdown de sele√ß√£o de dia, rec√©m-inserido √† esquerda do ‚Äú‚úñ‚Äù ‚Üì -->
    <select id="selectComparisonDay"
            style="
              position: absolute;
              top: 50%;
              right: 75px;
              transform: translateY(-50%);
              padding: 2px 6px;
              font-size: 0.9rem;
              border-radius: 4px;
              border: 1px solid #ccc;
              background: #fff;
              cursor: pointer;
            ">
      <option value="">All Days</option>
    </select>

    <button id="closeComparisonPanel"
          style="
            position: absolute;
            top: 50%;
            right: 35px;
            transform: translateY(-50%);
            font-size: 22px;
            background: none;
            border: none;
            color: #c1121f;
            cursor: pointer;
            line-height: 1;
            padding: 3px 7px;
            border-radius: 50%;
            transition: background 0.15s;
          ">
      ‚úñ
    </button>
  </div>

  <div id="comparisonPanelContent">

    <!-- ‚Üì NOVO: painel de detalhe, escondido at√© o hover ‚Üì -->
    <div id="detailContainer" style="display:none; margin-bottom:20px;">
      <h4 id="detailTitle" style="text-align:center; margin:0 0 8px 0;"></h4>
      <canvas id="detailChart" style="width:100%; height:200px;"></canvas>
      <button id="closeDetail"
              style="display:block; margin:8px auto; padding:4px 8px; border:none;
                     background:#c1121f; color:#fff; border-radius:4px; cursor:pointer;">
        Fechar detalhe
      </button>
    </div>

    <!-- ECOM Chart + Bot√£o de Filtro -->
    <div class="comparison-row" style="margin-bottom: 30px; position: relative;">
      <h4 style="margin: 0 0 6px 0;">Ecom</h4>
      <button id="openEcomFilterBtn"
              style="position: absolute; top: 0; left: 20px;
                     background: #007acc; color: #fff; border: none;
                     border-radius: 4px; padding: 2px 6px; font-size: 0.8rem;
                     cursor: pointer;">
        ‚öô Filtrar
      </button>
      <canvas id="ecomComparisonChart" style="margin-top: 12px; width: 100%; height: 200px;"></canvas>
    </div>

    <!-- RETAIL Chart + Bot√£o de Filtro -->
    <div class="comparison-row" style="margin-bottom: 30px; position: relative;">
      <h4 style="margin: 0 0 6px 0;">Retail</h4>
      <button id="openRetailFilterBtn"
              style="position: absolute; top: 0; left: 20px;
                     background: #007acc; color: #fff; border: none;
                     border-radius: 4px; padding: 2px 6px; font-size: 0.8rem;
                     cursor: pointer;">
        ‚öô Filtrar
      </button>
      <canvas id="retailComparisonChart" style="margin-top: 12px; width: 100%; height: 200px;"></canvas>
    </div>

  </div>
</div>
<!-- Fim do painel de compara√ß√£o -->

<!-- Fim do painel de compara√ß√£o -->

    <!-- ===== Modal de Filtro Ecom ===== -->
    <div id="ecomFilterModal" class="modal-filter">
      <div class="modal-content">
        <div class="modal-header">Filtrar Ecom Tasks</div>
        <div id="ecomTasksModalContainer">
          <!-- Checkboxes de Ecom ser√£o injetados aqui via JavaScript -->
        </div>
        <div class="modal-footer">
          <button class="cancel" onclick="closeEcomModal()">Cancelar</button>
          <button class="confirm" onclick="applyEcomFilter()">OK</button>
        </div>
      </div>
    </div>

    <!-- ===== Modal de Filtro Retail ===== -->
    <div id="retailFilterModal" class="modal-filter">
      <div class="modal-content">
        <div class="modal-header">Filtrar Retail Tasks</div>
        <div id="retailTasksModalContainer">
          <!-- Checkboxes de Retail ser√£o injetados aqui via JavaScript -->
        </div>
        <div class="modal-footer">
          <button class="cancel" onclick="closeRetailModal()">Cancelar</button>
          <button class="confirm" onclick="applyRetailFilter()">OK</button>
        </div>
      </div>
    </div>
  </div>

  <div id="plannedHoursModal" class="modal">
  <div class="modal-content" style="width: 800px; max-height: 80vh; overflow-y: auto;">
    <h3>Set Weekly Planned Hours</h3>

    <p style="margin: 6px 0; font-size: 0.85rem; color: #555;">
      You can enter time as <strong>HH:MM</strong> (e.g. <strong>07:30</strong>)
      or as <strong>decimal hours</strong> (e.g. <strong>7,5</strong> or <strong>285.38</strong>).
      The system will automatically convert everything to HH:MM.
    </p>


    <!-- 1) Seletor de Semana -->
    <div style="margin-bottom: 12px;">
      <label for="modalWeekNumber">Semana n¬∫:</label>
      <input type="number" id="modalWeekNumber" min="1" max="53"
             style="width: 60px; padding:4px; margin-left:6px;">
    </div>

    <!-- 2) Filtro de Task -->
    <div style="margin-bottom: 12px;">
      <label for="setModalTaskFilter">Filter Task:</label>
      <input type="text" id="setModalTaskFilter" class="filter-input" style="margin-left:6px;">
    </div>

    <!-- 3) Tabela 7 dias √ó N tasks -->
    <div style="overflow-x: auto; margin-bottom: 12px;">
      <table id="weeklyPlannedTable" style="width: 100%; border-collapse: collapse;">
        <thead>
          <tr>
            <th style="border:1px solid #ddd; padding:6px;">Task</th>
            <!-- Cabe√ßalhos dos 7 dias ser√£o criados dinamicamente -->
          </tr>
        </thead>
        <tbody>
          <!-- Linhas de tasks + inputs HH:MM -->
        </tbody>
      </table>
    </div>

    <!-- 4) Bot√µes -->
    <div class="modal-buttons" style="justify-content: center; gap: 16px;">
      <button id="confirmPlannedHours" class="confirm-button">OK</button>
      <button id="cancelPlannedHours" class="cancel-button">Cancel</button>
    </div>
  </div>
</div>


  <!-- Modal for Editing Planned Hours -->
<div id="editHoursModal" class="modal">
  <div class="modal-content">

    <p style="font-size: 1.1rem; font-weight: bold; margin-bottom: 10px;">
      Edit Planned Hours
    </p>

    <p style="margin: 6px 0; font-size: 0.85rem; color: #555;">
      Enter the planned time in <strong>HH:MM</strong> (e.g. <strong>07:30</strong>)
      or in <strong>decimal hours</strong> (e.g. <strong>7.5</strong>, <strong>7,5</strong>,
      <strong>25.50</strong> or <strong>25,50</strong>).
      The system will convert everything to HH:MM and store it internally as decimal hours.
    </p>

    <label for="editModalTaskFilter">Filter Task:</label>
    <input type="text" id="editModalTaskFilter" class="filter-input">
    <br>

    <label for="editModalTask">Task:</label>
    <select id="editModalTask">
      <option value="">Select Task</option>
      <!-- Options ser√£o populadas dinamicamente -->
    </select>
    <br>

    <label for="editModalSelectedDay">Select Day:</label>
    <input type="date" id="editModalSelectedDay">
    <br>

    <label for="editModalDayPlanned">Planned Hours for that Day:</label>
    <input type="text" id="editModalDayPlanned" placeholder="HH:MM">
    <br>

    <div class="modal-buttons">
      <button id="confirmEditHours" class="confirm-button">OK</button>
      <button id="cancelEditHours" class="cancel-button">Cancel</button>
    </div>

  </div>
</div>


  <!-- Modal de senha para Edit Hours -->
  <div id="editHoursPasswordModal" class="modal">
    <div class="modal-content">
      <p>Enter password to Edit Hours</p>
      <input type="password" id="editHoursPasswordInput">
      <div class="modal-buttons">
        <button id="confirmEditHoursPasswordButton" class="confirm-button">OK</button>
        <button id="cancelEditHoursPasswordButton" class="cancel-button">Cancel</button>
      </div>
      <p id="editHoursErrorMessage" style="color: red; display: none;">
        Incorrect password. Please try again.
      </p>
    </div>
  </div>
<!-- Modal de detalhe di√°rio -->
<div id="dailyDetailModal" class="modal-filter">
  <div class="modal-content" style="
      width: 90vw;
      max-width: 700px;
      height: 90vh;
      display: flex;
      flex-direction: column;
      padding: 16px;
      box-sizing: border-box;
    ">
    <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center;">
      <span id="dailyDetailTitle">Detalhe Di√°rio</span>
      <button id="closeDailyDetailBtn"
              type="button"
              style="background: none; border: none; font-size: 20px; cursor: pointer;">
        ‚úñ
      </button>
    </div>
    <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
      <canvas id="dailyDetailChart" style="width: 100%; height: 100%;"></canvas>
    </div>
  </div>
</div>
<!-- ‚òÖ NOVA caixinha flutuante ‚Äì Missing Budgets -->
<div id="missingBudgetBox">
  <div class="mb-header">
    <span>Tasks com Budget &amp; 0&nbsp;h</span>
    <button id="closeMissingBudgets" title="Fechar">‚úñ</button>
  </div>
  <div class="mb-body">
    <!-- A tabela ser√° injetada via JavaScript -->
  </div>
</div>

  <!-- External Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

    <script>
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Vari√°veis Globais ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // ============================================
  // ETAPA 2: Preencher painel de Pay Codes
  // a partir do dropdown #payCodeFilter existente
  // ============================================
  function rebuildPayCodeMultiPanelFromDropdown() {
  const container = document.getElementById('payCodeMultiBody');
  if (!container) return;

  // Guarda o que j√° estava marcado antes
  const previouslyChecked = new Set();
  container.querySelectorAll('input[type="checkbox"]:checked')
    .forEach(cb => previouslyChecked.add(cb.value));

  // Limpa o painel
  container.innerHTML = '';

  // Gera a lista de Pay Codes √∫nicos a partir do storedData
  const uniqueCodes = new Set(
    (storedData || [])
      .map(entry => (entry.payCode || '').trim())
      .filter(code => code !== '')
  );

  // Se ainda n√£o h√° Pay Codes, mostra uma mensagenzinha
  if (uniqueCodes.size === 0) {
    const info = document.createElement('div');
    info.style.fontSize = '0.8rem';
    info.style.color = '#777';
    info.textContent = 'No Pay Codes loaded yet.';
    container.appendChild(info);
    return;
  }

  // üîπ NOVO: converte para array e ordena os Pay Codes (A‚ÄìZ)
  const sortedCodes = Array.from(uniqueCodes).sort((a, b) => a.localeCompare(b));

  // Cria um checkbox para cada Pay Code, j√° ordenado
  sortedCodes.forEach(code => {
    const label = document.createElement('label');
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    label.style.gap = '6px';
    label.style.fontSize = '0.8rem';
    label.style.cursor = 'pointer';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = code;

    // Se j√° estava marcado antes, mant√©m marcado
    if (previouslyChecked.has(code)) {
      checkbox.checked = true;
    }

    const span = document.createElement('span');
    span.textContent = code;

    label.appendChild(checkbox);
    label.appendChild(span);
    container.appendChild(label);
  });
}



  // üîπ NOVO: ao carregar a p√°gina, tenta montar o painel (se j√° houver op√ß√µes)
  document.addEventListener('DOMContentLoaded', () => {
    rebuildPayCodeMultiPanelFromDropdown();
  });

const taskMapping = {
  "1007680000": "R.Missing Task",
  "1007681300": "R.Retail Putaway",
  "1007681322": "R.Aged Putaway",
  "1007681400": "R.Concession XDock",
  "1007681404": "R.FastTrack",
  "1007681500": "R.RTWs",
  "1007681530": "R.RTV Warehouse",
  "1007682000": "R.Retail Loading",
  "1007682100": "R.Retail Pick",
  "1007683200": "R.Retail Inventory",
  "1007683252": "R.Queries",
  "1007683311": "R.Retail Administration",
  "1007683550": "R.Selfridges Internal Xcharge",
  "1007684010": "R.Paid Break",
  "1007684035": "R.Briefing",
  "1007684037": "R.Meeting",
  "1007684042": "R.Performance Coaches",
  "1007684044": "R.Training (Core)",
  "1007684046": "R.OMS Training",
  "1007684054": "R.Housekeeping",
  "1007684072": "R.Union",
  "1007688009": "R.Warehouse FLM",
  "1007688198": "R.Exceptions - NonFashion",
  "1007688206": "R.Training (Agency), Induction",
  "1007688223": "R.Retail Marshalling",
  "1007688224": "R.PI",
  "1007688332": "R.Consolidation",
  "1007688338": "R.OMS Control Room",
  "1007688339": "R.RTV Admin",
  "1007683250": "R.QC Checking",
  "1007686000": "R.Trainers",
  "1007688412": "R.Price Changes",
  "1007688433": "R.Exceptions - Fashion",
  "1007688434": "R.Exceptions - Food",
  "1007688436": "R.Senior Managers",
  "1007688437": "R.Receiving",
  "1007688438": "R.Cosmetics F/T Processing+C.Group 63 T",
  "1007688439": "R.Ladies Fashion",
  "1007688440": "R.Accessories",
  "1007688441": "R.Menswear Fashion",
  "1007688442": "R.Children/Toys/Games proc. & Ticketing",
  "1007688444": "R.Books",
  "1007688445": "R.Children",
  "1007688446": "R.Home Accessories (Non Fashion)",
  "1007688452": "R.Pins & Tags",
  "1007688453": "R.Food Processing",
  "1007688454": "R.Zetes",
  "1007688455": "R.Cosmetics P/A Processing",
  "1007688457": "R.Exceptions - Beauty",
  "1007688458": "R.Cubiscan",
  "1007650000": "E.Missing Task",
  "1007651300": "E.Ecom Putaway",
  "1007651500": "E.Returns",
  "1007651524": "E.Returns putaway",
  "1007652000": "E.Despatch",
  "1007652100": "E.Ecom Pick",
  "1007652312": "E.Ecom VNA Drop",
  "1007652400": "E.Packing",
  "1007653200": "E.Ecom Inventory",
  "1007653250": "E.QC Checking",
  "1007653252": "E.Goods In queries",
  "1007653311": "E.Ecom Administration",
  "1007654010": "E.Paid Break",
  "1007654035": "E.Briefs",
  "1007654037": "E.Meetings",
  "1007654042": "E.OMS Coaches",
  "1007654044": "E.Training (Core)",
  "1007654046": "E.OMS Training",
  "1007654054": "E.Housekeeping",
  "1007654072": "E.Union",
  "1007656000": "E.Trainers",
  "1007658009": "E.Warehouse FLM",
  "1007658198": "E.Exceptions",
  "1007658206": "E.Training (Agency), Induction",
  "1007658223": "E.Ecom Marshalling",
  "1007658224": "E.Inventory Pick",
  "1007658332": "E.Consolidation",
  "1007658337": "E.Packaging Admin",
  "1007658338": "E.OMS Control Room",
  "1007658339": "E.Concessions RTVs",
  "1007658340": "E.Wave Running",
  "1007658342": "E.hazard",
  "1007683550": "E.Selfridges Internal Xcharge",
  "1007658361": "E.Inventory Photo studio",
  "1007658384": "E.Cage pick",
  "1007658388": "E.Cage pack",
  "1007658430": "E.Jo Malone",
  "1007658431": "E.Entrupy",
  "1007658432": "E.Gift boxes",
  "1007658436": "E.Senior Managers",
  "1007658452": "E.Pins & Tags",
  "1007658456": "E.Goods In CN Proc.",
  "1007658459": "E.Packaging Stock Count",
  "1007658597": "E.Transport"
};

    let storedData            = JSON.parse(localStorage.getItem('csvData') || '[]');
let plannedHoursTracker   = JSON.parse(localStorage.getItem('plannedHoursTracker') || '{}');
let currentDepartmentFilter = 'All';
let grossMinutes          = 0;
let originalTotalMinutes  = 0;
let showValues = false;
let toggleListenerAdded = false;
let currentCodeFilter = '';


/* ‚ñº NOVO: controla o modo do cart√£o Budget Total (true = total; false = vis√≠veis) */
let showBudgetTotal = true;

// Novas vari√°veis de estado para filtros de Comparison Panel
let selectedEcomTasks   = [];
let selectedRetailTasks = [];


    // formata segundos totais em "HH:MM:SS"
    function formatTime(totalSeconds) {
  // ‚úÖ Blindagem contra floats (ex.: 65160.00000000001)
  const sec = Math.round(Number(totalSeconds) || 0);

  const hours     = Math.floor(sec / 3600);
  const remainder = sec % 3600;
  const minutes   = Math.floor(remainder / 60);
  const seconds   = remainder % 60;

  const hh = String(hours).padStart(2, '0');
  const mm = String(minutes).padStart(2, '0');
  const ss = String(seconds).padStart(2, '0');

  return `${hh}:${mm}:${ss}`;
}

    function formatTimeHHMM(totalSeconds) {
  totalSeconds = Math.round(Number(totalSeconds) || 0); // ‚úÖ trava floats

  const hours   = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);

  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}

// Ex.:  120 seg  -> "+00:02:00"
//      -240 seg  -> "-00:04:00"
function formatSignedTime(seconds) {
  const sign = seconds < 0 ? '-' : '+';
  const abs  = Math.round(Math.abs(Number(seconds) || 0)); // ‚úÖ trava floats
  return sign + formatTime(abs);
}



    const managersList = [
      { name: "Akash Mohammed", personNumber: "82610253992" },
      { name: "Ambrutis Skirmantas", personNumber: "82610122024" },
      { name: "Antaluta Roxana Elena", personNumber: "82610134667" },
      { name: "Askew Christopher", personNumber: "82610105763" },
      { name: "Balde Mamadou", personNumber: "82610128333" },
      { name: "Bereza Raluca", personNumber: "82610124836" },
      { name: "Burton Adam", personNumber: "82610126261" },
      { name: "Busby Ian", personNumber: "82610121362" },
      { name: "Cleaves Matt", personNumber: "82610156629" },
      { name: "Cox Hayley", personNumber: "82610149965" },
      { name: "Albrighton Ashley", personNumber: "82610107474" },
      { name: "Davies Dean", personNumber: "82610106041" },
      { name: "Ellis Oliver", personNumber: "82610281094" },
      { name: "Fiaz Mohammed", personNumber: "82610107884" },
      { name: "Ghalib Assem", personNumber: "82610240991" },
      { name: "Goodwin Mick", personNumber: "82610130721" },
      { name: "Grigore Mirela", personNumber: "82610154295" },
      { name: "Grozavu Alexandru", personNumber: "82610135568" },
      { name: "Gulbahar Aminah", personNumber: "82610128865" },
      { name: "Hobbs Christopher", personNumber: "82610301864" },
      { name: "James Joanne", personNumber: "82610122611" },
      { name: "Jarvis Adam", personNumber: "82610117318" },
      { name: "Kendall Stephen", personNumber: "82610108753" },
      { name: "Khan Assam", personNumber: "82610119402" },
      { name: "Lupu Lavinia", personNumber: "82610154356" },
      { name: "McDonald Simon", personNumber: "82610115109" },
      { name: "Miecielica Agata", personNumber: "82610124485" },
      { name: "Miseviciute Eimante", personNumber: "82610135464" },
      { name: "Nita Silvia", personNumber: "82610146015" },
      { name: "Oprisiu Alexandru", personNumber: "82610151109" },
      { name: "Parker Gary", personNumber: "82610230853" },
      { name: "Parker Richard", personNumber: "82610247934" },
      { name: "Pleaden Jonathan", personNumber: "82610126053" },
      { name: "Ribeiro Victor", personNumber: "82610138612" },
      { name: "Sadowy Dominika", personNumber: "82610131923" },
      { name: "Salt Steven", personNumber: "82610119214" },
      { name: "Sergalis Audrius", personNumber: "82610153159" },
      { name: "Simaitis Audrius", personNumber: "82610141024" },
      { name: "Sobieski Wojciech", personNumber: "82610125655" },
      { name: "Stefanovici Sergiu Adrian", personNumber: "82610137926" },
      { name: "Tanase Crina", personNumber: "82610129702" },
      { name: "Thind Harwinder", personNumber: "82610128711" },
      { name: "Tran Peter", personNumber: "82610128203" },
      { name: "Ullah Sana", personNumber: "82610121303" },
      { name: "Viana Nivio", personNumber: "82610148847" },
      { name: "White Nigel", personNumber: "82610110410" },
      { name: "Wilson Ronald", personNumber: "82610109544" },
      { name: "Yasmeen Tahira", personNumber: "82610132057" }
    ];
    function getEmployeeType(employeeOrEntry) {
  if (!employeeOrEntry) return '';

  // ‚úÖ aceita string OU entry (objeto)
  let name = '';
  let typeText = '';

  if (typeof employeeOrEntry === 'object') {
    name = String(employeeOrEntry.employee || '').trim();

    // tenta ler a coluna Type do CSV (se existir)
    typeText = String(
      employeeOrEntry.type ??
      employeeOrEntry.Type ??
      employeeOrEntry.employeeType ??
      ''
    ).trim();
  } else {
    name = String(employeeOrEntry || '').trim();
  }

  // ‚úÖ se existir Type no ficheiro:
  if (typeText) {
    const tLC = typeText.toLowerCase().trim();

    // CORE expl√≠cito
    if (tLC === 'core' || tLC.includes('core')) return 'CORE';

    // padroniza ag√™ncias conhecidas
    if (tLC.startsWith('extra')) return 'AGY J&T';
    if (tLC.startsWith('247'))   return 'AGY 247';

    // qualquer outra ag√™ncia: devolve como vem (mas SEMPRE string)
    return String(typeText);
  }

  // ‚úÖ fallback pelo nome (como antes)
  const lower = String(name).toLowerCase().trim();

  if (lower.startsWith('extra ')) return 'AGY J&T';
  if (lower.startsWith('247 '))   return 'AGY 247';
  return 'CORE';
}



    document.addEventListener('DOMContentLoaded', function () {
  // ‚îÄ‚îÄ‚îÄ FUN√á√ÉO NOVA: popula o dropdown de dias ‚îÄ‚îÄ‚îÄ
  function populateComparisonDayDropdown() {
    const selectDay = document.getElementById('selectComparisonDay');
    selectDay.innerHTML = '<option value="">All Days</option>';
    const allDates = [...new Set(storedData.map(entry => entry.date))];
    allDates.sort((a, b) => {
      const [da, ma, ya] = a.split('/').map(Number);
      const [db, mb, yb] = b.split('/').map(Number);
      return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
    });
    allDates.forEach(dateStr => {
      const opt = document.createElement('option');
      opt.value       = dateStr;
      opt.textContent = dateStr;
      selectDay.appendChild(opt);
    });
    selectDay.addEventListener('change', renderComparisonCharts);
  }
  

  // ‚Ä¶ aqui continuam todas as outras fun√ß√µes e event listeners do seu c√≥digo ‚Ä¶

  function populatePayCodeDropdown() {
  const payCodeSelect = document.getElementById('payCodeFilter');
  payCodeSelect.innerHTML = '<option value="">All</option>';
  const uniqueCodes = new Set(
    storedData
      .map(entry => entry.payCode || '')
      .filter(code => code.trim() !== '')
  );
  uniqueCodes.forEach(code => {
    const opt = document.createElement('option');
    opt.value       = code;
    opt.textContent = code;
    payCodeSelect.appendChild(opt);
  });

  // üîπ NOVO ‚Äî Atualiza o painel multi-sele√ß√£o
  rebuildPayCodeMultiPanelFromDropdown();
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helpers para tempo: HH:MM ou horas decimais
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Converte string (HH:MM ou decimal "285,38"/"285.38") ‚Üí horas decimais
function parseTimeToDecimal(raw) {
  if (!raw) return null;
  const value = raw.toString().trim().replace(',', '.');

  // Caso 1: formato HH:MM (ou HH:MM:SS)
  if (value.includes(':')) {
    const parts = value.split(':');
    if (parts.length < 2) return null;

    const h = Number(parts[0]);
    const m = Number(parts[1]);
    const s = parts[2] != null ? Number(parts[2]) : 0;

    if ([h, m, s].some(n => Number.isNaN(n))) return null;
    if (h < 0 || m < 0 || s < 0) return null;

    return h + m / 60 + s / 3600;
  }

  // Caso 2: decimal puro (ex.: "7.5" ou "285.38795")
  const dec = Number(value);
  if (Number.isNaN(dec) || dec < 0) return null;
  return dec;
}

// Converte horas decimais ‚Üí string HH:MM
function decimalToHHMM(dec) {
  if (dec == null || Number.isNaN(dec)) return '';
  const totalMinutes = Math.round(dec * 60);
  const h = Math.floor(totalMinutes / 60);
  const m = totalMinutes % 60;
  return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
}

// Valida√ß√£o gen√©rica: aceita HH:MM ou decimal
function isValidHHMM(value) {
  return parseTimeToDecimal(value) != null;
}

// Mant√©m o nome antigo para compatibilidade com o resto do c√≥digo
function convertHHMMToDecimal(timeInput) {
  return parseTimeToDecimal(timeInput);
}

// Valida e NORMALIZA o input para HH:MM
function validateTimeInput(inputEl) {
  const raw = inputEl.value.trim();
  if (raw === '') return true; // vazio √© permitido

  const dec = parseTimeToDecimal(raw);
  if (dec == null) {
    alert('Please enter a valid time. Use HH:MM (e.g., 07:30) or decimal hours (e.g., 7.5).');
    inputEl.focus();
    inputEl.select?.();
    return false;
  }

  // Se for v√°lido, reescreve o campo em HH:MM padr√£o
  inputEl.value = decimalToHHMM(dec);
  return true;
}
 // 2) populateComparisonTaskFilters: preenche os modais de filtro
      function populateComparisonTaskFilters() {
        const ecomTasksSet   = new Set();
        const retailTasksSet = new Set();
        storedData.forEach(entry => {
          if (entry.department === 'Ecom')   ecomTasksSet.add(entry.task);
          if (entry.department === 'Retail') retailTasksSet.add(entry.task);
        });

        const ecomModalContainer   = document.getElementById('ecomTasksModalContainer');
        const retailModalContainer = document.getElementById('retailTasksModalContainer');
        ecomModalContainer.innerHTML   = '';
        retailModalContainer.innerHTML = '';

        // ‚ÄúTodas as Tasks‚Äù no modal Ecom
        const allEcomLabel = document.createElement('label');
        allEcomLabel.innerHTML = `
          <input type="checkbox" value="" class="ecom-modal-checkbox" checked />
          <span style="font-weight: bold;">Todas as Tasks</span>
        `;
        ecomModalContainer.appendChild(allEcomLabel);

        // ‚ÄúTodas as Tasks‚Äù no modal Retail
        const allRetailLabel = document.createElement('label');
        allRetailLabel.innerHTML = `
          <input type="checkbox" value="" class="retail-modal-checkbox" checked />
          <span style="font-weight: bold;">Todas as Tasks</span>
        `;
        retailModalContainer.appendChild(allRetailLabel);

        function createCheckboxLabel(task, cls) {
          const lbl = document.createElement('label');
          lbl.innerHTML = `
            <input type="checkbox" value="${task}" class="${cls}" />
            <span>${task}</span>
          `;
          return lbl;
        }

        Array.from(ecomTasksSet).sort().forEach(task => {
          const lbl = createCheckboxLabel(task, 'ecom-modal-checkbox');
          ecomModalContainer.appendChild(lbl);
        });

        Array.from(retailTasksSet).sort().forEach(task => {
          const lbl = createCheckboxLabel(task, 'retail-modal-checkbox');
          retailModalContainer.appendChild(lbl);
        });

        // L√≥gica ‚ÄúTodas as Tasks‚Äù ‚Üî checkboxes individuais (modal Ecom)
        const ecomAllCheckbox    = ecomModalContainer.querySelector('input.ecom-modal-checkbox[value=""]');
        const ecomTaskCheckboxes = Array.from(ecomModalContainer.querySelectorAll('input.ecom-modal-checkbox')).filter(cb => cb.value !== '');
        ecomAllCheckbox.addEventListener('change', () => {
          if (ecomAllCheckbox.checked) {
            ecomTaskCheckboxes.forEach(cb => cb.checked = false);
          }
        });
        ecomTaskCheckboxes.forEach(cb => {
          cb.addEventListener('change', () => {
            if (cb.checked) {
              ecomAllCheckbox.checked = false;
            }
            const algumaMarcada = ecomTaskCheckboxes.some(x => x.checked);
            if (!algumaMarcada) {
              ecomAllCheckbox.checked = true;
            }
          });
        });

        // L√≥gica ‚ÄúTodas as Tasks‚Äù ‚Üî checkboxes individuais (modal Retail)
        const retailAllCheckbox    = retailModalContainer.querySelector('input.retail-modal-checkbox[value=""]');
        const retailTaskCheckboxes = Array.from(retailModalContainer.querySelectorAll('input.retail-modal-checkbox')).filter(cb => cb.value !== '');
        retailAllCheckbox.addEventListener('change', () => {
          if (retailAllCheckbox.checked) {
            retailTaskCheckboxes.forEach(cb => cb.checked = false);
          }
        });
        retailTaskCheckboxes.forEach(cb => {
          cb.addEventListener('change', () => {
            if (cb.checked) {
              retailAllCheckbox.checked = false;
            }
            const algumaMarcada = retailTaskCheckboxes.some(x => x.checked);
            if (!algumaMarcada) {
              retailAllCheckbox.checked = true;
            }
          });
        });
      }

      // 3) Fun√ß√µes para abrir/fechar modais
document.getElementById('openEcomFilterBtn').addEventListener('click', () => {
  populateComparisonTaskFilters();
  document.getElementById('ecomFilterModal').style.display = 'flex';
});
document.getElementById('openRetailFilterBtn').addEventListener('click', () => {
  populateComparisonTaskFilters();
  document.getElementById('retailFilterModal').style.display = 'flex';
});
function closeEcomModal() {
  document.getElementById('ecomFilterModal').style.display = 'none';
}
function closeRetailModal() {
  document.getElementById('retailFilterModal').style.display = 'none';
}

// 4) Fun√ß√µes de ‚ÄúOK‚Äù dos modais -> atualizam estados e redesenham gr√°ficos
function applyEcomFilter() {
  const allChecked = document.querySelector('#ecomTasksModalContainer input.ecom-modal-checkbox[value=""]').checked;
  if (allChecked) {
    selectedEcomTasks = [];
  } else {
    selectedEcomTasks = Array.from(
      document.querySelectorAll('#ecomTasksModalContainer input.ecom-modal-checkbox')
    )
    .filter(cb => cb.value !== '' && cb.checked)
    .map(cb => cb.value);
  }
  closeEcomModal();
  renderComparisonCharts();
}
function applyRetailFilter() {
  const allChecked = document.querySelector('#retailTasksModalContainer input.retail-modal-checkbox[value=""]').checked;
  if (allChecked) {
    selectedRetailTasks = [];
  } else {
    selectedRetailTasks = Array.from(
      document.querySelectorAll('#retailTasksModalContainer input.retail-modal-checkbox')
    )
    .filter(cb => cb.value !== '' && cb.checked)
    .map(cb => cb.value);
  }
  closeRetailModal();
  renderComparisonCharts();
}

// === EXPORTANDO AS FUN√á√ïES PARA O ESCOPO GLOBAL ===
window.closeEcomModal    = closeEcomModal;
window.applyEcomFilter   = applyEcomFilter;
window.closeRetailModal  = closeRetailModal;
window.applyRetailFilter = applyRetailFilter;


      // 5) Fun√ß√£o para renderizar os charts de compara√ß√£o
      function renderComparisonCharts() {
  if (window.ecomComparisonChartObj)   window.ecomComparisonChartObj.destroy();
  if (window.retailComparisonChartObj) window.retailComparisonChartObj.destroy();

  // 1) L√™ o dia selecionado (string ‚ÄúDD/MM/YYYY‚Äù ou vazio)
  const selectedDay = document.getElementById('selectComparisonDay').value;

  // 2) Fonte base = EXACTAMENTE o que a Home est√° a mostrar (respeita Pay Code e restantes filtros)
const baseData = getFilteredData();

// Filtra por departamento Ecom/Retail **E** (opcionalmente) pelo dia
let dataEcom   = baseData.filter(e => e.department === "Ecom");
let dataRetail = baseData.filter(e => e.department === "Retail");


  if (selectedDay) {
    dataEcom   = dataEcom.filter(e => e.date === selectedDay);
    dataRetail = dataRetail.filter(e => e.date === selectedDay);
  }

  // 3) Continua filtragem atual por tarefas selecionadas
  const filterEcomFunc = (selectedEcomTasks.length === 0)
    ? (() => true)
    : (entry => selectedEcomTasks.includes(entry.task));
  const filterRetailFunc = (selectedRetailTasks.length === 0)
    ? (() => true)
    : (entry => selectedRetailTasks.includes(entry.task));

  const filteredEcomData   = dataEcom.filter(filterEcomFunc);
  const filteredRetailData = dataRetail.filter(filterRetailFunc);

        function buildComparison(deptData) {
          const consumedByDay = {};
          const plannedByDay  = {};

          deptData.forEach(e => {
            const key = `${e.task}|${e.date}`;
            const [h = 0, m = 0, s = 0] = (e.totalHoursFormatted || "00:00:00").split(":").map(Number);
            consumedByDay[key] = (consumedByDay[key] || 0) + (h * 3600 + m * 60 + s);

            if (!(key in plannedByDay)) {
              const plannedDec = (plannedHoursTracker[e.task] || {})[e.date];
              plannedByDay[key] = plannedDec != null ? Math.round(plannedDec * 3600) : 0;
            }
          });

          const allTasks = Array.from(new Set(Object.keys(consumedByDay).map(k => k.split("|")[0])));
          const dataArr = allTasks.map(task => {
            let sumConsumed = 0, sumPlanned = 0;
            Object.keys(consumedByDay).forEach(k => {
              if (k.startsWith(task + "|")) {
                sumConsumed += consumedByDay[k];
                sumPlanned  += plannedByDay[k] || 0;
              }
            });
            return { task, consumed: sumConsumed, planned: sumPlanned };
          });

          dataArr.sort((a, b) => b.consumed - a.consumed);
          return dataArr;
        }

        const ecomArr   = buildComparison(filteredEcomData);
        const retailArr = buildComparison(filteredRetailData);

        function chartConfig(arr) {
  return {
    type: "bar",
    data: {
      labels: arr.map(d => d.task),
      datasets: [
        {
          label: "Consumed",
          data: arr.map(d => (d.consumed / 3600)),
          backgroundColor: "#007acc"
        },
        {
          label: "Planned",
          data: arr.map(d => (d.planned / 3600)),
          backgroundColor: "#26a269"
        }
      ]
    },
    options: {
      plugins: {
        legend: { display: true, position: "top" },
        tooltip: { /* ‚Ä¶ seu callback existente ‚Ä¶ */ },
        datalabels: {
          display: true,
          anchor: "end",    // "end" coloca no topo da barra
          align: "end",     // "end" alinha a label logo acima (fora) da barra
          rotation: -90,      // texto horizontal
          font: {
            weight: "normal",
            size: 9
          },
          color: "#717171",
          formatter: value => {
            const totalSec = Math.round(value * 3600);
            const hh = String(Math.floor(totalSec / 3600)).padStart(2, "0");
            const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, "0");
            return `${hh}:${mm}`;
          }
        }
      },
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            maxRotation: 90,
            minRotation: 90,
            callback: v => arr[v]?.task || "",
            font: { size: 12 }
          }
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: "Hours" },
          ticks: {
            callback: v => {
              const totalSec = Math.round(v * 3600);
              const hh = String(Math.floor(totalSec / 3600)).padStart(2, "0");
              const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, "0");
              return `${hh}:${mm}`;
            }
          }
        }
      }
    },
    plugins: [ChartDataLabels]
  };
}
      // ‚Äî‚Äì‚Äì ECOM CHART COM ONCLICK ‚Äî‚Äì‚Äì
const ecomCtx = document
  .getElementById("ecomComparisonChart")
  .getContext("2d");

const ecomConfig = chartConfig(ecomArr);

/* agora o gr√°fico de detalhe abre apenas
   quando o utilizador CLICA na barra */
ecomConfig.options.onClick = function (event, elements) {
  if (elements.length) {
    const idx  = elements[0].index;
    const task = this.data.labels[idx];
    showDailyDetail(task);
  }
};

window.ecomComparisonChartObj = new Chart(ecomCtx, ecomConfig);


      // ‚Äî‚Äì‚Äì RETAIL CHART COM ONCLICK ‚Äî‚Äì‚Äì
const retailCtx = document
  .getElementById("retailComparisonChart")
  .getContext("2d");

const retailConfig = chartConfig(retailArr);

/* o detalhe abre apenas quando o utilizador CLICA na barra */
retailConfig.options.onClick = function (event, elements) {
  if (elements.length) {
    const idx  = elements[0].index;
    const task = this.data.labels[idx];
    showDailyDetail(task);
  }
};

window.retailComparisonChartObj = new Chart(retailCtx, retailConfig);

    }  // ‚Üê fecha renderComparisonCharts()

// ‚îÄ‚îÄ Fun√ß√µes de Drill-down Di√°rio ‚îÄ‚îÄ
function showDailyDetail(task) {
  // 1) Atualiza o t√≠tulo do modal para o nome da task clicada
  document.getElementById('dailyDetailTitle').textContent = task;

  // 2) filtra s√≥ os registros daquele task, respeitando os filtros da Home
const selectedDay = document.getElementById('selectComparisonDay').value;

let data = getFilteredData().filter(e => e.task === task);

// Se o user escolheu um dia no Comparison Panel, mant√©m o detalhe consistente
if (selectedDay) {
  data = data.filter(e => e.date === selectedDay);
}


  // 3) agrupa por dia
const byDay = {};
data.forEach(e => {
  byDay[e.date] = byDay[e.date] || { consumed: 0, planned: 0 };
  const [h, m, s] = e.totalHoursFormatted.split(':').map(Number);
  byDay[e.date].consumed += h * 3600 + m * 60 + s;
  const pd = (plannedHoursTracker[task] || {})[e.date] || 0;
byDay[e.date].planned   = Math.round(pd * 3600);
});

// 4) prepara arrays de labels e valores
const labels = Object.keys(byDay).sort((a, b) => {
  const [da, ma, ya] = a.split('/').map(Number);
  const [db, mb, yb] = b.split('/').map(Number);
  return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
});

/* =========================================================
   ‚úÖ NOVO: KPIs din√¢micos no topo do Daily Detail
   - Consumed total
   - Planned total
   - Diff com setas (verde/vermelho)
   ========================================================= */
let totalConsumedSec = 0;
let totalPlannedSec  = 0;

labels.forEach(d => {
  totalConsumedSec += (byDay[d]?.consumed || 0);
  totalPlannedSec  += (byDay[d]?.planned  || 0);
});

const diffSec = totalConsumedSec - totalPlannedSec;

const diffArrow = diffSec > 0 ? '‚ñº ' : diffSec < 0 ? '‚ñ≤ ' : '';
const diffSign  = diffSec > 0 ? '-'  : diffSec < 0 ? '+'  : '';
const diffColor = diffSec > 0 ? '#c1121f' : diffSec < 0 ? '#26a269' : '#777';

const consumedTxt = formatTimeHHMM(totalConsumedSec);
const plannedTxt  = formatTimeHHMM(totalPlannedSec);
const diffTxt     = diffSec === 0
  ? '‚Äî 00:00'
  : `${diffArrow}${diffSign}${formatTimeHHMM(Math.abs(diffSec))}`;

// ‚úÖ Budget do TASK selecionado (semanal) ‚Äî vem do Budget Tracker (Budget Logged Tasks)
let currentWeek = null;

// tenta tirar week da 1¬™ linha do task filtrado (mais fi√°vel)
if (data && data.length && data[0].week != null) {
  currentWeek = Number(data[0].week);
} else if (labels.length) {
  // fallback: calcula week a partir do 1¬∫ dia do gr√°fico
  currentWeek = getCustomWeekNumber(parseBrDate(labels[0]));
}

// Budget semanal do task (horas decimais -> segundos)
const budgetDec = (currentWeek != null && typeof getBudgetForTaskWeek === 'function')
  ? (getBudgetForTaskWeek(task, currentWeek) || 0)
  : 0;

const budgetSec = Math.round(Number(budgetDec) * 3600);
const budgetTxt = formatTimeHHMM(budgetSec);

// ‚úÖ Budget Diff = Consumed - Budget (igual estilo do Diff)
const budgetDiffSec = totalConsumedSec - budgetSec;

const budgetArrow = budgetDiffSec > 0 ? '‚ñº ' : budgetDiffSec < 0 ? '‚ñ≤ ' : '';
const budgetSign  = budgetDiffSec > 0 ? '-'  : budgetDiffSec < 0 ? '+'  : '';
const budgetColor = budgetDiffSec > 0 ? '#c1121f' : budgetDiffSec < 0 ? '#26a269' : '#777';

const budgetDiffTxt = budgetDiffSec === 0
  ? '‚Äî 00:00'
  : `${budgetArrow}${budgetSign}${formatTimeHHMM(Math.abs(budgetDiffSec))}`;


// Cria (uma vez) a linha de KPIs logo abaixo do t√≠tulo
const titleEl = document.getElementById('dailyDetailTitle');
if (titleEl && titleEl.parentElement) {
  let kpiRow = document.getElementById('dailyDetailKpiRow');

  if (!kpiRow) {
    kpiRow = document.createElement('div');
    kpiRow.id = 'dailyDetailKpiRow';

    // estilo leve, sem estragar layout
    kpiRow.style.display = 'flex';
    kpiRow.style.gap = '10px';
    kpiRow.style.marginTop = '6px';
    kpiRow.style.alignItems = 'center';
    kpiRow.style.justifyContent = 'flex-start';
    kpiRow.style.fontSize = '0.85rem';
    kpiRow.style.flexWrap = 'nowwrap'; // ‚úÖ para caber 4 KPIs sem rebentar

    titleEl.insertAdjacentElement('afterend', kpiRow);
  }

  kpiRow.innerHTML = `
  <span style="color:#555;"><b>Consumed:</b> ${consumedTxt}</span>
  <span style="color:#555;"><b>Planned:</b> ${plannedTxt}</span>
  <span style="color:${diffColor}; font-weight:700;"><b>Diff:</b> ${diffTxt}</span>
  <span style="color:#555;"><b>Budget:</b> ${budgetTxt}</span>
  <span style="color:${budgetColor}; font-weight:700;"><b>Budget Diff:</b> ${budgetDiffTxt}</span>
`;
}

/* ====================== FIM KPIs ======================= */

// (continua como j√° estava)
const consumed = labels.map(d => byDay[d].consumed / 3600);
const planned  = labels.map(d => byDay[d].planned  / 3600);


  // 5) renderiza no canvas
  const ctx = document.getElementById('dailyDetailChart').getContext('2d');
  if (window.dailyDetailChartObj) window.dailyDetailChartObj.destroy();
 window.dailyDetailChartObj = new Chart(ctx, {
  type: 'bar',
  data: {
    labels,
    datasets: [
      { label: 'Consumed', data: consumed },
      { label: 'Planned',  data: planned  }
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,

    /* ‚îÄ‚îÄ‚îÄ ‚¨áÔ∏è  NOVO bloco datalabels  ‚¨áÔ∏è ‚îÄ‚îÄ‚îÄ */
    plugins: {
      legend: { position: 'top' },

      datalabels: {
        display: true,           // sempre vis√≠vel no gr√°fico-hover
        anchor : 'center',
        align  : 'center',
        font   : { weight: 'normal', size: 10 },
        color  : '#5C5C5C',       // branco dentro da barra
        formatter: v => {
          const totalSec = Math.round(v * 3600);
          const hh = String(Math.floor(totalSec / 3600)).padStart(2,'0');
          const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2,'0');
          return `${hh}:${mm}`;   // HH:MM elegante
        }
      }
    },
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    scales: { /* ‚Ä¶ mant√©m ‚Ä¶ */ }
  },
  plugins: [ChartDataLabels]       // garante que o plugin esteja ativo aqui
});


  // 6) abre modal
  document.getElementById('dailyDetailModal').style.display = 'flex';
}

function closeDailyDetail() {
  document.getElementById('dailyDetailModal').style.display = 'none';
}
// ‚îÄ‚îÄ bot√£o fecha o modal de detalhe di√°rio
document
  .getElementById('closeDailyDetailBtn')
  .addEventListener('click', closeDailyDetail);


      function setActive(elements, activeClass, activeElement) {
        elements.forEach(el => el.classList.remove(activeClass));
        activeElement.classList.add(activeClass);
      }
     function getCustomWeekNumber(d) {
  // 1) Normaliza para meia‚Äênoite (evita efeitos de hora de ver√£o/fuso)
  const dt = new Date(d.getFullYear(), d.getMonth(), d.getDate());

  // 2) Encontra o domingo daquela semana
  const day = dt.getDay();             // 0=domingo, ‚Ä¶, 6=s√°bado
  const sunday = new Date(dt);
  sunday.setDate(dt.getDate() - day);

  // 3) Calcula ISO‚Äêweek do domingo
  const isoDate = new Date(Date.UTC(
    sunday.getFullYear(),
    sunday.getMonth(),
    sunday.getDate()
  ));
  // transita para quinta‚Äêfeira da mesma semana ISO:
  isoDate.setUTCDate(isoDate.getUTCDate() + 4 - (isoDate.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(isoDate.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil(
    (
      (isoDate - yearStart) / 86400000   // dif em dias
      + 1
    ) / 7
  );
  return weekNo;
}

function parseCSV(text) {
  const rows   = text.trim().split('\n');
  const result = [];

  for (const row of rows) {
    const columns = row.split(',');
    if (columns[0].toLowerCase().includes("employee")) continue;

    let firstPart  = columns[0].trim().replace(/^"|"$/g, '');
    let secondPart = columns[1].trim().replace(/^"|"$/g, '');
    let employee   = firstPart + ' ' + secondPart;

    if (firstPart.toLowerCase().startsWith('extra')) {
      employee = 'Extra ' + secondPart;
    } else if (firstPart.toLowerCase().startsWith('247')) {
      employee = '247 ' + secondPart;
    }

    const personNumber = columns[2].trim();

    const [day, month, year] = columns[3].trim().split('/').map(Number);
    const dateObj   = new Date(year, month - 1, day);
    const week      = getCustomWeekNumber(dateObj);
    const monthName = dateObj.toLocaleString('default', { month: 'long' });

    let rawLabourAccount = (columns[5] || '').trim();
    let labourAccount = rawLabourAccount.includes("DSC/GB_1725")
      ? (rawLabourAccount.match(/(\d{6}).*\/(\d{4})/) || [])[1] +
        (rawLabourAccount.match(/(\d{6}).*\/(\d{4})/) || [])[2]
      : rawLabourAccount.replace(/\/+/g, '');

    // ‚îÄ‚îÄ‚îÄ Departamento original pelo prefixo ‚îÄ‚îÄ‚îÄ
    let department = '';
    if (labourAccount.startsWith('100765')) {
      department = 'Ecom';
    } else if (labourAccount.startsWith('100768')) {
      department = 'Retail';
    } else if (labourAccount.startsWith('100666')) {
      department = 'IT';
    }
    // (se n√£o for nenhum desses, department fica '')

    // se veio sem conta E SEM departamento v√°lido, ignora a linha
    if ((!labourAccount || labourAccount.toUpperCase() === 'N/A') &&
        (!department    || department.toUpperCase() === 'N/A')) {
      continue;
    }

    // ‚îÄ‚îÄ‚îÄ Estilo da labourAccount (vazia = erro) ‚îÄ‚îÄ‚îÄ
    let labourAccountStyle = '';
    if (!labourAccount) {
      labourAccount      = 'Missing Code';
      labourAccountStyle = 'color:red;font-weight:bold;';
    }

    // ‚îÄ‚îÄ‚îÄ Task + estilo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let taskStyle = '';
    let task;

    const codeSuffix = labourAccount.slice(-4);
    const isBreak    = codeSuffix === '4010';   // Flag para Paid Break

    if (codeSuffix === '0000') {
      // Prefixo conforme o departamento j√° detetado
      const depPrefix =
              department === 'Ecom'   ? 'E.'
            : department === 'Retail' ? 'R.'
            : 'U.';  // Unknown / outros

      task      = `${depPrefix}Missing Task-${codeSuffix}`;
      taskStyle = 'color:red;font-weight:bold;';
    } else {
      const baseTask = taskMapping[labourAccount] ||
                       (isBreak ? 'Paid Break' : 'N/A');
      task = `${baseTask}-${codeSuffix}`;
    }

    const isManager = managersList.some(m => m.personNumber === personNumber);
    const role      = isManager ? 'Manager' : 'Operative';

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //  NOVO BLOCO: horas em decimal + HH:MM:SS
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const rawTime = String(columns[6] || '').trim().replace(/"/g, '');

    let totalHoursDecimal   = 0;          // n√∫mero em horas decimais (ex.: 7.75)
    let totalHoursFormatted = '00:00:00'; // string HH:MM:SS (ex.: 07:45:00)

    if (rawTime) {
      if (rawTime.includes(':')) {
        // Caso 1: ainda venha em HH:MM[:SS] (compatibilidade com ficheiros antigos)
        const parts = rawTime.split(':').map(Number);
        const h = parts[0] || 0;
        const m = parts[1] || 0;
        const s = parts[2] || 0;
        const totalSec = h * 3600 + m * 60 + s;

        totalHoursDecimal = totalSec / 3600;

        const hh = String(h).padStart(2, '0');
        const mm = String(m).padStart(2, '0');
        const ss = String(s).padStart(2, '0');
        totalHoursFormatted = `${hh}:${mm}:${ss}`;
      } else {
        // Caso 2: vem em decimal (ex.: "7.75")
        const dec = parseFloat(rawTime.replace(',', '.'));
        if (!isNaN(dec) && dec > 0) {
          totalHoursDecimal = dec;

          const totalSec = Math.round(dec * 3600);
          const h = Math.floor(totalSec / 3600);
          const m = Math.floor((totalSec % 3600) / 60);
          const s = totalSec % 60;

          const hh = String(h).padStart(2, '0');
          const mm = String(m).padStart(2, '0');
          const ss = String(s).padStart(2, '0');
          totalHoursFormatted = `${hh}:${mm}:${ss}`;
        }
      }
    }

    const rawPayCode = columns[columns.length - 1]
      .trim()
      .replace(/^"|"$/g, '');
    const payCode    = rawPayCode;

    result.push({
      employee,
      personNumber,
      role,
      date: dateObj.toLocaleDateString('en-GB'),
      week,
      month: monthName,
      labourAccount,
      department,
      task,
      taskStyle,
      dayOfWeek: dateObj.getDay(),
      labourAccountStyle,
      totalHoursDecimal,    // üëà NOVO (horas decimais, origem CSV)
      totalHoursFormatted,  // üëà HH:MM:SS derivado dos decimais
      payCode
    });
  }

  return result;
}
      function aggregateData(data) {
  return data;
}
window.aggregateData = aggregateData; // ‚úÖ agora o console enxerga

    async function addDataToStorage(newData) {
  // 1) Descobre todas as datas presentes no novo CSV
  const datesInNew = [...new Set(newData.map(e => e.date))];

  // 2) Remove do storedData tudo que tenha essas datas (substitui)
  storedData = storedData.filter(e => !datesInNew.includes(e.date));

  // 3) Adiciona TODOS os registros do novo CSV
  storedData.push(...newData);

  // 4) Persiste (IndexedDB = fonte de verdade)
  try {
    await idbPutCsvRows(storedData, { replace: true });   // ‚úÖ grava dataset completo

    // ‚úÖ FLAG: garante que o boot sabe que existe IDB
    localStorage.setItem('hasIDBData', '1');

    // ‚úÖ evita estourar quota do localStorage
    localStorage.removeItem('csvData');

  } catch (e) {
    console.warn('IDB save failed ‚Äî fallback to localStorage:', e);

    // ‚úÖ se falhou IDB, n√£o deixa a app ‚Äúpensar‚Äù que tem IDB
    localStorage.removeItem('hasIDBData');

    // fallback
    localStorage.setItem('csvData', JSON.stringify(storedData));
  }
}
// ‚úÖ PayCodes v√°lidos para OT (valores "limpos")
const OT_PAYCODES_ALLOWED = new Set([
  'AGY BASIC',
  'BASIC',
  'GB99 OT POOL EARNED',
  'OFF SITE P'
]);

function isPayCodeAllowedForOT(entry) {
  const pc = String(entry && entry.payCode ? entry.payCode : '').trim().toUpperCase();
  return OT_PAYCODES_ALLOWED.has(pc);
}

/* =========================================================
   ‚úÖ AGY OT MODE + PERIOD MAP (Passo 1 ‚Äî s√≥ infraestrutura)
   Regras:
   - CORE: sempre semanal (como hoje)
   - AGY: Periods 1‚Äì11 = por per√≠odo | Period 12 (weeks 48‚Äì52) = semanal
   ========================================================= */

// modo atual (default: weekly) ‚Äî vamos ligar ao toggle no Passo 2
window.agyOtMode = window.agyOtMode || (localStorage.getItem('agyOtMode') || 'weekly');

// helper para setar modo (vamos usar no toggle depois)
function setAgyOtMode(mode) {
  const m = (String(mode || '').toLowerCase() === 'period') ? 'period' : 'weekly';
  window.agyOtMode = m;
  localStorage.setItem('agyOtMode', m);

  // ‚úÖ avisa o "motor" (filterTable) que o modo mudou
  try {
    window.dispatchEvent(new CustomEvent('agyOtModeChanged', { detail: { mode: m } }));
  } catch (e) {
    window.dispatchEvent(new Event('agyOtModeChanged'));
  }
}


// identifica CORE usando o texto do type (mesmo padr√£o do teu sistema)
function isCoreEntry(entry) {
  const typeText = String(
    (typeof getEmployeeType === 'function' ? getEmployeeType(entry) : (entry?.type || ''))
  ).toLowerCase();
  return typeText.includes('core');
}

// Week -> Period (conforme tabela 2026)
function getPeriodFromWeek(weekNum) {
  const w = Number(weekNum);
  if (!Number.isFinite(w) || w < 1 || w > 53) return null;

  if (w >=  1 && w <=  4) return 1;
  if (w >=  5 && w <=  8) return 2;
  if (w >=  9 && w <= 13) return 3;   // 5 semanas
  if (w >= 14 && w <= 17) return 4;
  if (w >= 18 && w <= 21) return 5;
  if (w >= 22 && w <= 26) return 6;   // 5 semanas
  if (w >= 27 && w <= 30) return 7;
  if (w >= 31 && w <= 34) return 8;
  if (w >= 35 && w <= 39) return 9;   // 5 semanas
  if (w >= 40 && w <= 43) return 10;
  if (w >= 44 && w <= 47) return 11;
  if (w >= 48 && w <= 52) return 12;  // Dezembro (semanal por regra)
  return null;
}

// devolve a ‚Äúchave de agrupamento‚Äù para OT
// (Passo 2 vai usar isto no c√°lculo real)
function getOtBucketKey(entry) {
  const person  = String(entry?.personNumber || '').trim();
  const weekStr = String(entry?.week || '').trim();
  const weekNum = Number(weekStr);

  if (!person || !weekStr) return `${person}|W${weekStr}`;

  // CORE nunca muda
  if (isCoreEntry(entry)) return `${person}|W${weekStr}`;

  // AGY: modo weekly -> sempre por week
  if (String(window.agyOtMode).toLowerCase() !== 'period') return `${person}|W${weekStr}`;

  // AGY: em Dezembro (Period 12 / weeks 48‚Äì52) continua semanal
  if (weekNum >= 48 && weekNum <= 52) return `${person}|W${weekStr}`;

  // AGY: Periods 1‚Äì11 -> por per√≠odo
  const p = getPeriodFromWeek(weekNum);
  return p ? `${person}|P${p}` : `${person}|W${weekStr}`;
}

// (opcional) expor para testes r√°pidos no console (mais robusto)
Object.assign(window, {
  setAgyOtMode,
  getPeriodFromWeek,
  getOtBucketKey
});
/* =========================================================
   ‚úÖ OT BUCKET (Week vs Period) ‚Äî 2026
   Regras:
   - CORE: sempre semanal
   - AGY: Period 1‚Äì11 em modo Period (bucket = P{period})
   - AGY: Period 12 sempre semanal
   ========================================================= */

(function initOtPeriodCalendar2026() {
  const PERIOD_RANGES_2026 = [
    { p: 1,  start: 1,  end: 4  },
    { p: 2,  start: 5,  end: 8  },
    { p: 3,  start: 9,  end: 13 },
    { p: 4,  start: 14, end: 17 },
    { p: 5,  start: 18, end: 21 },
    { p: 6,  start: 22, end: 26 },
    { p: 7,  start: 27, end: 30 },
    { p: 8,  start: 31, end: 34 },
    { p: 9,  start: 35, end: 39 },
    { p: 10, start: 40, end: 43 },
    { p: 11, start: 44, end: 47 },
    { p: 12, start: 48, end: 52 }
  ];

  // Week -> Period
  window.getPeriodForWeek = function getPeriodForWeek(weekNum) {
    const w = parseInt(weekNum, 10);
    if (!Number.isFinite(w)) return null;

    for (const r of PERIOD_RANGES_2026) {
      if (w >= r.start && w <= r.end) return r.p;
    }
    return null;
  };

  // Period -> Weeks count (4 ou 5)
  window.getWeeksInPeriod = function getWeeksInPeriod(periodNum) {
    const p = parseInt(periodNum, 10);
    if (!Number.isFinite(p)) return 1;

    const r = PERIOD_RANGES_2026.find(x => x.p === p);
    return r ? (r.end - r.start + 1) : 1;
  };

  // Detecta ‚Äúmodo period‚Äù sem depender de 1 √∫nico nome (fica robusto)
  function getOtMode() {
    if (window.otMode === 'period' || window.otMode === 'week') return window.otMode;
    if (typeof window.isOtPeriodMode === 'boolean') return window.isOtPeriodMode ? 'period' : 'week';

    const cb =
      document.getElementById('otPeriodToggle') ||
      document.getElementById('toggleOtPeriod') ||
      document.getElementById('togglePeriod');

    if (cb && typeof cb.checked === 'boolean') return cb.checked ? 'period' : 'week';

    return 'week'; // default: semanal
  }

  // ‚úÖ A fun√ß√£o central: define o ‚Äúbucket‚Äù onde OT soma/threshold bate
function getOtBucketKey(entry) {
  const person = String(entry?.personNumber || '').trim();
  const weekRaw = String(entry?.week || '').trim();
  const w = parseInt(weekRaw, 10);
  if (!person || !Number.isFinite(w)) return `${person}|${weekRaw}`;

  // Tipo (prefer√™ncia: getEmployeeType, depois entry.type)
  const typeText =
    (typeof getEmployeeType === 'function' ? String(getEmployeeType(entry) || '') : '') ||
    String(entry?.type || '');

  // CORE = sempre semanal (usa o teu helper isCoreEntry se existir)
  const isCore =
    (typeof isCoreEntry === 'function')
      ? isCoreEntry(entry)
      : (
          (typeof isCoreTypeText === 'function')
            ? isCoreTypeText(typeText)
            : String(typeText || '').toLowerCase().includes('core')
        );

  if (isCore) return `${person}|${w}`;

  // AGY: modo vem do helper (fallback pro getOtMode se existir)
  const mode = String(
    window.agyOtMode ||
    (typeof getOtMode === 'function' ? getOtMode() : 'weekly') ||
    'weekly'
  ).toLowerCase();

  // Period: prefer√™ncia pro teu getPeriodFromWeek (fallback pro getPeriodForWeek antigo)
  const period =
    (typeof getPeriodFromWeek === 'function')
      ? getPeriodFromWeek(w)
      : ((typeof window.getPeriodForWeek === 'function') ? window.getPeriodForWeek(w) : null);

  // Period 12 (weeks 48‚Äì52) = sempre semanal
  if (period === 12 || (w >= 48 && w <= 52)) return `${person}|${w}`;

  // Period 1‚Äì11: s√≥ vira ‚ÄúP{period}‚Äù quando o toggle est√° em Period
  if (mode === 'period' && period && period >= 1 && period <= 11) {
    return `${person}|P${period}`;
  }

  // weekly (ou sem period v√°lido): semanal
  return `${person}|${w}`;
}

// ‚úÖ garante que TODO o sistema usa esta fun√ß√£o (sem duplica√ß√µes)
window.getOtBucketKey = getOtBucketKey;
})();
// quantas semanas tem cada per√≠odo (2026)
function getWeeksInPeriod(periodNum) {
  const p = Number(periodNum);
  if (!Number.isFinite(p)) return 1;
  if (p === 3 || p === 6 || p === 9 || p === 12) return 5;
  return 4;
}

// (opcional) expor para testes
window.getWeeksInPeriod = getWeeksInPeriod;

/* =========================================================
   ‚úÖ PASSO 2 ‚Äî LIGAR O TOGGLE (robusto)
   - aplica o modo guardado (localStorage) ao UI
   - grava no localStorage quando muda
   - refresca OT (sem rebentar nada)
   ========================================================= */
(function initAgyOtToggle() {
  function applyModeToUI() {
    const weeklyEl = document.getElementById('agyOtWeekly');
    const periodEl = document.getElementById('agyOtPeriod');
    const hintEl   = document.getElementById('agyOtModeHint');

    if (!weeklyEl || !periodEl) return false;

    const mode = (String(window.agyOtMode).toLowerCase() === 'period') ? 'period' : 'weekly';
    weeklyEl.checked = (mode === 'weekly');
    periodEl.checked = (mode === 'period');

    if (hintEl) {
      hintEl.textContent = (mode === 'period')
        ? 'AGY OT por per√≠odo (P1‚ÄìP11). P12 (W48‚ÄìW52) continua semanal.'
        : 'AGY OT semanal (como hoje).';
    }
    return true;
  }

  function refreshAfterModeChange() {
    // ‚úÖ chamadas seguras (s√≥ se existirem)
    if (typeof filterTable === 'function') filterTable();
    if (typeof populateOTPeopleDropdown === 'function') populateOTPeopleDropdown();

    // (opcional) se quiser refletir tamb√©m no dashboard/budget:
    if (typeof displayBudgetOverview === 'function') displayBudgetOverview();
    if (document.getElementById('dashboard')?.classList.contains('active') && typeof renderDashboard === 'function') {
      renderDashboard();
    }
  }

  function bind() {
    const weeklyEl = document.getElementById('agyOtWeekly');
    const periodEl = document.getElementById('agyOtPeriod');
    if (!weeklyEl || !periodEl) return;

    weeklyEl.addEventListener('change', () => {
      if (!weeklyEl.checked) return;
      setAgyOtMode('weekly');
      applyModeToUI();
      refreshAfterModeChange();
      console.log('[AGY OT] mode =', window.agyOtMode);
    });

    periodEl.addEventListener('change', () => {
      if (!periodEl.checked) return;
      setAgyOtMode('period');
      applyModeToUI();
      refreshAfterModeChange();
      console.log('[AGY OT] mode =', window.agyOtMode);
    });
  }

  // normaliza o modo salvo
  setAgyOtMode(window.agyOtMode);

  // se o script correr antes do HTML, espera o DOM
  if (!applyModeToUI()) {
    document.addEventListener('DOMContentLoaded', () => {
      applyModeToUI();
      bind();
    });
  } else {
    bind();
  }
})();


  function processFile() {
  const fileInput = document.getElementById('fileInput');
  const file = fileInput.files[0];
  if (!file) {
    alert('Please select a file.');
    return;
  }

  const reader = new FileReader();

  reader.onload = async function(event) {
    const text = event.target.result;
    const newData = parseCSV(text);

    // ‚úÖ IMPORTANTE: espera o save/merge (IDB) antes de renderizar
    await addDataToStorage(newData);

    const aggregatedData = aggregateData(storedData);
    displayResults(aggregatedData);
    updateTotalHours(aggregatedData);
    updateFilteredTotals(aggregatedData);
    updateResult();

    populateDropdowns();
    populatePayCodeDropdown();
    populateComparisonTaskFilters();
    populateTypeDropdown(); // ‚úÖ actualiza o filtro TYPE sempre que carrega ficheiro

    populateComparisonDayDropdown();
    renderComparisonCharts();

    fileInput.value = '';
    fileInput.style.backgroundColor = '#ccc';

    displayBudgetOverview();
    if (document.getElementById('dashboard').classList.contains('active')) {
      renderDashboard();
    }

    filterTable();
    populateOTPeopleDropdown();
  };

  reader.readAsText(file);
}
      function updateMissingTaskCount() {
  const table = document.getElementById('resultTable');
  const tbody = table ? table.querySelector('tbody') : null;
  if (!table || !tbody) return;

  // ‚úÖ acha colunas pelo header
  const taskIdx = (typeof getColumnIndexByHeaderText === 'function')
    ? getColumnIndexByHeaderText(table, 'task')
    : -1;

  const empIdx = (typeof getColumnIndexByHeaderText === 'function')
    ? getColumnIndexByHeaderText(table, 'employee')
    : -1;

  if (taskIdx < 0 || empIdx < 0) return;

  const rows = tbody.querySelectorAll('tr');

  // ‚úÖ set de pessoas com missing task
  const missingPeople = new Set();

  rows.forEach(row => {
    if (getComputedStyle(row).display === 'none') return;

    const cells = row.cells;
    if (!cells || cells.length <= Math.max(taskIdx, empIdx)) return;

    const taskText = String(cells[taskIdx]?.textContent || '').trim();
    if (!taskText.endsWith('Missing Task-0000')) return;

    const empName = String(cells[empIdx]?.textContent || '').trim();
    if (empName) missingPeople.add(empName.toLowerCase());
  });

  const span = document.getElementById('missingTaskCount');
  if (!span) return;

  const missing = missingPeople.size;
  span.textContent = missing;

  // ‚úÖ 0 = verde / >0 = laranja
  span.style.color = missing > 0 ? '#ff8c00' : 'green';
}



function updateMissingTaskHours() {
  const table = document.getElementById('resultTable');
  const tbody = table ? table.querySelector('tbody') : null;
  if (!table || !tbody) return;

  const taskIdx = (typeof getColumnIndexByHeaderText === 'function')
    ? getColumnIndexByHeaderText(table, 'task')
    : -1;

  const hoursIdx = (typeof getColumnIndexByHeaderText === 'function')
    ? getColumnIndexByHeaderText(table, 'total hours')
    : -1;

  if (taskIdx < 0 || hoursIdx < 0) return;

  const rows = tbody.querySelectorAll('tr');

  let missingSec = 0;
  let grossSec = 0;

  rows.forEach(row => {
    if (getComputedStyle(row).display === 'none') return;

    const cells = row.cells;
    if (!cells || cells.length <= Math.max(taskIdx, hoursIdx)) return;

    const taskText  = String(cells[taskIdx]?.textContent || '').trim();
    const hoursText = String(cells[hoursIdx]?.textContent || '').trim();
    if (!hoursText || hoursText === 'N/A') return;

    const parts = hoursText.split(':').map(v => Number(v) || 0);
    const h = parts[0] || 0, m = parts[1] || 0, s = parts[2] || 0;
    const entrySec = h * 3600 + m * 60 + s;

    grossSec += entrySec;

    if (taskText.endsWith('Missing Task-0000')) {
      missingSec += entrySec;
    }
  });

  const missingFormatted = formatTime(missingSec);
  const percent = grossSec > 0 ? (missingSec / grossSec) * 100 : 0;

  // ‚úÖ 1) Top label: Missing Task Hours (laranja quando > 0)
  const topEl = document.getElementById('depTotalHours');
  if (topEl) {
    topEl.textContent = missingFormatted;
    topEl.style.fontWeight = 'bold';
    topEl.style.color = (missingSec > 0) ? '#ff8c00' : 'green';
  }

  // ‚úÖ 2) Secondary label: horas + %
    const el = document.getElementById('missingTaskHours');
  if (el) {
    const label = `${missingFormatted} (${percent.toFixed(2)}%)`;
    el.innerHTML = `<span style="font-weight:bold;">${label}</span>`;

    // ‚úÖ 0 = verde / >0 = vermelho igual OT
    el.style.color = percent === 0 ? "green" : "#c1121f";
  }
}



function getWorkerTypeAndSupervisor(personNumber, typeText) {
  const typeLC = String(typeText || '').toLowerCase();
  const isCore = typeLC.includes('core');

  // ‚úÖ AGY/247/Extra/etc: Worker Type = Agency (Type), Supervisor = Agency (Type)
  if (!isCore) {
    const agy = String(typeText || '').trim();
    return { workerType: agy, supervisor: agy };
  }

  // ‚úÖ CORE: vem do Employee Master
  const empId = (typeof normalizeEmpId === 'function')
    ? normalizeEmpId(personNumber)
    : String(personNumber || '').replace(/\D/g, '').trim();

  const rec = (window.employeeMasterIndex && empId)
    ? window.employeeMasterIndex[empId]
    : null;

  return {
    workerType: String(rec?.workerType || '').trim(),
    supervisor: String(rec?.supervisor || '').trim()
  };
}

      function displayResults(data) {
  const tbody = document.querySelector('#resultTable tbody');
  tbody.innerHTML = '';

  const COL = window.COL; // usa o mapa de 15 colunas

  if (!Array.isArray(data) || data.length === 0) {
  tbody.innerHTML = '<tr><td colspan="15" style="text-align:center;">No results found</td></tr>';
  updateHeadcount();
  updateMissingTaskCount(); // ‚úÖ agora esta fun√ß√£o j√° atualiza: pessoas + horas + %
  return;
}


  // helpers (CORE usa Employee Master; AGY/Extra/247 devolve o Type)
  const master = window.employeeMasterIndex || {};

  const normId = (v) => {
    if (typeof normalizeEmpId === 'function') return normalizeEmpId(v);
    return String(v || '').replace(/\D/g, '').trim();
  };

  const getMasterRec = (personNumber) => {
    const id = normId(personNumber);
    return id ? (master[id] || null) : null;
  };

  const resolveWorkerType = (entry, typeCell) => {
    const isCore = String(typeCell || '').toLowerCase().includes('core');
    if (!isCore) return typeCell; // üëà AGY/Extra/247: mostra a ag√™ncia (Type)

    const rec = getMasterRec(entry.personNumber);
    const wt = rec?.workerType || rec?.WorkerType || rec?.worker_type || '';
    return wt || ''; // CORE: Full-Time / Part-Time vindo do master
  };

  const resolveSupervisor = (entry, typeCell) => {
    const isCore = String(typeCell || '').toLowerCase().includes('core');
    if (!isCore) return typeCell; // üëà AGY: supervisor = pr√≥pria ag√™ncia (Type)

    const rec = getMasterRec(entry.personNumber);
    const sup = rec?.supervisorName || rec?.SupervisorName || rec?.supervisor || '';
    return sup || '';
  };

  const rowsHtml = data.map(entry => {
    const typeCell = getEmployeeType(entry.employee);

    const workerTypeCell = resolveWorkerType(entry, typeCell);
    const supervisorCell = resolveSupervisor(entry, typeCell);

    // Hours Dec
    const hoursDecCell = (() => {
      if (typeof entry.totalHoursDecimal === 'number') return entry.totalHoursDecimal.toFixed(2);
      const t = entry.totalHoursFormatted || '00:00:00';
      const [h = 0, m = 0, s = 0] = String(t).split(':').map(Number);
      const dec = h + m / 60 + s / 3600;
      return dec.toFixed(2);
    })();

    // Total Hours (HH:MM)
    const totalHoursCell = (() => {
      const [h = 0, m = 0, s = 0] = String(entry.totalHoursFormatted || '00:00:00').split(':').map(Number);
      return formatTime(h * 3600 + m * 60 + s);
    })();

    return `
      <tr>
        <td>${entry.employee || ''}</td>
        <td>${typeCell || ''}</td>
        <td>${entry.personNumber || ''}</td>

        <td>${workerTypeCell || ''}</td>
        <td>${supervisorCell || ''}</td>

        <td>${entry.role || ''}</td>
        <td>${entry.date || ''}</td>
        <td>${entry.week || ''}</td>
        <td>${entry.month || ''}</td>

        <td>${
          entry.labourAccountStyle
            ? `<span style="${entry.labourAccountStyle}">${entry.labourAccount || ''}</span>`
            : (entry.labourAccount || '')
        }</td>

        <td>${entry.department || ''}</td>

        <td>${
          entry.taskStyle
            ? `<span style="${entry.taskStyle}">${entry.task || ''}</span>`
            : (entry.task || 'N/A')
        }</td>

        <td>${hoursDecCell}</td>
        <td>${totalHoursCell}</td>
        <td>${entry.payCode || ''}</td>
      </tr>
    `;
  }).join('');

  tbody.innerHTML = rowsHtml;

  updateHeadcount();
  updateMissingTaskCount();
  updateMissingTaskHours();
}


 function updateTotalHours(data) {
  let totalMinutes   = 0;
  let ecomMinutes    = 0;
  let retailMinutes  = 0;
  let breakMinutes   = 0;
  let loggedMinutes  = 0;

  grossMinutes = 0;

  data.forEach(entry => {
    const [hours = 0, minutes = 0, seconds = 0] =
      (entry.totalHoursFormatted || '00:00:00')
        .split(':')
        .map(Number);

    const entrySeconds = hours * 3600 + minutes * 60 + seconds;

    // ‚ÄúgrossMinutes‚Äù aqui na verdade est√° em segundos, mas mantemos o nome
    grossMinutes += entrySeconds;

    if (entry.department) {
      totalMinutes += entrySeconds;

      if (entry.department === 'Ecom') {
        ecomMinutes += entrySeconds;
      } else if (entry.department === 'Retail') {
        retailMinutes += entrySeconds;
      } else if (entry.department === 'Break') {
        breakMinutes += entrySeconds;
      }

      if (entry.task && entry.task !== 'N/A') {
        loggedMinutes += entrySeconds;
      }
    }
  });

  // Atualiza labels principais (usando formatTime em segundos)
  document.getElementById('grossHours').textContent  = formatTime(grossMinutes);
  document.getElementById('loggedHours').textContent = formatTime(loggedMinutes);
  document.getElementById('totalBreak').textContent  = formatTime(breakMinutes);
  document.getElementById('totalEcom').textContent   = formatTime(ecomMinutes);
  document.getElementById('totalRetail').textContent = formatTime(retailMinutes);

  // Cor da Logged Hours se maior que Gross
  if (grossMinutes > loggedMinutes) {
    document.getElementById('loggedHours').style.color = "#ff8c00";
  } else {
    document.getElementById('loggedHours').style.color = "";
  }

  // Guarda totalMinutes (para l√≥gicas j√° existentes)
  originalTotalMinutes = totalMinutes;

  // Mant√©m o comportamento original de updateResult()
  updateResult();
}


function updatePlannedLabel() {
  const label = document.getElementById('plannedLabel');
  label.textContent = 'Planned Hours';
}
// ==== HELPERS: Budget por semana ==================================
function getBudgetForTaskWeek(task, weekNum) {
  if (!plannedHoursTracker || !plannedHoursTracker[task]) return null;

  const obj   = plannedHoursTracker[task];
  const wkKey = String(weekNum);

  // NOVO formato: budgets por semana
  if (obj.budgets && obj.budgets[wkKey] != null) {
    return obj.budgets[wkKey];          // horas em decimal
  }

  // COMPATIBILIDADE: se ainda existir um budget ‚Äúantigo‚Äù global,
  // devolve-o (vai desaparecer quando voltares a gravar as semanas).
  if (typeof obj.budget === 'number') {
    return obj.budget;
  }

  return null;
}

function setBudgetForTaskWeek(task, weekNum, valueDec) {
  plannedHoursTracker[task] = plannedHoursTracker[task] || {};
  const wkKey = String(weekNum);

  plannedHoursTracker[task].budgets = plannedHoursTracker[task].budgets || {};

  if (valueDec == null) {
    delete plannedHoursTracker[task].budgets[wkKey];
  } else {
    plannedHoursTracker[task].budgets[wkKey] = valueDec;  // horas em decimal
  }
}


function displayBudgetOverview() {
  updatePlannedLabel();

  // 1) L√™ o filtro de task
  const filterValue = document.getElementById('modalTaskFilter').value.toLowerCase();

  // 2) Monta o overview[task][date] = totalSeconds
//    ‚úÖ AGORA respeita exatamente os filtros da Home (incluindo Pay Code)
const sourceData = getFilteredData();     // <- vem do cache do filterTable()
const aggregatedData = aggregateData(sourceData);


  const aggregatedDataFiltered =
        currentDepartmentFilter === 'All'
      ? aggregatedData
      : aggregatedData.filter(entry => {
          if (currentDepartmentFilter === 'Break') {
            return entry.labourAccount.endsWith('4010') ||
                   /break/i.test(entry.task.toLowerCase());
          }
          return entry.department === currentDepartmentFilter;
        });

  const overview = {};
  aggregatedDataFiltered.forEach(entry => {
    const tsk = entry.task;
    const dateKey = entry.date;
    if (!overview[tsk])          overview[tsk] = {};
    if (!overview[tsk][dateKey]) overview[tsk][dateKey] = 0;
    const [h=0,m=0,s=0] = (entry.totalHoursFormatted || '00:00:00').split(':').map(Number);
    overview[tsk][dateKey] += h*3600 + m*60 + s;
  });

  let dates = [];
let currentWeek = null;

if (aggregatedDataFiltered.length) {
  const weekNum = aggregatedDataFiltered[0].week;
  currentWeek   = Number(weekNum);

  // ‚úÖ FIX: descobre o ANO dominante nos dados filtrados desta semana
  const yearForWeek = (() => {
    const counts = {}; // { 2025: 10, 2026: 2, ... }

    aggregatedDataFiltered.forEach(e => {
      if (String(e.week) !== String(weekNum)) return;
      if (!e.date) return;

      const parts = String(e.date).split('/').map(Number);
      if (parts.length !== 3) return;

      const y = parts[2];
      if (!y || isNaN(y)) return;

      counts[y] = (counts[y] || 0) + 1;
    });

    const years = Object.keys(counts);
    if (!years.length) return new Date().getFullYear();

    // mais frequente; empate ‚Üí ano mais recente
    years.sort((a, b) => (counts[b] - counts[a]) || (Number(b) - Number(a)));
    return Number(years[0]);
  })();

  const [weekStart, weekEnd] = getWeekRange(yearForWeek, weekNum);

  for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
    dates.push(d.toLocaleDateString('en-GB'));
  }
}

  // 4) Soma apenas as tasks que passam no filtro
  const tasksToSum = Object.keys(overview)
    .filter(tsk => filterValue === '' || tsk.toLowerCase().includes(filterValue));

  let sumConsumed = 0;
  let sumPlannedSeconds = 0;

  tasksToSum.forEach(tsk => {
    dates.forEach(dateKey => {
      // consumo real
      const consumedSec = overview[tsk]?.[dateKey] || 0;
      sumConsumed += consumedSec;
      // planned por dia
      const pd = plannedHoursTracker[tsk]?.[dateKey];
      if (pd != null) sumPlannedSeconds += Math.round(pd * 3600);
    });
  });

  // ‚îÄ‚îÄ‚îÄ NOVO BLOCO (logo ap√≥s somar sumConsumed e sumPlannedSeconds) ‚îÄ‚îÄ‚îÄ
  const sumBudgetSeconds = tasksToSum.reduce((sum, tsk) => {
  if (currentWeek == null) return sum;
  const bd = getBudgetForTaskWeek(tsk, currentWeek);   // horas
  return sum + (bd != null ? bd * 3600 : 0);
}, 0);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // 5) Atualiza os r√≥tulos din√¢micos de KPI
  document.getElementById('totalConsumed').textContent = formatTime(sumConsumed);
  document.getElementById('totalPlanned').textContent  = formatTimeHHMM(sumPlannedSeconds);

  // 5.1) Calcula e atualiza o Planned Diff.
  const diffSec  = sumConsumed - sumPlannedSeconds;
  const absDiff  = Math.abs(diffSec);
  const diffSign = diffSec > 0 ? '+' : '-';
  const diffText = `${diffSign}${formatTime(absDiff)}`;
  const diffEl   = document.getElementById('totalDifference');
  diffEl.textContent      = diffText;
  diffEl.style.color      = diffSec > 0 ? 'red' : 'green';
  diffEl.style.fontWeight = 'bold';

  // 5.2) Budget Diff. = sumConsumed ‚Äì sumBudgetSeconds
const budgetDiffSec = sumConsumed - sumBudgetSeconds;
const budgetDiffEl  = document.getElementById('totalBudgetDifference');
// sempre mostrar "+" se valor >= 0
budgetDiffEl.textContent = (budgetDiffSec >= 0 ? '+' : '-') + formatTime(Math.abs(budgetDiffSec));
// mesma cor do Planned Diff. (vermelho se excedeu, verde se dentro)
budgetDiffEl.style.color      = budgetDiffSec > 0 ? 'red' : 'green';
// mesmo peso de fonte
budgetDiffEl.style.fontWeight = 'bold';

// 5.3) Budget Total = soma de todos os budgets lan√ßados
const totalBudgetEl = document.getElementById('totalBudget');
totalBudgetEl.textContent     = formatTimeHHMM(sumBudgetSeconds);
// deixa em negrito igual √†s outras labels
totalBudgetEl.style.fontWeight = 'bold';
// copia a cor do elemento totalPlanned (normalmente √© padr√£o, ou ajuste √† sua paleta)
totalBudgetEl.style.color      = window.getComputedStyle(
  document.getElementById('totalPlanned')
).color;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // 6) Monta o piv√¥ semanal (cabe√ßalho + corpo) ‚Äî continua como antes‚Ä¶
  const table = document.getElementById('budgetTable');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  const dayNames = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];



  // 6.1) Header em 2 linhas
thead.innerHTML = '';
const headerRow1 = document.createElement('tr');
const thTask     = document.createElement('th');
thTask.rowSpan   = 2;
thTask.textContent = 'Task';
headerRow1.appendChild(thTask);

// existing date‚Äêcolumns
dates.forEach(dateKey => {
  const [d,m,y] = dateKey.split('/');
  const lbl     = `${d}-${m}-${y.slice(-2)}`;
  const dow     = dayNames[new Date(`${y}-${m}-${d}`).getDay()];
  const th      = document.createElement('th');
  th.colSpan    = 3;
  th.innerHTML  = `${lbl}<br>${dow}`;
  headerRow1.appendChild(th);
});

// ‚îÄ‚îÄ NOVO: coluna Budget ‚îÄ‚îÄ
const thBudget = document.createElement('th');
thBudget.rowSpan    = 2;
thBudget.textContent = 'Budget';
headerRow1.appendChild(thBudget);

thead.appendChild(headerRow1);

const headerRow2 = document.createElement('tr');
dates.forEach(() => {
  ['Consumed','Planned','Diff.'].forEach(txt => {
    const th = document.createElement('th');
    th.textContent = txt;
    headerRow2.appendChild(th);
  });
});
thead.appendChild(headerRow2);


  // 6.2) Corpo da tabela
tbody.innerHTML = '';
Object.keys(overview)
  .filter(tsk => filterValue === '' || tsk.toLowerCase().includes(filterValue))
  .sort()
  .forEach(tsk => {
    const tr = document.createElement('tr');
    // Task
    const tdTask = document.createElement('td');
    tdTask.textContent = tsk;
    tr.appendChild(tdTask);

    // Vamos acumular aqui o total consumido na semana
    let weekConsumedSec = 0;

    // Para cada dia: Consumed | Planned | Diff.
    dates.forEach(dateKey => {
      const consumedSec = overview[tsk][dateKey] || 0;
      weekConsumedSec  += consumedSec;                // acumula

      const plannedDec  = (plannedHoursTracker[tsk] || {})[dateKey] || 0;
      const plannedSec  = Math.round(plannedDec * 3600);
      const diffDaySec  = consumedSec - plannedSec;


      // Consumed
      const tdC = document.createElement('td');
      tdC.textContent     = formatTime(consumedSec);
      tdC.style.textAlign = 'right';
      tdC.style.fontSize  = '0.85rem';
      tr.appendChild(tdC);

      // Planned
      const tdP = document.createElement('td');
      tdP.textContent     = formatTime(plannedSec);
      tdP.style.textAlign = 'right';
      tdP.style.fontSize  = '0.85rem';
      tr.appendChild(tdP);

      // Diff.
      const tdD = document.createElement('td');
      const arrow    = diffDaySec > 0 ? '‚ñº ' : diffDaySec < 0 ? '‚ñ≤ ' : '';
      const sign     = diffDaySec > 0 ? '-' : '';
      const diffTxt  = `${sign}${formatTime(Math.abs(diffDaySec))}`;
      tdD.textContent      = `${arrow}${diffTxt}`;
      tdD.style.color      = diffDaySec > 0 ? 'red' : 'green';
      tdD.style.fontWeight = 'bold';
      tdD.style.fontSize   = '0.85rem';
      tdD.title            = `${formatTime(consumedSec)} ‚Äì ${formatTime(plannedSec)}`;
      if (Math.abs(diffDaySec) > 2 * 3600) tdD.style.background = '#ffe6e6';
      tr.appendChild(tdD);
    });

    // ‚îÄ‚îÄ NOVO: c√©lula Budget Restante com seta ‚îÄ‚îÄ
const budgetDec = currentWeek != null
  ? (getBudgetForTaskWeek(tsk, currentWeek) || 0)
  : 0;
const budgetSec = budgetDec * 3600;

// subtrai o total consumido na semana
const remainSec = budgetSec - weekConsumedSec;
// escolhe a seta conforme sobra ou estoura
const arrow     = remainSec > 0  ? '‚ñ≤ '  // ainda sobra
                 : remainSec < 0  ? '‚ñº '  // ultrapassou
                 : '';                  // exato
// formata HH:MM
const hRem       = Math.floor(Math.abs(remainSec) / 3600);
const mRem       = Math.round((Math.abs(remainSec) % 3600) / 60);
const remainText = `${arrow}${String(hRem).padStart(2,'0')}:${String(mRem).padStart(2,'0')}`;

const tdB = document.createElement('td');
tdB.textContent      = remainText;
tdB.style.textAlign  = 'right';
tdB.style.fontWeight = 'bold';
tdB.style.color      = remainSec < 0 ? 'red' : 'green';
// fonte menor s√≥ na coluna Budget
tdB.style.fontSize   = '0.86rem';

tr.appendChild(tdB);
tbody.appendChild(tr);

  });
}
// =========================================================
// OT Threshold (Weekly) usando Employee Master (CORE only)
// - AGY: sempre 40h/sem
// - CORE: Exp Weekly Hours do master; se n√£o existir, cai para 40h
// =========================================================
function isAgencyType(typeLC) {
  const t = String(typeLC || '').toLowerCase();
  return t.includes('agy') || t.includes('247') || t.includes('extr');
}

function getWeeklyThresholdSecForRow(personNumber, employeeName, typeTextMaybe) {
  // 1) Determina type (CORE/AGY...) da forma mais segura poss√≠vel
  let typeLC = String(typeTextMaybe || '').toLowerCase().trim();

  // se n√£o veio do TYPE da tabela, tenta inferir pelo nome via getEmployeeType()
  if (!typeLC && typeof getEmployeeType === 'function') {
    typeLC = String(getEmployeeType(employeeName || '') || '').toLowerCase();
  }

  // 2) AGY mant√©m 40h SEMPRE
  if (isAgencyType(typeLC)) return 40 * 3600;

  // 3) CORE -> usa master
  const empId = normalizeEmpId(personNumber); // <- j√° existe do bloco do master
  const idx = window.employeeMasterIndex || {};
  const rec = idx[empId];

  const expSec = rec && Number(rec.expWeeklySeconds);
  if (expSec && Number.isFinite(expSec) && expSec > 0) {
    return expSec;
  }

  // fallback seguro
  return 40 * 3600;
}
// =====================================================
// CONTRACT FILE (Full-Time / Part-Time) ‚Äî Loader + Map
// Emp ID (Kronos Person Number) -> { workerType, expWeeklyHoursText, ... }
// =====================================================
(function initContractModule() {
  const STORAGE_KEY = 'contractInfo_v1';

  // Map: EmpID -> info
  window.contractInfoMap = new Map();

  // ---------- helpers ----------
  function normalizeId(v) {
    return String(v || '').trim();
  }

  function parseWeeklyHoursToText(v) {
    // aceita "40:00:00" ou "20:00" ou "20"
    const raw = String(v || '').trim();
    if (!raw) return '';

    // se j√° tem ":" mant√©m
    if (raw.includes(':')) {
      const parts = raw.split(':').map(p => p.trim()).filter(Boolean);
      if (parts.length === 2) return `${parts[0].padStart(2,'0')}:${parts[1].padStart(2,'0')}:00`;
      if (parts.length === 3) return `${parts[0].padStart(2,'0')}:${parts[1].padStart(2,'0')}:${parts[2].padStart(2,'0')}`;
      return raw;
    }

    // se for n√∫mero tipo "20"
    const n = Number(raw);
    if (Number.isFinite(n)) return `${String(Math.floor(n)).padStart(2,'0')}:00:00`;
    return raw;
  }

  // Parser robusto:
  // - se tiver TAB -> trata como TSV
  // - se tiver v√≠rgula sem quotes (nome "Abdi, Amirah") -> reconstr√≥i a partir da direita (√∫ltimas 4 colunas)
  function parseContractText(text) {
    const lines = String(text || '')
      .replace(/\r/g, '')
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean);

    if (!lines.length) return new Map();

    const header = lines[0];
    const isTSV = header.includes('\t');

    const map = new Map();

    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      if (!line) continue;

      let fullName = '';
      let empId = '';
      let supervisor = '';
      let expHours = '';
      let workerType = '';

      if (isTSV) {
        const cols = line.split('\t');
        // Esperado: 5 colunas
        fullName   = (cols[0] || '').trim();
        empId      = (cols[1] || '').trim();
        supervisor = (cols[2] || '').trim();
        expHours   = (cols[3] || '').trim();
        workerType = (cols[4] || '').trim();
      } else {
        // CSV com v√≠rgula e nomes com v√≠rgula SEM quotes:
        // vamos ‚Äúcortar‚Äù as √∫ltimas 4 colunas a partir da direita
        const parts = line.split(',').map(p => p.trim());

        if (parts.length >= 5) {
          workerType = parts[parts.length - 1] || '';
          expHours   = parts[parts.length - 2] || '';
          supervisor = parts[parts.length - 3] || '';
          empId      = parts[parts.length - 4] || '';
          fullName   = parts.slice(0, parts.length - 4).join(', ').trim();
        } else {
          // fallback (linha mal formatada)
          continue;
        }
      }

      empId = normalizeId(empId);
      if (!empId) continue;

      const info = {
        fullName: fullName || '',
        empId,
        supervisor: supervisor || '',
        expWeeklyHoursText: parseWeeklyHoursToText(expHours),
        workerType: workerType || ''
      };

      map.set(empId, info);
    }

    return map;
  }

  function saveToStorage(map) {
    try {
      const arr = Array.from(map.values());
      localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
    } catch (e) {
      console.warn('ContractInfo: failed to save storage', e);
    }
  }

    function loadFromStorage() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;

      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return;

      window.contractInfoMap.clear();
      arr.forEach(obj => {
        const empId = normalizeId(obj?.empId);
        if (!empId) return;
        window.contractInfoMap.set(empId, {
          fullName: obj.fullName || '',
          empId,
          supervisor: obj.supervisor || '',
          expWeeklyHoursText: obj.expWeeklyHoursText || '',
          workerType: obj.workerType || ''
        });
      });
    } catch (e) {
      console.warn('ContractInfo: failed to load storage', e);
    }
  }

  // =========================================================
  // ‚úÖ TYPE (FT/PT) ‚Äî CORE via ContractInfoMap | AGY via entry.type
  // =========================================================
  function normalizeEmpIdDigits(raw) {
    // mant√©m s√≥ d√≠gitos (personNumber/Emp ID)
    return String(raw || '').replace(/\D/g, '').trim();
  }

  function normalizeTypeKey(s) {
    // iguala "Full-Time" == "Full Time" == "full_time"
    return String(s || '')
      .toLowerCase()
      .replace(/[\s\-_]+/g, '');
  }

  // ‚úÖ devolve Worker Type para filtros e para a tabela:
  // - CORE: vem do CSV master (window.contractInfoMap)
  // - AGY : devolve a Agency (entry.type)
  function getEmployeeType(entry) {
    if (!entry || typeof entry !== 'object') return '';

    const empId  = normalizeEmpIdDigits(entry.personNumber || entry.empId || '');
    const agency = String(entry.type || '').trim();

    const rec = (window.contractInfoMap && empId)
      ? window.contractInfoMap.get(empId)
      : null;

    if (rec && rec.workerType) return String(rec.workerType).trim(); // ‚úÖ CORE
    return agency; // ‚úÖ AGY (ou vazio)
  }

  // ‚úÖ (opcional, mas j√° deixa pronto) Supervisor:
  // - CORE: supervisor do Master
  // - AGY : agency (entry.type)
  function getEmployeeSupervisor(entry) {
    if (!entry || typeof entry !== 'object') return '';

    const empId  = normalizeEmpIdDigits(entry.personNumber || entry.empId || '');
    const agency = String(entry.type || '').trim();

    const rec = (window.contractInfoMap && empId)
      ? window.contractInfoMap.get(empId)
      : null;

    if (rec && rec.supervisor) return String(rec.supervisor).trim(); // ‚úÖ CORE
    return agency; // ‚úÖ AGY
  }


  // ---------- PUBLIC API ----------
  // ‚úÖ Esta √© a fun√ß√£o que o teu filtro vai usar
  window.getContractInfoByPerson = function getContractInfoByPerson(personNumber) {
    const key = normalizeId(personNumber);
    if (!key) return null;
    return window.contractInfoMap.get(key) || null;
  };

  // ‚úÖ Loader: recebe um File (do input) e popula o Map
  window.loadContractFile = async function loadContractFile(file) {
    if (!file) return false;

    const text = await file.text();
    const map = parseContractText(text);

    window.contractInfoMap.clear();
    map.forEach((v, k) => window.contractInfoMap.set(k, v));

    saveToStorage(window.contractInfoMap);

    console.log(`ContractInfo loaded: ${window.contractInfoMap.size} rows`);
    return true;
  };

  // ‚úÖ UI opcional: cria um input escondido e um bot√£o "Upload Contract"
  // (n√£o mexe no teu HTML se n√£o quiseres)
  window.openContractUploadDialog = function openContractUploadDialog() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = '.csv,text/csv,.tsv,text/tab-separated-values';
    inp.style.display = 'none';

    inp.addEventListener('change', async () => {
      const file = inp.files?.[0];
      if (!file) return;

      const ok = await window.loadContractFile(file);
      if (ok && typeof filterTable === 'function') {
        filterTable(); // re-aplica filtros j√° com FT/PT dispon√≠vel
      }
      inp.remove();
    });

    document.body.appendChild(inp);
    inp.click();
  };

  // auto-load do storage (se j√° tinhas carregado antes)
  loadFromStorage();
})();
/* ===========================
   IndexedDB Layer (CSV Rows)
   =========================== */
const IDB_DB_NAME    = 'BudgetTrackerDB';
const IDB_DB_VERSION = 1;
const IDB_STORE      = 'csvRows';

function idbOpen() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_DB_NAME, IDB_DB_VERSION);

    req.onupgradeneeded = () => {
      const db = req.result;

      if (!db.objectStoreNames.contains(IDB_STORE)) {
        // key auto para n√£o depender de campos do CSV
        const store = db.createObjectStore(IDB_STORE, { keyPath: 'id', autoIncrement: true });

        // (opcional) indexes √∫teis ‚Äî podes ignorar se n√£o precisares j√°
        store.createIndex('dateISO', 'dateISO', { unique: false });
        store.createIndex('week', 'week', { unique: false });
        store.createIndex('employee', 'employee', { unique: false });
        store.createIndex('personNumber', 'personNumber', { unique: false });
      }
    };

    req.onsuccess = () => resolve(req.result);
    req.onerror   = () => reject(req.error);
  });
}

function idbTx(mode, fn) {
  return idbOpen().then(db => new Promise((resolve, reject) => {
    const tx    = db.transaction(IDB_STORE, mode);
    const store = tx.objectStore(IDB_STORE);

    let out;
    try { out = fn(store, tx); } catch (e) { reject(e); return; }

    tx.oncomplete = () => resolve(out);
    tx.onerror    = () => reject(tx.error || new Error('IDB tx error'));
    tx.onabort    = () => reject(tx.error || new Error('IDB tx aborted'));
  }));
}

async function idbClearCsvRows() {
  return idbTx('readwrite', (store) => { store.clear(); });
}

// rows: array de objetos (linhas do CSV)
// opts.replace=true => apaga tudo e grava de novo
async function idbPutCsvRows(rows, opts = {}) {
  const replace   = !!opts.replace;
  const chunkSize = opts.chunkSize || 2000;

  const safeRows = Array.isArray(rows) ? rows : [];
  if (!safeRows.length && replace) {
    await idbClearCsvRows();
    return 0;
  }

  const db = await idbOpen();
  let firstChunk = true;

  for (let i = 0; i < safeRows.length; i += chunkSize) {
    const chunk = safeRows.slice(i, i + chunkSize);

    await new Promise((resolve, reject) => {
      const tx    = db.transaction(IDB_STORE, 'readwrite');
      const store = tx.objectStore(IDB_STORE);

      if (replace && firstChunk) store.clear();
      firstChunk = false;

      for (const row of chunk) {
        store.put(row);
      }

      tx.oncomplete = resolve;
      tx.onerror    = () => reject(tx.error || new Error('IDB put error'));
      tx.onabort    = () => reject(tx.error || new Error('IDB put aborted'));
    });
  }

  return safeRows.length;
}

async function idbGetAllCsvRows() {
  return idbTx('readonly', (store) => {
    return new Promise((resolve, reject) => {
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror   = () => reject(req.error);
    });
  });
}

async function idbCountCsvRows() {
  return idbTx('readonly', (store) => {
    return new Promise((resolve, reject) => {
      const req = store.count();
      req.onsuccess = () => resolve(req.result || 0);
      req.onerror   = () => reject(req.error);
    });
  });
}

/* ‚úÖ EXPORTA PARA O CONSOLE (IMPORTANTE!)
   ‚Äî isto resolve o teu erro mesmo se o script for type="module" */
window.idbOpen          = idbOpen;
window.idbClearCsvRows  = idbClearCsvRows;
window.idbPutCsvRows    = idbPutCsvRows;
window.idbGetAllCsvRows = idbGetAllCsvRows;
window.idbCountCsvRows  = idbCountCsvRows;

function filterTable() {
  const employeeFilter      = document.getElementById('employeeFilter').value.toLowerCase();
  const typeFilter          = document.getElementById('typeFilter')
                             ? document.getElementById('typeFilter').value.toLowerCase()
                             : '';
  const taskFilterRaw       = document.getElementById('taskFilter').value.toLowerCase().trim();
  const taskFilters         = taskFilterRaw
    ? taskFilterRaw.split(/[,;]+/).map(s => s.trim()).filter(Boolean)
    : [];

  const labourAccountFilter = document.getElementById('labourAccountFilter').value.toLowerCase();
  const payCodeFilter       = document.getElementById('payCodeFilter').value.toLowerCase();
  const weekFilter          = document.getElementById('selectWeek').value;
  const monthFilter         = document.getElementById('selectMonth').value;
    const codeFilter          = document.getElementById('codeFilter').value;
  window.currentCodeFilter  = codeFilter;

  // ‚úÖ MODO OT > 40h (Week): robusto (value OU texto do option)
  const codeFilterEl = document.getElementById('codeFilter');

  // ‚úÖ NOVO: multi-select (se existir). Se estiver vazio, cai no dropdown normal.
  const selectedCodeFilters =
    (window.selectedCodeFilters && window.selectedCodeFilters instanceof Set && window.selectedCodeFilters.size > 0)
      ? new Set(window.selectedCodeFilters)
      : new Set();

  if (selectedCodeFilters.size === 0 && codeFilter) {
    selectedCodeFilters.add(codeFilter);
  }

  // (debug/compat opcional)
  window.currentCodeFilterSet = selectedCodeFilters;

  const codeFilterValue = String(codeFilter || '').toLowerCase().trim();
  const codeFilterText  = String(
    codeFilterEl?.options?.[codeFilterEl.selectedIndex]?.textContent || ''
  ).toLowerCase().trim();

  const looksLikeOt40Week = (str) => {
    const s = String(str || '').toLowerCase();
    return s.includes('ot') && (s.includes('40') || s.includes('40h')) && s.includes('week');
  };

  const anySelectedLooksLikeOt40 =
    Array.from(selectedCodeFilters).some(v => looksLikeOt40Week(v));

  let isOt40WeekMode =
  anySelectedLooksLikeOt40 ||
  codeFilterValue === 'overtime' ||
  codeFilterValue === 'ot40' ||
  codeFilterValue === 'ot40week' ||
  looksLikeOt40Week(codeFilterValue) ||
  looksLikeOt40Week(codeFilterText);

// ‚úÖ NOVO: Break = Over Spending. N√£o faz sentido misturar com OT >40h (Week).
if (currentDepartmentFilter === 'Break' && isOt40WeekMode) {
  // limpa sele√ß√£o do multi-select
  if (window.selectedCodeFilters && window.selectedCodeFilters instanceof Set) {
    Array.from(window.selectedCodeFilters).forEach(v => {
      if (looksLikeOt40Week(v) || v === 'overtime' || v === 'ot40' || v === 'ot40week') {
        window.selectedCodeFilters.delete(v);
      }
    });
  }

  // reseta dropdown legado
  if (codeFilterEl) codeFilterEl.value = '';

  // reseta label do bot√£o do multi-select (se existir)
  const btnCode = document.getElementById('codeMultiSelectBtn');
  if (btnCode) btnCode.textContent = 'All ‚ñæ';

  isOt40WeekMode = false;
}

// ‚úÖ AQUI √â O PONTO CERTO: exp√µe o modo atual para o KPI (updateOvertimeLabel)
window.isOt40WeekMode = !!isOt40WeekMode;

const dateFilter          = document.getElementById('dateFilter').value;

// ‚úÖ (legacy-safe) OT People dropdown (mesmo que n√£o exista no HTML, n√£o quebra nada)
const otPeopleEl = document.getElementById('otPeopleFilter');
const otPersonFilter = otPeopleEl ? otPeopleEl.value.trim() : '';

const rows = document.querySelectorAll('#resultTable tbody tr');

// ‚úÖ COLUNAS DA TABELA (15 colunas) ‚Äî GLOBAL (usar em tudo)
window.COL = {
  employee    : 0,
  type        : 1,
  person      : 2,

  workerType  : 3,
  supervisor  : 4,

  role        : 5,
  date        : 6,
  week        : 7,
  month       : 8,

  labour      : 9,

  // ‚úÖ alias duplo (dep/department) pra n√£o quebrar trechos antigos
  dep         : 10,
  department  : 10,

  task        : 11,
  hoursDec    : 12,
  totalHours  : 13,
  payCode     : 14
};


// =======================
// Helper: aplica TODOS os filtros atuais,
// mas IGNORA o pr√≥prio modo OT>40 (Week)
// + ‚úÖ pode ignorar Employee (para headcount total)
// =======================
function passesFiltersExcludingOT(
  cells,
  ignoreEmployee = false,
  ignoreDate = false,
  ignoreDepartment = false,
  ignoreLabour = false,
  ignoreTask = false
) {
  const employeeText      = (cells[COL.employee]?.textContent || '').toLowerCase();
  const typeText          = (cells[COL.type]?.textContent || '').toLowerCase();
  const personNumber      = (cells[COL.person]?.textContent || '').trim();
  const roleText          = (cells[COL.role]?.textContent || '').trim();
  const dateText          = (cells[COL.date]?.textContent || '').trim();
  const weekText          = (cells[COL.week]?.textContent || '').trim();
  const monthText         = (cells[COL.month]?.textContent || '').trim();
  const labourAccountText = (cells[COL.labour]?.textContent || '').toLowerCase();
  const departmentText    = (cells[COL.department]?.textContent || '').trim();
  const taskText          = (cells[COL.task]?.textContent || '').trim();
  const taskTextLC        = taskText.toLowerCase();
  const payCodeText       = (cells[COL.payCode]?.textContent || '').toLowerCase();

  // Task multi-filter
  const matchesTask =
    ignoreTask ||
    taskFilters.length === 0 ||
    taskFilters.some(f => taskTextLC.includes(f));

  let show =
    (ignoreEmployee || employeeText.includes(employeeFilter)) &&
    (ignoreLabour || labourAccountText.includes(labourAccountFilter)) &&
    matchesTask;

  // Type
  if (typeFilter && !typeText.includes(typeFilter)) show = false;

  // Pay Code (dropdown + multi)
  let passesPayCode = true;

  if (payCodeFilter && payCodeText !== payCodeFilter) {
    passesPayCode = false;
  }

  if (window.selectedPayCodes && window.selectedPayCodes.size > 0) {
    if (!window.selectedPayCodes.has(payCodeText)) {
      passesPayCode = false;
    }
  }

  if (!passesPayCode) show = false;

  // Week / Month
  if (weekFilter  && weekText  !== weekFilter)  show = false;
  if (monthFilter && monthText !== monthFilter) show = false;

  // Department slicer
  if (!ignoreDepartment && currentDepartmentFilter && currentDepartmentFilter !== 'All') {
    if (currentDepartmentFilter === 'Break') {
      const labourDigits = String(cells[COL.labour]?.textContent || '').replace(/\D/g, '');
      const taskLC2      = String(cells[COL.task]?.textContent || '').toLowerCase();

      const isBreakRow =
        labourDigits.endsWith('4010') ||
        /-4010\b/.test(taskLC2) ||
        taskLC2.includes('paid break');

      if (!isBreakRow) show = false;
    } else {
      if (departmentText !== currentDepartmentFilter) show = false;
    }
  }

  // Date (ISO)
  if (dateFilter && !ignoreDate) {
    const [d, m, y] = dateText.split('/');
    const isoDate = `${y}-${String(m||'').padStart(2,'0')}-${String(d||'').padStart(2,'0')}`;
    if (isoDate !== dateFilter) show = false;
  }

  if (!personNumber || !weekText) show = false;

  return show;
}

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Somar horas base de OT (CORE + AGY: semanal)
//    ‚úÖ NOVO: Paid Break (4010 / Paid Break) CONTA para OT,
//    mas com CAP di√°rio:
//      - threshold >= 40h  => conta at√© 30 min/dia
//      - threshold >= 30h  => conta at√© 20 min/dia
//      - threshold <  30h  => 0 (n√£o conta)
//    ‚úÖ mant√©m filtros atuais e ignora DATE para construir a base semanal
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const weeklyTotals = {};       // person|week -> totalSec (work + break capado)
const breakDayTotals = {};     // person|week|date -> breakSecRaw (s√≥ paid break)
const typeByKeyWeek = {};      // person|week -> type
const employeeByPerson = {};   // person -> employee

function isPaidBreakRowFromCells(cells) {
  const labourDigits = String(cells[COL.labour]?.textContent || '').replace(/\D/g, '');
  const taskLC2      = String(cells[COL.task]?.textContent || '').toLowerCase();

  return (
    labourDigits.endsWith('4010') ||
    /-4010\b/.test(taskLC2) ||
    taskLC2.includes('paid break')
  );
}

rows.forEach(row => {
  const cells = row.getElementsByTagName('td');
  if (!cells.length) return;

  if (typeof passesFiltersExcludingOT === 'function') {
  // ‚úÖ OT semanal deve ignorar Dept/Labour/Task/Date (sen√£o 4010 ‚Äúmata‚Äù o OT)
  if (!passesFiltersExcludingOT(cells, false, true, true, true, true)) return;
}

  const typeText     = (cells[COL.type]?.textContent || '').trim().toLowerCase();
  const personNumber = (cells[COL.person]?.textContent || '').trim();
  const weekText     = (cells[COL.week]?.textContent || '').trim();
  const dateText     = (cells[COL.date]?.textContent || '').trim();
  const hoursText    = (cells[COL.totalHours]?.textContent || '').trim();
  const empName      = (cells[COL.employee]?.textContent || '').trim();

  if (!personNumber || !weekText) return;
  if (!hoursText || hoursText === 'N/A') return;

  const [h = 0, m = 0, s = 0] = String(hoursText).split(':').map(Number);
  const secs = h * 3600 + m * 60 + s;

  const keyWeek = `${personNumber}|${weekText}`;

  // guarda type/nome (para threshold)
  if (!typeByKeyWeek[keyWeek]) typeByKeyWeek[keyWeek] = typeText;
  if (!employeeByPerson[personNumber]) employeeByPerson[personNumber] = empName;

  // ‚úÖ separa work vs paid break
  if (isPaidBreakRowFromCells(cells)) {
    const keyDay = `${personNumber}|${weekText}|${dateText}`;
    breakDayTotals[keyDay] = (breakDayTotals[keyDay] || 0) + secs;
  } else {
    weeklyTotals[keyWeek] = (weeklyTotals[keyWeek] || 0) + secs;
  }
});


// ‚úÖ threshold e break allowance por pessoa|semana
const thresholdByKeyWeek = {};
const breakAllowanceByKeyWeek = {};

Object.keys(weeklyTotals).forEach(keyWeek => {
  const personNumber = keyWeek.split('|')[0];
  const typeLC  = typeByKeyWeek[keyWeek] || '';
  const empName = employeeByPerson[personNumber] || '';

  const thresholdSec = getWeeklyThresholdSecForRow(personNumber, empName, typeLC);
  thresholdByKeyWeek[keyWeek] = thresholdSec;

  let allowance = 0;
  if (thresholdSec >= 40 * 3600) allowance = 30 * 60;      // 30 min
  else if (thresholdSec >= 30 * 3600) allowance = 20 * 60; // 20 min
  else allowance = 0;                                      // <30 => 0
  breakAllowanceByKeyWeek[keyWeek] = allowance;
});

// ‚úÖ adiciona Paid Break ao total semanal, mas CAPADO por dia
const breakEffectiveByKeyDay = {};
Object.entries(breakDayTotals).forEach(([keyDay, breakSecRaw]) => {
  const parts = keyDay.split('|');      // person|week|date
  const personNumber = parts[0];
  const weekText     = parts[1];
  const keyWeek      = `${personNumber}|${weekText}`;

  // se por algum motivo n√£o existir work total, garante a chave
  if (typeof weeklyTotals[keyWeek] === 'undefined') weeklyTotals[keyWeek] = 0;

  const allowance = breakAllowanceByKeyWeek[keyWeek] || 0;
  const effective = allowance > 0 ? Math.min(breakSecRaw, allowance) : 0;

  breakEffectiveByKeyDay[keyDay] = effective;
  weeklyTotals[keyWeek] += effective;
});

// ‚úÖ para distribuir break capado por linha (se houver mais de 1 break no mesmo dia)
const breakEffectiveRemainingByKeyDay = {};
Object.keys(breakEffectiveByKeyDay).forEach(k => {
  breakEffectiveRemainingByKeyDay[k] = breakEffectiveByKeyDay[k];
});


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1.1) OT semanal real por pessoa|semana (AGY e CORE)
// + NOVO: OT por ‚Äúbucket‚Äù (week OU period via getOtBucketKey)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const overtimeByRow = new Map();           // row -> segundos de OT nesta linha
const overtimeRemainingWeek = {};          // person|week -> OT a distribuir (mant√©m compatibilidade)
const weeklyOTByKeyWeek = new Map();       // person|week -> OT semanal real
const weeklyTotalByKeyWeek = new Map();    // person|week -> total semanal (work + break capado)

// ‚úÖ NOVO: mapas por bucket (podem ser person|week OU person|P{period})
const bucketOTByKey = new Map();           // bucketKey -> OT real
const bucketTotalByKey = new Map();        // bucketKey -> total (work + break capado)
const overtimeRemainingBucket = {};        // bucketKey -> OT a distribuir

// ‚úÖ acumuladores para somar semanas dentro do mesmo bucket
const bucketTotals = {};                   // bucketKey -> totalSec somado
const bucketMetaByKey = {};                // bucketKey -> { personNumber, typeLC, empName }

// ‚úÖ NOVO: semanas realmente carregadas por bucket
const bucketWeeksSet = {};                 // bucketKey -> Set(weekStr)

Object.entries(weeklyTotals).forEach(([keyWeek, totalSec]) => {
  const [personNumber, weekStr] = keyWeek.split('|');
  const typeLC  = typeByKeyWeek[keyWeek] || '';
  const empName = employeeByPerson[personNumber] || '';

  const bucketKey = (typeof window.getOtBucketKey === 'function')
    ? window.getOtBucketKey({ personNumber, week: weekStr, type: typeLC, employee: empName })
    : keyWeek;

  bucketTotals[bucketKey] = (bucketTotals[bucketKey] || 0) + (Number(totalSec) || 0);

  if (!bucketMetaByKey[bucketKey]) {
    bucketMetaByKey[bucketKey] = { personNumber, typeLC, empName };
  }

  // ‚úÖ NOVO: regista a week que entrou neste bucket
  if (!bucketWeeksSet[bucketKey]) bucketWeeksSet[bucketKey] = new Set();
  bucketWeeksSet[bucketKey].add(String(weekStr));
});

// ‚úÖ agora calcula OT por bucket (Period inteligente: threshold x weeks realmente carregadas)
Object.entries(bucketTotals).forEach(([bucketKey, totalSec]) => {
  const meta = bucketMetaByKey[bucketKey] || {};
  const personNumber = meta.personNumber || String(bucketKey).split('|')[0] || '';
  const typeLC = meta.typeLC || '';
  const empName = meta.empName || '';

  // threshold ‚Äúsemanal base‚Äù (ex.: 40h p/ AGY, etc.)
  const baseWeekThrSec = getWeeklyThresholdSecForRow(personNumber, empName, typeLC);

  let thrSec = baseWeekThrSec;

  const m = String(bucketKey).match(/\|P(\d+)$/);
if (m) {
  const p = Number(m[1]);

  const weeksInP = (typeof getWeeksInPeriod === 'function')
    ? (getWeeksInPeriod(p) || 1)
    : 1;

  const loadedWeeks = (bucketWeeksSet[bucketKey] && bucketWeeksSet[bucketKey].size)
    ? bucketWeeksSet[bucketKey].size
    : 1;

  const mult = Math.min(loadedWeeks, weeksInP);
  thrSec = baseWeekThrSec * mult;
}


  const otSec = Math.max(0, (Number(totalSec) || 0) - (Number(thrSec) || 0));

  bucketTotalByKey.set(bucketKey, Number(totalSec) || 0);
  bucketOTByKey.set(bucketKey, otSec);
  overtimeRemainingBucket[bucketKey] = otSec;
});

// (opcional) debug
// window.bucketWeeksSet = bucketWeeksSet;
// ‚úÖ exp√µe para o KPI (updateOvertimeLabel) e filtros
window.weeklyOTByKeyWeek = weeklyOTByKeyWeek;
window.weeklyTotalByKeyWeek = weeklyTotalByKeyWeek;

window.bucketOTByKey = bucketOTByKey;
window.bucketTotalByKey = bucketTotalByKey;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1.2) Distribui OT pelas linhas (inclui Paid Break capado)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
rows.forEach(row => {
  const cells = row.getElementsByTagName('td');
  if (!cells.length) return;

  if (typeof passesFiltersExcludingOT === 'function') {
  // ‚úÖ mant√©m distribui√ß√£o est√°vel (Ecom/Retail/Date/Labour/Task n√£o mudam o ‚Äúmotor‚Äù do OT)
  if (!passesFiltersExcludingOT(cells, false, true, true, true, true)) return;
}


  const personNumber = (cells[COL.person]?.textContent || '').trim();
  const weekText     = (cells[COL.week]?.textContent || '').trim();
  const dateText     = (cells[COL.date]?.textContent || '').trim();
  const hoursText    = (cells[COL.totalHours]?.textContent || '').trim();

  if (!personNumber || !weekText) return;
  if (!hoursText || hoursText === 'N/A') return;

  const [h = 0, m = 0, s = 0] = String(hoursText).split(':').map(Number);
  const secsRowRaw = h * 3600 + m * 60 + s;

  // ‚úÖ se for Paid Break, usa o break capado do dia
  let secsRowEffective = secsRowRaw;

  if (isPaidBreakRowFromCells(cells)) {
    const keyDay = `${personNumber}|${weekText}|${dateText}`;
    const left = breakEffectiveRemainingByKeyDay[keyDay] || 0;

    secsRowEffective = Math.min(secsRowRaw, left);
    breakEffectiveRemainingByKeyDay[keyDay] = Math.max(0, left - secsRowEffective);
  }

  let otThisRow = 0;

const keyWeek = `${personNumber}|${weekText}`; // mant√©m (compatibilidade / outros usos)

// ‚úÖ usa bucket (week OU period)
const keyBucket = (typeof window.getOtBucketKey === 'function')
  ? window.getOtBucketKey({
      personNumber,
      week: weekText,
      type: (cells[COL.type]?.textContent || '')
    })
  : keyWeek;

const otLeft  = overtimeRemainingBucket[keyBucket] || 0;

if (otLeft > 0) {
  otThisRow = Math.min(secsRowEffective, otLeft);
  overtimeRemainingBucket[keyBucket] = otLeft - otThisRow;
}

overtimeByRow.set(row, otThisRow);

});

// ‚úÖ mant√©m compatibilidade com o resto do sistema
window.overtimeByRow = overtimeByRow;


// ‚úÖ NOVO: Set de pessoas com OT por semana (person|week)
const otPersonWeekSet = new Set();

rows.forEach(row => {
  const otSec = overtimeByRow.get(row) || 0;
  if (otSec <= 0) return;

  const cells = row.getElementsByTagName('td');
  if (!cells.length) return;

    const personNumber = (cells[COL.person]?.textContent || '').trim();
  const weekText     = (cells[COL.week]?.textContent || '').trim();


  if (!personNumber || !weekText) return;

  otPersonWeekSet.add(`${personNumber}|${weekText}`);
});

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // 2) Loop ‚Äúoficial‚Äù para filtros e KPI‚Äôs
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 grossSeconds     = 0;
loggedSeconds    = 0;
let filteredData     = [],
    totalWorkSeconds = 0;

// ‚úÖ NOVO: total OT por Pessoa|Semana (para o filtro OT n√£o ‚Äúcortar‚Äù linhas)
const otByPersonWeek = new Map();

rows.forEach(r => {
  const c = r.getElementsByTagName('td');
  if (!c.length) return;

    const pNum = (c[COL.person]?.textContent || '').trim(); // Person Number
  const wk   = (c[COL.week]?.textContent || '').trim();   // Week

  if (!pNum || !wk) return;

  const key = `${pNum}|${wk}`;
  const ot  = overtimeByRow.get(r) || 0;

  otByPersonWeek.set(key, (otByPersonWeek.get(key) || 0) + ot);
});

// üîª loop principal continua igual
rows.forEach(row => {
  const cells = row.getElementsByTagName('td');
  if (!cells.length) return;

    const employeeText      = cells[COL.employee].textContent.toLowerCase();
  const typeText          = cells[COL.type].textContent.toLowerCase();
  const personNumber      = cells[COL.person].textContent.trim();
  const roleText          = cells[COL.role].textContent.trim();
  const dateText          = cells[COL.date].textContent.trim();
  const weekText          = cells[COL.week].textContent.trim();
  const monthText         = cells[COL.month].textContent.trim();
  const labourAccountText = cells[COL.labour].textContent.toLowerCase();
  const departmentText    = cells[COL.department].textContent.trim();
  const taskText          = cells[COL.task].textContent.trim();
  const taskTextLC        = taskText.toLowerCase();
  const hoursText         = cells[COL.totalHours].textContent.trim();   // ‚úÖ Total Hours agora √© COL.totalHours
  const payCodeText       = cells[COL.payCode].textContent.toLowerCase();


  const matchesTask =
    taskFilters.length === 0 ||
    taskFilters.some(f => taskTextLC.includes(f));

  let show =
    employeeText.includes(employeeFilter) &&
    labourAccountText.includes(labourAccountFilter) &&
    matchesTask;

  // üîπ Filtro TYPE (din√¢mico como os outros)
  if (typeFilter && !typeText.includes(typeFilter)) show = false;


        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ filtro Pay Code (dropdown + multi-select) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let passesPayCode = true;

    // 1) L√≥gica ORIGINAL ‚Äì dropdown simples (1 Pay Code)
    if (payCodeFilter && payCodeText !== payCodeFilter) {
      passesPayCode = false;
    }

    // 2) NOVO ‚Äì multi-select (painel com checkboxes)
    if (window.selectedPayCodes && window.selectedPayCodes.size > 0) {
      // se o c√≥digo da linha N√ÉO estiver na lista seleccionada ‚Üí reprova
      if (!window.selectedPayCodes.has(payCodeText)) {
        passesPayCode = false;
      }
    }

    if (!passesPayCode) show = false;

    if (weekFilter    && weekText    !== weekFilter)    show = false;
    if (monthFilter   && monthText   !== monthFilter)   show = false;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ filtro por departamento ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (currentDepartmentFilter && currentDepartmentFilter !== 'All') {
  if (currentDepartmentFilter === 'Break') {
    const labourDigits = String(cells[COL.labour]?.textContent || '').replace(/\D/g, '');
    const taskLC2      = String(cells[COL.task]?.textContent || '').toLowerCase();

    const isBreakRow =
      labourDigits.endsWith('4010') ||
      /-4010\b/.test(taskLC2) ||
      taskLC2.includes('paid break');

    if (!isBreakRow) show = false;

  } else {
    if (departmentText !== currentDepartmentFilter) show = false;
  }
}


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ filtros adicionais (multi-select) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function applyCodeMultiFilters() {
  // selectedCodeFilters vem do bloco 2.1 (do mesmo filterTable)
  const set = (typeof selectedCodeFilters !== 'undefined' && selectedCodeFilters instanceof Set)
    ? selectedCodeFilters
    : new Set();

  // 1) Role: Manager / Operative
  const wantsManager   = set.has('manager');
  const wantsOperative = set.has('operative');

  // se marcou s√≥ 1, filtra; se marcou os 2, n√£o filtra (equivale a "All roles")
  if (wantsManager && !wantsOperative && roleText !== 'Manager') show = false;
  if (wantsOperative && !wantsManager && roleText !== 'Operative') show = false;

  // 2) Missing Task
  if (set.has('missingTask') && !taskText.endsWith('Missing Task-0000')) show = false;

  // 3) Full Time / Part Time (s√≥ CORE)
  (function applyFTPTFilter() {
    // detecta FT/PT vindo do multi-set (e fallback no dropdown)
    const lowerSet = Array.from(set).map(v => String(v || '').toLowerCase().trim());

    const cfValue = String(codeFilter || '').toLowerCase().trim();
    const cfText  = String(
      codeFilterEl?.options?.[codeFilterEl.selectedIndex]?.textContent || ''
    ).toLowerCase().trim();

    const isFullTimeMode =
      lowerSet.includes('fulltime') ||
      lowerSet.includes('full-time') ||
      lowerSet.includes('ft') ||
      cfValue === 'fulltime' ||
      cfValue === 'full-time' ||
      cfValue === 'ft' ||
      cfText.includes('full time') ||
      cfText.includes('full-time');

    const isPartTimeMode =
      lowerSet.includes('parttime') ||
      lowerSet.includes('part-time') ||
      lowerSet.includes('pt') ||
      cfValue === 'parttime' ||
      cfValue === 'part-time' ||
      cfValue === 'pt' ||
      cfText.includes('part time') ||
      cfText.includes('part-time');

    // ‚úÖ se marcou os dois ‚Üí n√£o filtra FT/PT
    if (isFullTimeMode && isPartTimeMode) return;

    const isFTPTMode = isFullTimeMode || isPartTimeMode;
    if (!isFTPTMode) return;

    // ‚úÖ FT/PT s√≥ faz sentido para CORE (AGY fora)
    const isCoreRow = String(typeText || '').toLowerCase().includes('core');
    if (!isCoreRow) {
      show = false;
      return;
    }

    // ‚úÖ 1) Fonte principal: Worker Type vindo da tabela (Employee Master)
    const workerTypeFromTable = String(cells[COL.workerType]?.textContent || '').trim();
    const workerTypeKeyFromTable = workerTypeFromTable
      .toLowerCase()
      .replace(/[\s\-_]+/g, ''); // "fulltime" / "parttime"

    if (workerTypeKeyFromTable) {
      if (isFullTimeMode && workerTypeKeyFromTable !== 'fulltime') show = false;
      if (isPartTimeMode && workerTypeKeyFromTable !== 'parttime') show = false;
      return;
    }

    // ‚úÖ 2) Fallback (opcional): ContractInfo (se existir)
    const map = window.contractInfoMap;
    const masterLoaded = !!(map && typeof map.size === 'number' && map.size > 0);

    if (!masterLoaded) {
      show = false;
      return;
    }

    const empId = (typeof normalizeId === 'function')
      ? normalizeId(personNumber)
      : String(personNumber || '').replace(/\D/g, '').trim();

    const rec = empId ? map.get(empId) : null;
    const workerTypeRaw = String(rec?.workerType || '').trim();

    const workerTypeKey = workerTypeRaw
      .toLowerCase()
      .replace(/[\s\-_]+/g, '');

    if (!workerTypeKey) {
      show = false;
      return;
    }

    if (isFullTimeMode && workerTypeKey !== 'fulltime') show = false;
    if (isPartTimeMode && workerTypeKey !== 'parttime') show = false;
  })();
})();

if (dateFilter) {
  const [d, m, y] = dateText.split('/');
  const isoDate    = `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
  if (isoDate !== dateFilter) show = false;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ filtro espec√≠fico OT > 40h (Week) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (isOt40WeekMode) {
  const key = (typeof window.getOtBucketKey === 'function')
    ? window.getOtBucketKey({
        personNumber,
        week: weekText,
        type: (cells[COL.type]?.textContent || '')
      })
    : `${personNumber}|${weekText}`;

  const otMap = (window.bucketOTByKey && typeof window.bucketOTByKey.get === 'function')
    ? window.bucketOTByKey
    : weeklyOTByKeyWeek;

  const otForKey = otMap.get(key) || 0;

  if (!(otForKey > 0)) show = false;
}

// mostra / esconde a linha
row.style.display = show ? '' : 'none';


    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ acumula totais ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (show && hoursText && hoursText !== 'N/A') {
  const [h = 0, m = 0, s = 0] = hoursText.split(':').map(Number);
  const secsRow  = h * 3600 + m * 60 + s;

  // ‚úÖ SEMPRE conta a linha inteira (mesmo no modo OT > 40h)
  grossSeconds += secsRow;

  if (taskTextLC !== 'n/a') {
    loggedSeconds += secsRow;

    if (secsRow > 0) {
      filteredData.push({
        department         : departmentText.toLowerCase(),
        totalHoursFormatted: formatTime(secsRow)
      });
    }
  }
}
});

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ KPI‚Äôs na parte de cima ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  document.getElementById('grossHours').textContent  = formatTime(grossSeconds);
  document.getElementById('loggedHours').textContent = formatTime(loggedSeconds);

  const diffSec   = grossSeconds - loggedSeconds;
  const absDiff   = Math.abs(diffSec);
  const unloggedEl = document.getElementById('depTotalHours');
  unloggedEl.textContent =
    (diffSec === 0 ? '' : diffSec > 0 ? '+' : '-') + formatTime(absDiff);
  unloggedEl.style.color = diffSec === 0 ? 'green' : 'red';

         // ======================= CACHE VIS√çVEL =======================
window.filteredRowsCache = [];
rows.forEach(row => {
  if (row.style.display !== 'none') {
    const cells = row.getElementsByTagName('td');

    // ‚úÖ FAIL-SAFE: no modo OT > 40h (Week), n√£o guardar linhas Break
if (isOt40WeekMode) {
  const depText      = String(cells[COL.department]?.textContent || '').trim(); // Dep.
  const labourDigits = String(cells[COL.labour]?.textContent || '').replace(/\D/g, '');
  const taskLC2      = String(cells[COL.task]?.textContent || '').toLowerCase();

  const isBreakRow =
    depText === 'Break' ||
    labourDigits.endsWith('4010') ||
    /-4010\b/.test(taskLC2) ||
    taskLC2.includes('paid break');

  if (isBreakRow) return; // üëà ignora esta linha no cache
}

    // ‚úÖ SEMPRE guarda as horas reais da c√©lula
    const totalHoursText = (cells[COL.totalHours].textContent || '').trim();

window.filteredRowsCache.push({
  // === colunas da tabela (completas) ===
  employee    : cells[COL.employee].textContent.trim(),
  type        : cells[COL.type].textContent.trim(),
  personNumber: cells[COL.person].textContent.trim(),

  workerType  : cells[COL.workerType].textContent.trim(),
  supervisor  : cells[COL.supervisor].textContent.trim(),

  role        : cells[COL.role].textContent.trim(),
  date        : cells[COL.date].textContent.trim(),
  week        : cells[COL.week].textContent.trim(),
  month       : cells[COL.month].textContent.trim(),

  labourAccount: cells[COL.labour].textContent.trim(),
  department  : cells[COL.department].textContent.trim(),
  task        : cells[COL.task].textContent.trim(),

  hoursDec    : cells[COL.hoursDec].textContent.trim(),
  totalHours  : totalHoursText,

  payCode     : cells[COL.payCode].textContent.trim(),

  // === compatibilidade (mant√©m nomes antigos usados noutros s√≠tios) ===
  totalHoursFormatted: totalHoursText
});

  }
});

// =======================
// HEADCOUNT TOTAL CACHE
// Total = aplica filtros, mas ignora Employee,
// e respeita o modo OT>40 se estiver ativo.
// =======================
(function buildHeadcountTotalCache() {
  const totalPeople = new Set();

  rows.forEach(row => {
    const cells = row.getElementsByTagName('td');
    if (!cells.length) return;

    // aplica filtros atuais, mas ignora Employee
    if (!passesFiltersExcludingOT(cells, true)) return;

    // se estiver em OT>40 (Week), aplica a mesma regra do show
if (isOt40WeekMode) {
  const depText      = String(cells[COL.department]?.textContent || '').trim(); // Dep.
  const labourDigits = String(cells[COL.labour]?.textContent || '').replace(/\D/g, '');
  const taskLC2      = String(cells[COL.task]?.textContent || '').toLowerCase();

  const isBreakRow =
    depText === 'Break' ||
    labourDigits.endsWith('4010') ||
    /-4010\b/.test(taskLC2) ||
    taskLC2.includes('paid break');

  if (isBreakRow) return;

  const personNumber = (cells[COL.person]?.textContent || '').trim();
  const weekText     = (cells[COL.week]?.textContent || '').trim();
  const key          = `${personNumber}|${weekText}`;

  const otForWeek = weeklyOTByKeyWeek.get(key) || 0;
  if (!(otForWeek > 0)) return;
}

const personNumber = (cells[COL.person]?.textContent || '').trim();
if (personNumber) totalPeople.add(personNumber);

  });

  window.headcountTotalCache = totalPeople.size;
})();

   // ==========================================================
// üîπ actualiza o KPI de Over Time com base nos dados actualmente vis√≠veis
updateOvertimeLabel();

// ‚úÖ OT People dropdown (se existir). Se removeste do HTML, isto N√ÉO quebra nada.
if (document.getElementById('otPeopleFilter') && typeof populateOTPeopleDropdown === 'function') {
  populateOTPeopleDropdown();
}

updateFilteredTotals(filteredData);
updateHeadcount();
updateMissingTaskCount();
updateMissingTaskHours();

// ‚úÖ NOVO: se estiver na aba Budget Tracker, re-renderiza o overview com os filtros atuais
if (document.getElementById('budgetTracker')?.classList.contains('active')) {
  displayBudgetOverview();
}

if (document.getElementById('dashboard').classList.contains('active')) {
  renderDashboard();
}
}
window.addEventListener('agyOtModeChanged', () => {
  try {
    if (typeof window.filterTable === 'function') window.filterTable();
  } catch (e) {}
}, { passive: true });
// ======================= NOVO BLOCO (helper) =======================
// Retorna as linhas actualmente vis√≠veis (se houver filtros activos);
// caso contr√°rio devolve o array completo `storedData`.  Usado pelo
// Dashboard para que os KPI e gr√°ficos reflitam exactamente o que o
// utilizador est√° a ver na aba Home.
function getFilteredData() {
  return Array.isArray(window.filteredRowsCache)
    ? window.filteredRowsCache
    : (storedData || []);
}
// ==================================================================

// ‚òÖ KPI de Over Time (total + %)
// Agora:
// - CORE  ‚Üí OT di√°ria (acima de 8h/dia)
// - AGY   ‚Üí OT semanal (acima de 40h/semana)
// - respeita os filtros activos (Employee, Type, Task, Dept, Week, Month, Date, etc.)
// ‚òÖ NOVO: fun√ß√£o √∫nica de c√°lculo de Over Time (CORE vs Ag√™ncia)
// Agora alinhada com o download Excel:
// - CORE  ‚Üí OT di√°ria > 8h/dia (soma excesso de cada dia)
// - AGY   ‚Üí OT semanal > 40h/semana
// =========================
// OT People Dropdown (AGY weekly > 40h)
// =========================
function getOTPeopleWeeklyOver40(baseSource, allEntries) {
  allEntries  = allEntries  || storedData || [];
  baseSource  = baseSource  || [];

  // chaves permitidas person|week vindas dos filtros atuais (exceto o pr√≥prio dropdown)
  const allowedKeys = new Set();

  baseSource.forEach(e => {
    const person = e.personNumber;
    const week   = e.week;
    if (!person || !week) return;
    allowedKeys.add(`${person}|${week}`);
  });

  // soma total por person|week, mas s√≥ para as keys permitidas
  const weeklyTotals = {};    // key person|week -> totalSec
  const nameByPerson = {};    // person -> employee (1¬∫ que aparecer)
  const typeByKey    = {};    // key person|week -> type (core/247/extra/etc)

  allEntries.forEach(e => {
    const person = e.personNumber;
    const week   = e.week;
    if (!person || !week) return;

    const key = `${person}|${week}`;
    if (!allowedKeys.has(key)) return;

    if (!nameByPerson[person]) nameByPerson[person] = e.employee || person;

        if (!typeByKey[key] && typeof getEmployeeType === 'function') {
      typeByKey[key] = String(getEmployeeType(e) || '').toLowerCase();
    }

    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h=0,m=0,s=0] = String(time).split(':').map(Number);
    const sec = h*3600 + m*60 + s;

    weeklyTotals[key] = (weeklyTotals[key] || 0) + sec;
  });

  // calcula OT semanal > 40h apenas para AGY/247/Extra (n√£o CORE)
  const otByPerson = {}; // person -> otSec

  Object.entries(weeklyTotals).forEach(([key, totalSec]) => {
    const typeLC = (typeByKey[key] || '').toLowerCase();

    const isAgency =
      typeLC.includes('agy') ||
      typeLC.includes('247') ||
      typeLC.includes('extr'); // Extra

    if (!isAgency) return;

    const otSec = Math.max(0, totalSec - 40 * 3600);
    if (otSec <= 0) return;

    const person = key.split('|')[0];
    otByPerson[person] = (otByPerson[person] || 0) + otSec;
  });

  // devolve lista ordenada
  return Object.entries(otByPerson)
    .map(([personNumber, otSec]) => ({
      personNumber,
      employee: nameByPerson[personNumber] || personNumber,
      otSec
    }))
    .sort((a,b) => b.otSec - a.otSec);
}

function populateOTPeopleDropdown() {
  const sel = document.getElementById('otPeopleFilter');
  if (!sel) return;

  // baseSource = linhas "vis√≠veis pelos filtros atuais" (sem aplicar o filtro deste dropdown)
  // vamos montar um "baseSource" a partir do storedData aplicando Week/Month/Date/Dept/Task/Labour/PayCode/Type, etc.
  // mas IGNORANDO employeeFilter e IGNORANDO o pr√≥prio otPeopleFilter.
  const weekFilter   = document.getElementById('selectWeek')?.value || '';
  const monthFilter  = document.getElementById('selectMonth')?.value || '';
  const dateFilter   = document.getElementById('dateFilter')?.value || '';
  const taskFilterRaw = (document.getElementById('taskFilter')?.value || '').toLowerCase().trim();
  const taskFilters = taskFilterRaw ? taskFilterRaw.split(/[,;]+/).map(s=>s.trim()).filter(Boolean) : [];
  const labourFilter = (document.getElementById('labourAccountFilter')?.value || '').toLowerCase();
  const typeFilter   = (document.getElementById('typeFilter')?.value || '').toLowerCase();
  const payCodeFilter1 = (document.getElementById('payCodeFilter')?.value || '').toLowerCase();
  const payCodeSet   = (window.selectedPayCodes && window.selectedPayCodes.size > 0) ? window.selectedPayCodes : null;

  const hasTask = taskFilters.length > 0;

  const baseSource = (storedData || []).filter(e => {
    // Week
    if (weekFilter && String(e.week) !== String(weekFilter)) return false;

    // Month
    if (monthFilter && String(e.month) !== String(monthFilter)) return false;

    // Date (dateFilter est√° em ISO yyyy-mm-dd)
    if (dateFilter) {
      const [d,m,y] = String(e.date || '').split('/');
      const iso = `${y}-${String(m||'').padStart(2,'0')}-${String(d||'').padStart(2,'0')}`;
      if (iso !== dateFilter) return false;
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ filtro por departamento (BASEADO EM storedData "e") ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (currentDepartmentFilter && currentDepartmentFilter !== 'All') {
  if (currentDepartmentFilter === 'Break') {
    const depText      = String(e.department || '').trim();
    const labourDigits = String(e.labourAccount || '').replace(/\D/g, '');
    const taskLC2      = String(e.task || '').toLowerCase();

    const isBreakRow =
      depText === 'Break' ||
      labourDigits.endsWith('4010') ||
      /-4010\b/.test(taskLC2) ||
      taskLC2.includes('paid break');

    if (!isBreakRow) return false;  // üëà aqui √© FILTER, ent√£o √© return false
  } else {
    if (String(e.department || '') !== String(currentDepartmentFilter)) return false;
  }
}



    // Labour Account
    if (labourFilter && !String(e.labourAccount || '').toLowerCase().includes(labourFilter)) return false;

    // Task (multi)
    if (hasTask) {
      const t = String(e.task || '').toLowerCase();
      if (!taskFilters.some(f => t.includes(f))) return false;
    }

    // Type (CORE/247/Extra...)
        if (typeFilter) {
      const t = (typeof getEmployeeType === 'function')
        ? String(getEmployeeType(e) || '').toLowerCase()
        : '';
      if (!t.includes(typeFilter)) return false;
    }

    // Pay Code (dropdown simples)
    if (payCodeFilter1) {
      if (String(e.payCode || '').toLowerCase() !== payCodeFilter1) return false;
    }

    // Pay Code (multi)
    if (payCodeSet) {
      const pc = String(e.payCode || '').toLowerCase();
      if (!payCodeSet.has(pc)) return false;
    }

    return true;
  });

  const list = getOTPeopleWeeklyOver40(baseSource, storedData);

  // preserva sele√ß√£o atual se poss√≠vel
  const prev = sel.value || '';
  sel.innerHTML = '<option value="">All</option>';

  list.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.personNumber;
    opt.textContent = `${p.employee} (${p.personNumber}) ‚Äî OT: ${formatTime(p.otSec)}`;
    sel.appendChild(opt);
  });

  // restaura se ainda existir
  const stillExists = Array.from(sel.options).some(o => o.value === prev);
  sel.value = stillExists ? prev : '';
}

function computeOvertimeFromEntries(baseSource, allEntries) {
  // baseSource = dados filtrados (ex.: linhas vis√≠veis ou intervalo de datas)
  allEntries = allEntries || storedData || [];
  baseSource = baseSource || [];

  // 1) chaves pessoa|semana que est√£o dentro dos filtros
  const allowedKeys = new Set();   // "personNumber|week"
  const typeByKey   = {};          // "person|week" -> tipo ("core", "247", "extra")

  baseSource.forEach(e => {
    const person = e.personNumber;
    const week   = e.week;
    if (!person || !week) return;

    const key = `${person}|${week}`;
    allowedKeys.add(key);

    // guarda o TYPE (CORE, 247, Extra, etc.) se a fun√ß√£o estiver dispon√≠vel
    if (!typeByKey[key] && typeof getEmployeeType === 'function') {
      const type = getEmployeeType(e.employee || '');
      typeByKey[key] = (type || '').toLowerCase();
    }
  });

  // 2) soma das horas:
//    - por semana (CORE + AGY: 40h/sem)
const weeklyTotals = {};   // person|week -> totalSegundosNaSemana

allEntries.forEach(e => {
  const person = e.personNumber;
  const week   = e.week;
  const date   = e.date;              // mant√©m se for usado noutros s√≠tios
  if (!person || !week || !date) return;

  const key = `${person}|${week}`;
  if (!allowedKeys.has(key)) return;  // s√≥ semanas/pessoas dentro do filtro

  const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
  if (!time || time === 'N/A') return;

  const [h = 0, m = 0, s = 0] = time.split(':').map(Number);
  const sec = h * 3600 + m * 60 + s;

  // ‚úÖ total da semana (para TODOS)
  weeklyTotals[key] = (weeklyTotals[key] || 0) + sec;
});


  // 3) Aplica regras de OT
  let overtimeTotalSec = 0;
  let baseTotalSec     = 0;

  // 3.1) Base de horas = total de horas trabalhadas (CORE + AGY)
  Object.values(weeklyTotals).forEach(totalSec => {
    baseTotalSec += totalSec;
  });

  Object.entries(weeklyTotals).forEach(([key, totalWeekSec]) => {
  const [person] = key.split('|');
  const typeLC   = String(typeByKey[key] || '').toLowerCase();
  const empName  = String((nameByPerson && nameByPerson[person]) || '');

  const thresholdSec = getWeeklyThresholdSecForRow(person, empName, typeLC);
  overtimeTotalSec += Math.max(0, totalWeekSec - thresholdSec);
});

return { overtimeTotalSec, baseTotalSec };

}


// ‚òÖ NOVO ‚Äì calcula "Over Spending" s√≥ para Break:
//    - baseSource = dados filtrados (normalmente s√≥ Break quando est√°s no slicer Break)
function computeBreakOverspendingFromEntries(baseSource) {
  baseSource = baseSource || [];
  
  let totalBreakSec = 0;
  const perPersonDay = {};   // chave: person|date -> segundos de break no dia

  baseSource.forEach(e => {
    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h = 0, m = 0, s = 0] = time.split(':').map(Number);
    const sec = h * 3600 + m * 60 + s;
    totalBreakSec += sec;

    const person = e.personNumber || e.employee || '';
    const date   = e.date || '';
    if (!person || !date) return;

    const key = `${person}|${date}`;
    perPersonDay[key] = (perPersonDay[key] || 0) + sec;
  });

  // allowance: 33 minutos de break por dia
  const dailyAllowanceSec = 33 * 60;
  let overspendSec = 0;

  Object.values(perPersonDay).forEach(totalDaySec => {
    if (totalDaySec > dailyAllowanceSec) {
      overspendSec += (totalDaySec - dailyAllowanceSec);
    }
  });

  return { overspendSec, totalBreakSec };
}
// ‚òÖ NOVO ‚Äì Over Time por Task / linha, usando Pay Code "Over..." como overtime
function computeTaskOvertimeFromEntries(baseSource) {
  baseSource = baseSource || [];

  let totalSec    = 0; // todas as horas do task (vis√≠veis)
  let overtimeSec = 0; // s√≥ linhas com Pay Code de overtime

  baseSource.forEach(e => {
    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h = 0, m = 0, s = 0] = time.split(':').map(Number);
    const sec = h * 3600 + m * 60 + s;
    totalSec += sec;

    const payCode = (e.payCode || '').toLowerCase();
    // aqui assumimos que os pay codes de OT t√™m "over" no nome
    if (payCode.includes('over')) {
      overtimeSec += sec;
    }
  });

  return { totalSec, overtimeSec };
}
// ‚òÖ NOVO ‚Äì devolve linhas de Over Spending por pessoa/dia (Break)
function getBreakOverspendingRows(baseSource) {
  baseSource = baseSource || [];

  const perPersonDay = {}; // key: person|date -> { person, date, totalSec }

  baseSource.forEach(e => {
    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h = 0, m = 0, s = 0] = time.split(':').map(Number);
    const sec = h * 3600 + m * 60 + s;

    const person = e.personNumber || e.employee || '';
    const date   = e.date || '';
    if (!person || !date) return;

    const key = `${person}|${date}`;
    if (!perPersonDay[key]) {
      perPersonDay[key] = { person, date, totalSec: 0 };
    }
    perPersonDay[key].totalSec += sec;
  });

  const dailyAllowanceSec = 33 * 60; // 33 min

  const rows = [];
  Object.values(perPersonDay).forEach(obj => {
    const overspendSec = Math.max(0, obj.totalSec - dailyAllowanceSec);
    if (overspendSec <= 0) return; // s√≥ queremos quem passou dos 33 min
    rows.push({
      person        : obj.person,
      date          : obj.date,
      totalBreakSec : obj.totalSec,
      overspendSec
    });
  });

  return rows;
}
// ‚úÖ OT semanal correto: soma por Employee|Week e aplica max(0, total-40h)
function computeWeeklyOTFromEntries(entries) {
  const perEmpWeek = new Map();

  // ‚úÖ NOVO: guarda quem tem OT (>40h) na(s) semana(s) presentes
  const eligibleEmployees = new Set();

  let baseTotalSec = 0;

  const toSec = (e) => {
    // 1) se tiver decimal (mais fi√°vel)
    const dec =
      (typeof e.hoursDec === 'number' ? e.hoursDec : null) ??
      (typeof e.hoursDecimal === 'number' ? e.hoursDecimal : null) ??
      (typeof e.totalHoursDec === 'number' ? e.totalHoursDec : null) ??
      (typeof e.totalHoursDecimal === 'number' ? e.totalHoursDecimal : null);

    if (dec != null && Number.isFinite(dec)) return Math.round(dec * 3600);

    // 2) fallback: HH:MM:SS
    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return 0;
    const [h = 0, m = 0, s = 0] = String(time).split(':').map(Number);
    return (h * 3600) + (m * 60) + s;
  };

  // helper: normaliza chave do empregado (para bater certinho com filtros)
  const normEmp = (e) =>
    String(e.employee || e.Employee || e.name || '').trim().toLowerCase();

  entries.forEach(e => {
    const emp = normEmp(e);
    const wk  = String(e.week || e.Week || '').trim();

    if (!emp || !wk) return;

    const sec = toSec(e);
    baseTotalSec += sec;

    const key = `${emp}|${wk}`;
    perEmpWeek.set(key, (perEmpWeek.get(key) || 0) + sec);
  });

  let overtimeTotalSec = 0;

perEmpWeek.forEach((sumSec, key) => {
  // key = "emp|week" (emp j√° normalizado)
  const empOnly = key.split('|')[0];

  // tenta achar um personNumber para aplicar o threshold real
  // (se n√£o tiveres personNumber nesta fun√ß√£o, isto fica limitado ‚Äî mas na tua app normalmente tens)
  const sample = entries.find(x => String((x.employee||'')).trim().toLowerCase() === empOnly);
  const person = String(sample?.personNumber || '').trim();

  let thresholdSec = 40 * 3600; // fallback seguro
    if (person) {
    const typeLC  = String(getEmployeeType(sample) || '').toLowerCase();
    const empName = String(sample?.employee || '');
    thresholdSec = getWeeklyThresholdSecForRow(person, empName, typeLC);
  }


  const ot = Math.max(0, sumSec - thresholdSec);
  overtimeTotalSec += ot;

  if (ot > 0) eligibleEmployees.add(empOnly);
});


  return { eligibleEmployees, overtimeTotalSec, baseTotalSec };
}
function isElementVisible(el) {
  if (!el) return false;
  const st = window.getComputedStyle(el);
  if (st.display === 'none' || st.visibility === 'hidden') return false;
  return el.offsetParent !== null || st.position === 'fixed';
}
// =======================
// CODE FILTER MULTI-SELECT (legacy-safe)
// - Mant√©m o dropdown #codeFilter
// - Adiciona um painel multi-select estilo PayCode
// - Guarda sele√ß√£o em window.selectedCodeFilters (Set)
// =======================
(function initCodeFilterMultiSelect() {
  function normalizeVal(v) {
    return String(v || '').trim();
  }

  function ensureSet() {
    if (!window.selectedCodeFilters || !(window.selectedCodeFilters instanceof Set)) {
      window.selectedCodeFilters = new Set();
    }
    return window.selectedCodeFilters;
  }

  function buildUI() {
  const sel = document.getElementById('codeFilter');
  if (!sel) return;

  // ‚úÖ mant√©m no DOM para compatibilidade, mas esconde (vamos usar o multi-select)
  sel.style.display = 'none';

  // evita duplicar UI
  if (document.getElementById('codeMultiSelectWrap')) return;

  const wrap = document.createElement('div');

    wrap.id = 'codeMultiSelectWrap';
    wrap.style.display = 'inline-block';
    wrap.style.position = 'relative';
    wrap.style.marginLeft = '8px';
    wrap.style.verticalAlign = 'middle';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.id = 'codeMultiSelectBtn';
btn.textContent = 'All ‚ñæ';
btn.style.padding = '6px 12px';
btn.style.border = '1px solid #ccc';
btn.style.borderRadius = '6px';
btn.style.background = '#fff';
btn.style.cursor = 'pointer';
btn.style.fontWeight = 'bold';
btn.style.display = 'inline-flex';
btn.style.alignItems = 'center';
btn.style.gap = '8px';


    const panel = document.createElement('div');
    panel.id = 'codeMultiSelectPanel';
    panel.style.position = 'absolute';
    panel.style.top = '110%';
    panel.style.right = '0';
    panel.style.minWidth = '210px';
    panel.style.maxHeight = '300px';
    panel.style.overflow = 'auto';
    panel.style.background = '#fff';
    panel.style.border = '1px solid #ccc';
    panel.style.borderRadius = '10px';
    panel.style.boxShadow = '0 10px 30px rgba(0,0,0,0.15)';
    panel.style.padding = '10px';
    panel.style.zIndex = '9999';
    panel.style.display = 'none';

    const title = document.createElement('div');
    title.textContent = 'Code Filter (Multi)';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '8px';

    const list = document.createElement('div');
    list.id = 'codeMultiSelectList';

    const actions = document.createElement('div');
    actions.style.display = 'flex';
    actions.style.gap = '8px';
    actions.style.marginTop = '10px';

    const btnApply = document.createElement('button');
btnApply.type = 'button';
btnApply.textContent = 'OK';
btnApply.style.flex = '1';
btnApply.style.border = '1px solid #2e7d32';
btnApply.style.borderRadius = '8px';
btnApply.style.background = '#fff';
btnApply.style.cursor = 'pointer';
btnApply.style.fontWeight = 'bold';

const btnCancel = document.createElement('button');
btnCancel.type = 'button';
btnCancel.textContent = 'Cancel';
btnCancel.style.flex = '1';
btnCancel.style.border = '1px solid #c1121f';
btnCancel.style.borderRadius = '8px';
btnCancel.style.background = '#fff';
btnCancel.style.cursor = 'pointer';
btnCancel.style.fontWeight = 'bold';

const btnClear = document.createElement('button');
btnClear.type = 'button';
btnClear.textContent = 'Clear';
btnClear.style.flex = '1';
btnClear.style.border = '1px solid #004d99';
btnClear.style.borderRadius = '8px';
btnClear.style.background = '#fff';
btnClear.style.cursor = 'pointer';
btnClear.style.fontWeight = 'bold';

// ‚úÖ NOVO: deixa os bot√µes menores (altura e padding)
function styleMiniActionBtn(b) {
  b.style.padding = '2px 8px';
  b.style.fontSize = '0.72rem';
  b.style.lineHeight = '1';
  b.style.height = '24px';
  b.style.minWidth = 'unset';
  b.style.whiteSpace = 'nowrap';
}

styleMiniActionBtn(btnApply);
styleMiniActionBtn(btnCancel);
styleMiniActionBtn(btnClear);


    actions.appendChild(btnApply);
    actions.appendChild(btnCancel);
    actions.appendChild(btnClear);

    panel.appendChild(title);
    panel.appendChild(list);
    panel.appendChild(actions);

    wrap.appendChild(btn);
    wrap.appendChild(panel);

    // insere ao lado do dropdown
    sel.insertAdjacentElement('afterend', wrap);

    // cria checkboxes baseado nas options do select
    function rebuildCheckboxes() {
      list.innerHTML = '';

      Array.from(sel.options || []).forEach(opt => {
        const val = normalizeVal(opt.value);
        const txt = normalizeVal(opt.textContent);

        // ignora All (value vazio)
        if (!val) return;

        const row = document.createElement('label');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        row.style.padding = '6px 4px';
        row.style.cursor = 'pointer';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = val;

        const span = document.createElement('span');
        span.textContent = txt;

        row.appendChild(cb);
        row.appendChild(span);
        list.appendChild(row);
      });
    }

    function setCheckboxesFromSet(set) {
      const allCbs = list.querySelectorAll('input[type="checkbox"]');
      allCbs.forEach(cb => {
        cb.checked = set.has(cb.value);
      });
    }

    function readSetFromCheckboxes() {
      const set = new Set();
      const allCbs = list.querySelectorAll('input[type="checkbox"]');
      allCbs.forEach(cb => {
        if (cb.checked) set.add(cb.value);
      });
      return set;
    }

    function updateButtonLabel() {
  const set = ensureSet();
  if (!set.size) {
    btn.textContent = 'All ‚ñæ';
    return;
  }

  const labels = [];
  const optMap = new Map();
  Array.from(sel.options || []).forEach(o => optMap.set(normalizeVal(o.value), normalizeVal(o.textContent)));

  Array.from(set).forEach(v => {
    labels.push(optMap.get(v) || v);
  });

  const label =
    labels.length <= 2
      ? labels.join(' + ')
      : `${labels.slice(0, 2).join(' + ')} +${labels.length - 2}`;

  btn.textContent = `${label} ‚ñæ`;
}


    // estado para Cancel
    let snapshot = new Set();

    function openPanel() {
      snapshot = new Set(ensureSet());
      setCheckboxesFromSet(snapshot);
      panel.style.display = 'block';
    }

    function closePanel() {
      panel.style.display = 'none';
    }

    // click no bot√£o abre/fecha
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (panel.style.display === 'none') openPanel();
      else closePanel();
    });

    // OK aplica set e chama filtro
    btnApply.addEventListener('click', (e) => {
      e.stopPropagation();
      const newSet = readSetFromCheckboxes();

      window.selectedCodeFilters = newSet;

      // sincroniza dropdown (compatibilidade)
      if (newSet.size === 1) {
        const only = Array.from(newSet)[0];
        sel.value = only;
      } else {
        sel.value = ''; // All
      }

      updateButtonLabel();
      closePanel();

      if (typeof filterTable === 'function') filterTable();
    });

    // Cancel restaura snapshot
    btnCancel.addEventListener('click', (e) => {
      e.stopPropagation();
      window.selectedCodeFilters = new Set(snapshot);

      if (snapshot.size === 1) {
        sel.value = Array.from(snapshot)[0];
      } else {
        sel.value = '';
      }

      updateButtonLabel();
      closePanel();

      if (typeof filterTable === 'function') filterTable();
    });

    // Clear limpa tudo
    btnClear.addEventListener('click', (e) => {
      e.stopPropagation();
      window.selectedCodeFilters = new Set();
      sel.value = '';

      setCheckboxesFromSet(window.selectedCodeFilters);
      updateButtonLabel();

      if (typeof filterTable === 'function') filterTable();
    });

    // fechar ao clicar fora
    document.addEventListener('click', () => closePanel());

    // n√£o fechar quando clica dentro
    panel.addEventListener('click', (e) => e.stopPropagation());

    // ‚úÖ importante: quando o dropdown mudar (legacy), atualiza o Set ANTES do filterTable (capture)
    sel.addEventListener('change', () => {
      const set = ensureSet();
      set.clear();

      const v = normalizeVal(sel.value);
      if (v) set.add(v);

      updateButtonLabel();
    }, true);

    // init
    ensureSet();
    rebuildCheckboxes();
    updateButtonLabel();
  }

  // init quando DOM estiver pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', buildUI);
  } else {
    buildUI();
  }
})();


function updateOvertimeLabel() {
  // 0) Se n√£o houver dados, mostra 0 e sai
  if (!storedData || !storedData.length) {
    let overtimeEl =
      document.getElementById('overtimeLabel') ||
      document.querySelector('[data-kpi="overtime"]');

    if (!overtimeEl) {
      overtimeEl = Array.from(
        document.querySelectorAll('span,div,p,strong,td,th')
      ).find(el => {
  const t = (el.textContent || '').trim();
  return t.startsWith('Over Time:') || t.startsWith('Over Spending:');
});

    }

    if (overtimeEl) {
      overtimeEl.innerHTML =
        'Over Time: ' +
        '<span style="font-weight:bold; color:#c1121f;">0:00:00</span>' +
        '<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:#004d99;">Total W/h: 0:00:00</span>' +
        '<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:#2e7d32;">0.00%</span>';
    }
    return;
  }

  // 1) Fonte base ‚Üí linhas actualmente vis√≠veis (Home + Dept + Week + Month + Date, etc.)
  const baseSource = Array.isArray(window.filteredRowsCache)
  ? window.filteredRowsCache
  : (storedData || []);

  if (!baseSource.length) {
    let overtimeEl =
      document.getElementById('overtimeLabel') ||
      document.querySelector('[data-kpi="overtime"]');

    if (!overtimeEl) {
      overtimeEl = Array.from(
        document.querySelectorAll('span,div,p,strong,td,th')
      ).find(el => {
  const t = (el.textContent || '').trim();
  return t.startsWith('Over Time:') || t.startsWith('Over Spending:');
});

    }

    if (overtimeEl) {
      overtimeEl.innerHTML =
        'Over Time: ' +
        '<span style="font-weight:bold; color:#c1121f;">0:00:00</span>' +
        '<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:#004d99;">Total W/h: 0:00:00</span>' +
        '<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:#2e7d32;">0.00%</span>';
    }
    return;
  }

  // 1.1) Encontra o elemento da label (vamos reutilizar nos dois modos)
    let overtimeEl =
    document.getElementById('overtimeLabel') ||
    document.querySelector('[data-kpi="overtime"]');

  // ‚úÖ se o id existir mas estiver escondido, ignora e procura o vis√≠vel
  if (overtimeEl && !isElementVisible(overtimeEl)) overtimeEl = null;

  if (!overtimeEl) {
    const nodes = Array.from(document.querySelectorAll('span,div,p,strong,td,th'));

    // prioridade 1: vis√≠vel e come√ßa por Over Time
    overtimeEl = nodes.find(el => isElementVisible(el) && (el.textContent || '').trim().startsWith('Over Time:'));

    // prioridade 2: vis√≠vel e come√ßa por Over Spending
    if (!overtimeEl) {
      overtimeEl = nodes.find(el => isElementVisible(el) && (el.textContent || '').trim().startsWith('Over Spending:'));
    }

    // fallback: qualquer um (mesmo se escondido)
    if (!overtimeEl) {
      overtimeEl = nodes.find(el => {
        const t = (el.textContent || '').trim();
        return t.startsWith('Over Time:') || t.startsWith('Over Spending:');
      });
    }
  }

  if (!overtimeEl) return;


  // =========================
// MODO BREAK = OVER SPENDING
// =========================
const depNow =
  (typeof window.currentDepartmentFilter !== 'undefined' && window.currentDepartmentFilter !== null)
    ? window.currentDepartmentFilter
    : currentDepartmentFilter;

if (depNow === 'Break') {
  const { overspendSec, totalBreakSec } =
    computeBreakOverspendingFromEntries(baseSource);

  // ‚úÖ extra informativo: overspending se a regra fosse >30m (sem mexer na l√≥gica oficial >33m)
  let overspend30Sec = 0;
  const perPersonDay = {}; // person|date -> total break sec no dia

  baseSource.forEach(e => {
    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h = 0, m = 0, s = 0] = String(time).split(':').map(Number);
    const sec = h * 3600 + m * 60 + s;

    const person = e.personNumber || e.employee || '';
    const date   = e.date || '';
    if (!person || !date) return;

    const key = `${person}|${date}`;
    perPersonDay[key] = (perPersonDay[key] || 0) + sec;
  });

  Object.values(perPersonDay).forEach(totalDaySec => {
    if (totalDaySec > 30 * 60) {
      overspend30Sec += (totalDaySec - 30 * 60);
    }
  });

  const overspend33Text = formatTime(overspendSec);     // oficial (>33)
  const overspend30Text = formatTime(overspend30Sec);   // informativo (>30)
  const totalBreakText  = formatTime(totalBreakSec);

  const percent = totalBreakSec > 0
    ? (overspendSec / totalBreakSec) * 100   // ‚úÖ percent continua oficial (>33)
    : 0;

  const percentColor = percent > 5 ? '#c1121f' : '#2e7d32';

 const badge = (label, value, bg, fg) =>
  `<span style="
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:3px 8px;
    border-radius:999px;
    font-weight:800;
    font-size:0.85em;
    background:${bg};
    color:${fg};
    border:1px solid rgba(0,0,0,0.08);
  ">
    <span style="opacity:0.85;">${label}</span>
    <span style="font-variant-numeric: tabular-nums;">${value}</span>
  </span>`;

const badge30 = badge('>30m', overspend30Text, '#fff3cd', '#664d03'); // warning
const badge33 = badge('>33m', overspend33Text, '#fde2e2', '#c1121f'); // critical

// ‚úÖ NOVO: diferen√ßa entre as regras (>30m vs >33m)
const deltaSec  = Math.max(0, overspend30Sec - overspendSec);
const deltaText = formatTime(deltaSec);
const badgeDiff = badge('Œî 30‚Üí33', deltaText, '#e9ecef', '#343a40');  // neutral

overtimeEl.innerHTML =
  'Over Spending: ' +
  `<span style="display:inline-flex; gap:8px; margin-left:6px; vertical-align:middle;">${badge30}${badge33}${badgeDiff}</span>` +
  `<span style="margin-left:10px; font-size:0.9em; font-weight:bold; color:#004d99;">Total Break: ${totalBreakText}</span>` +
  `<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:${percentColor};">` +
    `${percent.toFixed(2)}%` +
  `</span>`;



  return; // üëà n√£o cai na l√≥gica normal de Over Time
}

 // =========================
// MODO NORMAL = OVER TIME (CORE + AGY)
// =========================

const codeFilter = window.currentCodeFilter || '';

// 1) total vis√≠vel (Gross)
let visibleGrossSec = 0;
baseSource.forEach(e => {
  const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
  if (!time || time === 'N/A') return;
  const [h = 0, m = 0, s = 0] = time.split(':').map(Number);
  visibleGrossSec += h * 3600 + m * 60 + s;
});
// ‚úÖ OT base + OT total (respeita buckets quando existirem; sen√£o usa weekly como hoje)
let weeklyBaseSec = 0;
let weeklyOtSec   = 0;

// 1) tenta usar mapas por ‚Äúbucket‚Äù (AGY pode ser P1‚ÄìP11 quando mode=period)
const totalMapToUse =
  (window.bucketTotalByKey && typeof window.bucketTotalByKey.forEach === 'function' && (window.bucketTotalByKey.size || 0) > 0)
    ? window.bucketTotalByKey
    : window.weeklyTotalByKeyWeek;

const otMapToUse =
  (window.bucketOTByKey && typeof window.bucketOTByKey.forEach === 'function' && (window.bucketOTByKey.size || 0) > 0)
    ? window.bucketOTByKey
    : window.weeklyOTByKeyWeek;

// 2) se tiver mapas prontos, soma direto (r√°pido e consistente com o motor)
if (
  totalMapToUse && typeof totalMapToUse.forEach === 'function' &&
  otMapToUse    && typeof otMapToUse.forEach === 'function' &&
  (totalMapToUse.size || 0) > 0
) {
  totalMapToUse.forEach(v => { weeklyBaseSec += (Number(v) || 0); });
  otMapToUse.forEach(v => { weeklyOtSec += (Number(v) || 0); });

} else {
  // 3) fallback (√∫ltimo recurso) ‚Äî mant√©m a tua l√≥gica atual
  const perKey = new Map();
  const typeByKey = {};
  const empByPerson = {};

  baseSource.forEach(e => {
    const person = String(e.personNumber || '').trim();
    const week   = String(e.week || '').trim();
    if (!person || !week) return;

    const time = e.totalHoursFormatted || e.totalHours || '00:00:00';
    if (!time || time === 'N/A') return;

    const [h = 0, m = 0, s = 0] = String(time).split(':').map(Number);
    const sec = h * 3600 + m * 60 + s;

    weeklyBaseSec += sec;

    const key = `${person}|${week}`;
    perKey.set(key, (perKey.get(key) || 0) + sec);

    if (!typeByKey[key] && typeof getEmployeeType === 'function') {
      typeByKey[key] = String(getEmployeeType(e) || '').toLowerCase();
    }
    if (!empByPerson[person]) empByPerson[person] = e.employee || '';
  });

  perKey.forEach((sumSec, key) => {
    const person = key.split('|')[0];
    const typeLC = typeByKey[key] || '';
    const empName = empByPerson[person] || '';
    const thresholdSec = getWeeklyThresholdSecForRow(person, empName, typeLC);

    weeklyOtSec += Math.max(0, sumSec - thresholdSec);
  });
}
// 2) detectar ‚Äúcortes‚Äù (dept/date/labour/task/paycode)
//    ‚Ü≥ se houver corte, OT tem de vir do overtimeByRow (por linha)
const hasDeptCut   = currentDepartmentFilter && currentDepartmentFilter !== 'All';
const hasDateCut   = !!(document.getElementById('dateFilter')?.value || '').trim();
const hasLabCut    = !!(document.getElementById('labourAccountFilter')?.value || '').trim();
const hasTaskCut   = !!(document.getElementById('taskFilter')?.value || '').trim();
const hasPayCut1   = !!(document.getElementById('payCodeFilter')?.value || '').trim();
const hasPayCut2   = (window.selectedPayCodes && window.selectedPayCodes.size > 0);

const hasAnyCut = hasDeptCut || hasDateCut || hasLabCut || hasTaskCut || hasPayCut1 || hasPayCut2;

// 3) OT vis√≠vel
// ‚úÖ regra especial: em OT >40h (Week), o KPI N√ÉO pode depender do overtimeByRow vis√≠vel
// porque ao filtrar 4010 podes ficar s√≥ com linhas Break (que podem ter OT=0 por linha).
let visibleOtSec = weeklyOtSec;

// ‚úÖ base do % (por default √© o gross vis√≠vel)
let baseSecForLabel = visibleGrossSec;

// ‚úÖ Se estiver em OT >40h (Week), calcula por pessoa|semana usando os mapas semanais
const isOt40Now = !!window.isOt40WeekMode;

// ‚úÖ FIX: nunca referenciar weeklyTotalMap/weeklyOtMap ‚Äúsoltos‚Äù (ReferenceError)
// Usa sempre refer√™ncias seguras via window e escolhe bucket quando existir.
const weeklyTotalMapRef = window.weeklyTotalByKeyWeek;
const weeklyOtMapRef    = window.weeklyOTByKeyWeek;

const bucketTotalMapRef = window.bucketTotalByKey;
const bucketOtMapRef    = window.bucketOTByKey;

const ot40TotalMap =
  (bucketTotalMapRef && typeof bucketTotalMapRef.get === 'function' && (bucketTotalMapRef.size || 0) > 0)
    ? bucketTotalMapRef
    : weeklyTotalMapRef;

const ot40OtMap =
  (bucketOtMapRef && typeof bucketOtMapRef.get === 'function' && (bucketOtMapRef.size || 0) > 0)
    ? bucketOtMapRef
    : weeklyOtMapRef;

if (
  isOt40Now &&
  ot40TotalMap && typeof ot40TotalMap.get === 'function' &&
  ot40OtMap    && typeof ot40OtMap.get === 'function'
) {
  const keySet = new Set();
  const rows = document.querySelectorAll('#resultTable tbody tr');

  // ‚úÖ inclui colunas necess√°rias p/ montar bucketKey corretamente
  const COL_SAFE = window.COL || { employee: 0, type: 1, person: 2, week: 7 };

  rows.forEach(row => {
    if (row.style.display === 'none') return;
    const cells = row.getElementsByTagName('td');
    if (!cells.length) return;

    const person = String(cells[COL_SAFE.person]?.textContent || '').trim();
    const week   = String(cells[COL_SAFE.week]?.textContent || '').trim();
    if (!person || !week) return;

    const empName = String(cells[COL_SAFE.employee]?.textContent || '').trim();
    const typeTxt = String(cells[COL_SAFE.type]?.textContent || '').trim();

    // ‚úÖ chave consistente com o motor (weekly ou period)
    const key = (typeof window.getOtBucketKey === 'function')
      ? window.getOtBucketKey({ personNumber: person, week, type: typeTxt, employee: empName })
      : `${person}|${week}`;

    if (key) keySet.add(String(key));
  });

  let otSum = 0;
  let baseSum = 0;

  keySet.forEach(key => {
    otSum   += Number(ot40OtMap.get(key) || 0);
    baseSum += Number(ot40TotalMap.get(key) || 0);
  });

  visibleOtSec    = otSum;
  baseSecForLabel = baseSum;

} else if (window.overtimeByRow && typeof window.overtimeByRow.get === 'function') {
  // ‚úÖ modo normal (Ecom/Retail/Date/etc) continua por linha
  try {
    let sum = 0;
    const rows = document.querySelectorAll('#resultTable tbody tr');

    rows.forEach(row => {
      if (row.style.display === 'none') return;
      sum += (window.overtimeByRow.get(row) || 0);
    });

    visibleOtSec = sum;
  } catch (e) {
    // fallback silencioso para weeklyOtSec
  }
}


const baseHoursText = formatTime(baseSecForLabel);


// ‚úÖ OT Std (Cap) = o OT que j√° est√° distribu√≠do por linha (base oficial do teu filterTable)
const otStdSec = visibleOtSec;

// ‚úÖ OT Real (Tabela) = recalcula OT usando o BREAK RAW do CSV (sem cap),
// mas respeitando o MESMO threshold do bucket (weekly/period inteligente).
let otRealSec = otStdSec;

try {
  const rowsDom = document.querySelectorAll('#resultTable tbody tr');

  const COL_SAFE = window.COL || {
    employee: 0,
    type: 1,
    person: 2,
    date: 6,
    week: 7,
    labour: 9,
    department: 10,
    task: 11,
    totalHours: 13
  };

  const rawTotalByBucket = new Map(); // bucketKey -> totalRawSec (inclui break RAW)
  const weeksByBucket    = new Map(); // bucketKey -> Set(week)
  const metaByBucket     = new Map(); // bucketKey -> { person, empName, typeLC }

  const toSec = (hhmmss) => {
    const t = String(hhmmss || '').trim();
    if (!t || t === 'N/A') return 0;
    const [h=0,m=0,s=0] = t.split(':').map(Number);
    return (h*3600) + (m*60) + s;
  };

  rowsDom.forEach(row => {
    if (row.style.display === 'none') return;

    const cells = row.getElementsByTagName('td');
    if (!cells.length) return;

    const person = String(cells[COL_SAFE.person]?.textContent || '').trim();
    const week   = String(cells[COL_SAFE.week]?.textContent || '').trim();
    if (!person || !week) return;

    const empName = String(cells[COL_SAFE.employee]?.textContent || '').trim();
    const typeTx  = String(cells[COL_SAFE.type]?.textContent || '').trim();
    const typeLC  = typeTx.toLowerCase();

    const labourTx = String(cells[COL_SAFE.labour]?.textContent || '').trim();
    const depTx    = String(cells[COL_SAFE.department]?.textContent || '').trim();
    const taskTx   = String(cells[COL_SAFE.task]?.textContent || '').trim();

    const secRaw = toSec(cells[COL_SAFE.totalHours]?.textContent || '');
    if (secRaw <= 0) return;

    // bucketKey respeita weekly/period e a regra do P12 semanal
    const entryLike = {
      personNumber: person,
      week: week,
      type: typeTx,
      employee: empName,
      labourAccount: labourTx,
      department: depTx,
      task: taskTx
    };

    const bucketKey = (typeof window.getOtBucketKey === 'function')
      ? window.getOtBucketKey(entryLike)
      : `${person}|${week}`;

    rawTotalByBucket.set(bucketKey, (rawTotalByBucket.get(bucketKey) || 0) + secRaw);

    let setWeeks = weeksByBucket.get(bucketKey);
    if (!setWeeks) { setWeeks = new Set(); weeksByBucket.set(bucketKey, setWeeks); }
    setWeeks.add(String(week));

    if (!metaByBucket.has(bucketKey)) {
      metaByBucket.set(bucketKey, { person, empName, typeLC });
    }
  });

  let sumReal = 0;

  rawTotalByBucket.forEach((totalRawSec, bucketKey) => {
    const meta = metaByBucket.get(bucketKey) || {};
    const person  = meta.person  || String(bucketKey).split('|')[0] || '';
    const empName = meta.empName || '';
    const typeLC  = meta.typeLC  || '';

    // threshold semanal ‚Äúbase‚Äù (o mesmo que o motor usa)
    let baseWeekThrSec = 40 * 3600;
    if (typeof getWeeklyThresholdSecForRow === 'function') {
      const thr = getWeeklyThresholdSecForRow(person, empName, typeLC);
      if (Number.isFinite(thr) && thr > 0) baseWeekThrSec = thr;
    }

    // multiplier inteligente s√≥ para buckets de per√≠odo (|P1..|P11)
    let mult = 1;
    const m = String(bucketKey).match(/\|P(\d+)$/i);
    if (m) {
      const p = Number(m[1]);

      const weeksInP = (typeof getWeeksInPeriod === 'function')
        ? (getWeeksInPeriod(p) || 1)
        : 1;

      const loadedWeeks = weeksByBucket.get(bucketKey)?.size || 1;

      mult = Math.min(loadedWeeks, weeksInP);
    }

    const thrSec = baseWeekThrSec * mult;
    const ot = Math.max(0, Number(totalRawSec || 0) - Number(thrSec || 0));

    sumReal += ot;
  });

  otRealSec = sumReal;

} catch (e) {
  // se der erro, mant√©m otRealSec = otStdSec (fail-safe)
}

const deltaSec = Math.max(0, otRealSec - otStdSec);

const otStdText  = formatTime(otStdSec);
const otRealText = formatTime(otRealSec);
const deltaText  = formatTime(deltaSec);


// ‚úÖ percent com base no ‚ÄúReal‚Äù (o que estamos a pagar)
const overtimePercent = baseSecForLabel > 0
  ? (otRealSec / baseSecForLabel) * 100
  : 0;

const percentColor = overtimePercent > 5 ? '#c1121f' : '#2e7d32';

// ‚úÖ badges iguais ao teu estilo
const badge = (label, value, bg, fg) =>
  `<span style="
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:3px 8px;
    border-radius:999px;
    font-weight:800;
    font-size:0.85em;
    background:${bg};
    color:${fg};
    border:1px solid rgba(0,0,0,0.08);
  ">
    <span style="opacity:0.85;">${label}</span>
    <span style="font-variant-numeric: tabular-nums;">${value}</span>
  </span>`;

// ‚úÖ 1¬∫ badge LARANJA (como OverSpending)
const badgeStd  = badge('OT Std (Cap)', otStdText,  '#fff3cd', '#664d03');
const badgeReal = badge('OT Real (Tabela)', otRealText, '#fde2e2', '#c1121f');
const badgeDiff = badge('Œî Dif.', deltaText, '#e9ecef', '#343a40');

overtimeEl.innerHTML =
  'Over Time: ' +
  `<span style="display:inline-flex; gap:8px; margin-left:6px; vertical-align:middle;">${badgeStd}${badgeReal}${badgeDiff}</span>` +
  `<span style="margin-left:10px; font-size:0.9em; font-weight:bold; color:#004d99;">Total W/h: ${baseHoursText}</span>` +
  `<span style="margin-left:8px; font-size:0.9em; font-weight:bold; color:${percentColor};">` +
    `${overtimePercent.toFixed(2)}%` +
  `</span>`;
}

      function updateFilteredTotals(filteredData) {
  let ecomMinutes    = 0,
      retailMinutes  = 0,
      paidBreakMinutes = 0;

  // ‚úÖ mant√©m o comportamento atual para Ecom/Retail (para n√£o mudar os teus totais)
  (filteredData || []).forEach(entry => {
    const time = entry.totalHoursFormatted || entry.totalHours || '00:00:00';
    const [h = 0, m = 0, s = 0] = String(time).split(':').map(Number);
    const entrySeconds = h * 3600 + m * 60 + s;

    const dep = String(entry.department || '').trim().toLowerCase();

    if (dep === 'ecom') {
      ecomMinutes += entrySeconds;
    } else if (dep === 'retail') {
      retailMinutes += entrySeconds;
    }
  });

  // ‚úÖ NOVO: calcula Paid Break a partir do cache vis√≠vel (tem labourAccount/task)
  const src = Array.isArray(window.filteredRowsCache) ? window.filteredRowsCache : [];

  src.forEach(entry => {
    const time = entry.totalHoursFormatted || entry.totalHours || '00:00:00';
    const [h = 0, m = 0, s = 0] = String(time).split(':').map(Number);
    const entrySeconds = h * 3600 + m * 60 + s;

    const labourDigits = String(entry.labourAccount || '').replace(/\D/g, '');
    const taskLC = String(entry.task || '').toLowerCase();

    const isPaidBreakRow =
      labourDigits.endsWith('4010') ||
      /-4010\b/.test(taskLC) ||
      taskLC.includes('paid break');

    if (isPaidBreakRow) {
      paidBreakMinutes += entrySeconds;
    }
  });

  document.getElementById('totalEcom').textContent   = formatTime(ecomMinutes);
  document.getElementById('totalRetail').textContent = formatTime(retailMinutes);

  // ‚úÖ aqui o teu "Total Hours Paid Break" vai deixar de ser 0
  document.getElementById('totalBreak').textContent  = formatTime(paidBreakMinutes);
}

      function updateResult() {
  const plannedBudget = parseFloat(document.getElementById('budgetInput').value);
  const resultBox = document.getElementById('resultBox');

  if (isNaN(plannedBudget)) {
    resultBox.style.display = 'none';
    return;
  }

  // 1) Or√ßamento (horas ‚Üí segundos)
  const budgetSeconds = plannedBudget * 3600;

  // 2) Usa o TOTAL BRUTO actualmente vis√≠vel (grossSeconds global)
  const remainingSec = budgetSeconds - grossSeconds;

  // 3) Converte diferen√ßa em HH:MM (sempre valor absoluto, com sinal separado)
  const absSec = Math.abs(remainingSec);
  const h = Math.floor(absSec / 3600);
  const m = Math.floor((absSec % 3600) / 60);
  const sign = remainingSec < 0 ? '-' : '';

  const resultTime = `${sign}${h}:${m.toString().padStart(2, '0')}`;

  // 4) Mostra vermelho se consumiu mais que o budget, verde se ainda tem folga
  if (remainingSec < 0) {
    resultBox.innerHTML = `Result: <span style="color: red; font-weight: bold;">${resultTime}</span>`;
  } else {
    resultBox.innerHTML = `Result: <span style="color: green; font-weight: bold;">${resultTime}</span>`;
  }

  resultBox.style.display = 'block';
}

window.updateResult = updateResult;


      function toggleResult() {
        const resultBox = document.getElementById('resultBox');
        resultBox.style.display = (resultBox.style.display === 'none' || resultBox.style.display === '') ? 'block' : 'none';
      }

            function clearData() {
        displayResults([]);
        document.getElementById('resultBox').innerHTML = '';
        document.getElementById('grossHours').textContent = '0:00';
        document.getElementById('loggedHours').textContent = '0:00';
        document.getElementById('depTotalHours').textContent = '0:00';
        document.getElementById('totalEcom').textContent = '0:00';
        document.getElementById('totalRetail').textContent = '0:00';
        document.getElementById('totalBreak').textContent = '0:00';
        grossSeconds = 0;            // ‚¨Ö aqui
        grossMinutes = 0;            // se ainda usar em algum lugar legado
        originalTotalMinutes = 0;
      }


      function filterByDate() {
        const startDateInput = document.getElementById('startDate').value;
        const endDateInput = document.getElementById('endDate').value;
        if (!startDateInput || !endDateInput) {
          alert('Please select both start and end dates.');
          return;
        }
        const startDate = new Date(startDateInput);
        const endDate = new Date(endDateInput);
        if (isNaN(startDate) || isNaN(endDate)) {
          alert('Please enter valid start and end dates.');
          return;
        }
        const filteredData = storedData.filter(entry => {
          const entryDate = new Date(entry.date.split('/').reverse().join('-'));
          return entryDate >= startDate && entryDate <= endDate;
        });
        const aggregatedData = aggregateData(filteredData);
        displayResults(aggregatedData);
        updateTotalHours(aggregatedData);
        updateFilteredTotals(aggregatedData);
        updateResult();
        document.getElementById('startDate').value = '';
        document.getElementById('endDate').value = '';
      }
function applyExcel1904(wb) {
  if (!wb) return;
  wb.Workbook = wb.Workbook || {};
  wb.Workbook.WBProps = wb.Workbook.WBProps || {};
  wb.Workbook.WBProps.date1904 = true;
}

            function downloadExcelReportBetweenDates() {
  const startDateInput = document.getElementById('startDate').value;
  const endDateInput   = document.getElementById('endDate').value;

  if (!startDateInput || !endDateInput) {
    alert('Please select both start and end dates.');
    return;
  }

  const startDate = new Date(startDateInput);
  const endDate   = new Date(endDateInput);

  if (isNaN(startDate) || isNaN(endDate)) {
    alert('Please enter valid start and end dates.');
    return;
  }

    // ‚úÖ Fonte de verdade do Export:
  // 1) se existir cache da Home (linhas vis√≠veis), usa cache
  // 2) sen√£o usa storedData
  const exportBase =
    (window.filteredRowsCache && Array.isArray(window.filteredRowsCache) && window.filteredRowsCache.length)
      ? window.filteredRowsCache
      : storedData;

  // Filtra a fonte escolhida pelo intervalo seleccionado
  const filteredData = (exportBase || []).filter(entry => {
    const dateStr = String(entry.date || '').trim();
    if (!dateStr) return false;

    // espera dd/mm/yyyy
    const entryDate = new Date(dateStr.split('/').reverse().join('-'));
    return entryDate >= startDate && entryDate <= endDate;
  });

  if (filteredData.length === 0) {
    alert('No data available for the selected dates.');
    return;
  }

  // ---- helpers internos ----------------------------------------------------
  function parseBrDate(str) {
  const [d, m, y] = String(str || '').split('/').map(n => parseInt(n, 10));
  if (!d || !m || !y) return null;

  // ‚úÖ UTC evita o shift de 1 dia (DST/BST)
  return new Date(Date.UTC(y, m - 1, d));
}

// =======================
// Daily Detail ‚Äî Budget (Tasks)
// Soma o budget das tasks presentes no modal (sem duplicar task)
// =======================
function getBudgetTasksSecFromDailyRows(dailyRows) {
  dailyRows = Array.isArray(dailyRows) ? dailyRows : [];

  // tenta achar um Map de budgets que tu j√° tens no sistema
  const map =
    window.taskBudgetMap ||
    window.budgetByTask ||
    window.taskBudgetByTask ||
    window.taskBudgetByCode ||
    null;

  const seen = new Set();
  let sumSec = 0;

  const toTaskKey = (r) => String(
    r?.task || r?.Task || r?.taskCode || r?.TaskCode || ''
  ).trim();

  const toSec = (v) => {
    if (v == null) return 0;

    // se j√° vier em n√∫mero, assumo que √© "horas" (ex.: 6.5) -> converte
    if (typeof v === 'number' && Number.isFinite(v)) return Math.round(v * 3600);

    // se vier "HH:MM" ou "HH:MM:SS"
    const s = String(v).trim();
    if (!s) return 0;

    const parts = s.split(':').map(Number);
    const h = parts[0] || 0;
    const m = parts[1] || 0;
    const sec = parts[2] || 0;
    return (h * 3600) + (m * 60) + sec;
  };

  dailyRows.forEach(r => {
    const taskKey = toTaskKey(r);
    if (!taskKey || seen.has(taskKey)) return;
    seen.add(taskKey);

    let budgetVal = null;

    // 1) Prefer√™ncia: Map global por task
    if (map && typeof map.get === 'function') {
      budgetVal =
        map.get(taskKey) ??
        map.get(taskKey.replace(/\s+/g, '')) ??
        map.get(taskKey.replace(/\D/g, '')); // se for c√≥digo tipo "1500"
    }

    // 2) Fallback: se a pr√≥pria row j√° tiver budget (alguns modais guardam isso)
    if (budgetVal == null) {
      budgetVal = r?.budget || r?.budgetHours || r?.budgetTime || r?.budgetSec || null;
      // se j√° for sec expl√≠cito
      if (typeof r?.budgetSec === 'number' && Number.isFinite(r.budgetSec)) budgetVal = r.budgetSec / 3600;
    }

    sumSec += toSec(budgetVal);
  });

  return sumSec;
}

  function parseTimeToSeconds(value) {
    if (!value || value === 'N/A') return 0;
    const parts = String(value).split(':').map(Number);
    const h = parts[0] || 0;
    const m = parts[1] || 0;
    const s = parts[2] || 0;
    return h * 3600 + m * 60 + s;
  }

  function secondsToHours(sec) {
    return sec / 3600;
  }

  function styleSheet(ws) {
    if (!ws['!ref']) return;
    const range = XLSX.utils.decode_range(ws['!ref']);

    // Cabe√ßalho em bold (linha 0)
    const headerRow = range.s.r; // normalmente 0
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cellAddress = XLSX.utils.encode_cell({ r: headerRow, c: C });
      const cell = ws[cellAddress];
      if (!cell) continue;
      cell.s = cell.s || {};
      cell.s.font = cell.s.font || {};
      cell.s.font.bold = true;
    }

    // AutoFit simples (baseado no comprimento do texto)
    const colWidths = [];
    for (let C = range.s.c; C <= range.e.c; ++C) {
      let maxLen = 10;
      for (let R = range.s.r; R <= range.e.r; ++R) {
        const addr = XLSX.utils.encode_cell({ r: R, c: C });
        const cell = ws[addr];
        if (!cell || cell.v == null) continue;
        const len = String(cell.v).length;
        if (len > maxLen) maxLen = len;
      }
      colWidths.push({ wch: maxLen + 2 });
    }
    ws['!cols'] = colWidths;

    // Filtros no cabe√ßalho
    ws['!autofilter'] = { ref: ws['!ref'] };
  }

    function getEmployeeGroup(entry) {
    // ‚úÖ mesmo crit√©rio da Home (master + prefixes)
    if (typeof getEmployeeType === 'function') {
      const t = String(getEmployeeType(entry) || '').trim();
      if (t) return t;
    }

    // fallback antigo
    const name = String(entry && entry.employee ? entry.employee : '');
    if (/^247\b/i.test(name))   return 'AGY 247';
    if (/^extra\b/i.test(name)) return 'AGY J&T';
    return 'CORE';
  }

    // ---- workbook ------------------------------------------------------------
  const wb = XLSX.utils.book_new();

  // ‚úÖ TREXO 3 (aqui)
  const nameByPerson = {};
  (filteredData || []).forEach(e => {
    const person = String(e.personNumber || '').trim();
    if (person && !nameByPerson[person]) nameByPerson[person] = e.employee || '';
  });
  

  // =====================================================================
  //  SHEET 1: DETAILS  (espelha a tabela Home)
  // =====================================================================

    const wsData = [[
    'Employee',
    'Type',
    'Person Number',
    'Worker Type',
    'Supervisor',
    'Role',
    'Date',
    'Week',
    'Month',
    'Labour Account',
    'Dep.',
    'Task',
    'Hours Dec.',
    'Total Hours',
    'Pay Code'
  ]];

  filteredData.forEach(entry => {
    const totalHoursText = entry.totalHoursFormatted || entry.totalHours || '00:00:00';

    // calcula horas em decimal (prioridade: hoursDec do cache, depois totalHoursDecimal, depois parse do texto)
    let hoursDec;
    if (entry.hoursDec != null && String(entry.hoursDec).trim() !== '') {
      hoursDec = Number(String(entry.hoursDec).replace(',', '.'));
      if (!Number.isFinite(hoursDec)) hoursDec = 0;
      hoursDec = Number(hoursDec.toFixed(2));
    } else if (typeof entry.totalHoursDecimal === 'number') {
      hoursDec = Number(entry.totalHoursDecimal.toFixed(2));
    } else {
      const [h = 0, m = 0, s = 0] = String(totalHoursText).split(':').map(Number);
      const dec = h + m / 60 + s / 3600;
      hoursDec = Number(dec.toFixed(2));
    }

    wsData.push([
      entry.employee || '',
      (typeof getEmployeeType === 'function' ? getEmployeeType(entry) : (entry.type || '')) || '',
      entry.personNumber || '',
      entry.workerType || '',
      entry.supervisor || '',
      entry.role || '',
      entry.date || '',
      entry.week || '',
      entry.month || '',
      entry.labourAccount || '',
      entry.department || '',
      entry.task || '',
      hoursDec,
      totalHoursText,
      entry.payCode || ''
    ]);
  });


  const wsDetail = XLSX.utils.aoa_to_sheet(wsData);
  XLSX.utils.book_append_sheet(wb, wsDetail, 'Details');

  // Converte datas e horas para tipos num√©ricos (Excel) + formatos bonitos
    if (wsDetail['!ref']) {
    const rangeDet = XLSX.utils.decode_range(wsDetail['!ref']);
    for (let R = 1; R <= rangeDet.e.r; ++R) {
      // Date (coluna 6)
      const addrDate = XLSX.utils.encode_cell({ r: R, c: 6 });
      const cellDate = wsDetail[addrDate];
      if (cellDate && cellDate.v) {
        const d = parseBrDate(cellDate.v);
if (d) {
  cellDate.v = d;
  cellDate.t = 'd';
  cellDate.z = 'dd/mm/yyyy';
}
}

      // Total Hours (coluna 13)
      const addrTime = XLSX.utils.encode_cell({ r: R, c: 13 });
      const cellTime = wsDetail[addrTime];
      if (cellTime && cellTime.v) {
        const sec = parseTimeToSeconds(cellTime.v);
        cellTime.v = sec / 86400; // parte do dia
        cellTime.t = 'n';
        cellTime.z = '[hh]:mm:ss';
      }

      // Hours Dec. (coluna 12)
      const addrDec = XLSX.utils.encode_cell({ r: R, c: 12 });
      const cellDec = wsDetail[addrDec];
      if (cellDec && cellDec.v != null) {
        cellDec.t = 'n';
        cellDec.z = '0.00';
      }
    }
  }


  styleSheet(wsDetail);

  // Auto-ajuste adicional para a coluna Date
  const detCols = wsDetail['!cols'] || [];
    detCols[6] = detCols[6] || {};
  detCols[6].wch = 12;
  wsDetail['!cols'] = detCols;

const rowCount   = filteredData.length;
const otPerRow   = new Array(rowCount).fill(0);   // em segundos (OT por linha)
const secPerRow  = new Array(rowCount).fill(0);   // em segundos (tempo bruto por linha)

// ‚úÖ agora √© ‚Äúpor bucket‚Äù: person|Wxx OU person|Pxx (conforme getOtBucketKey)
const perBucket = {};       // bucketKey -> { totalWorkSec, breakEffectiveSec, totalForOTSec, weeklyThresholdSec, bucketThresholdSec, rows: [] }
const breakDayTotals = {};  // keyDay -> breakSecRaw
const bucketByDay = {};     // keyDay -> bucketKey (para saber a que bucket pertence aquele dia)

// helper: multiplier do threshold quando √© por per√≠odo
function getBucketMultiplier(bucketKey) {
  const s = String(bucketKey || '');
  const m = s.match(/\|P(\d+)$/i);
  if (!m) return 1;

  // ‚úÖ inteligente: semanas realmente carregadas nesse bucket (para essa pessoa)
  const wk = (typeof perBucket === 'object' && perBucket) ? perBucket[bucketKey] : null;
  const loaded = wk && wk.weeksSet && typeof wk.weeksSet.size === 'number' ? wk.weeksSet.size : 0;
  if (loaded > 0) return loaded;

  // fallback te√≥rico (caso ainda n√£o exista weeksSet por algum motivo)
  const p = Number(m[1]);
  return (typeof window.getWeeksInPeriod === 'function') ? (window.getWeeksInPeriod(p) || 1) : 1;
}

function isPaidBreakEntry(entry) {
  const labourDigits = String(entry.labourAccount || '').replace(/\D/g, '');
  const taskLC = String(entry.task || '').toLowerCase();
  return labourDigits.endsWith('4010') || /-4010\b/.test(taskLC) || taskLC.includes('paid break');
}

function dailyBreakAllowanceSec(thresholdSecWeekly) {
  if (thresholdSecWeekly >= 40 * 3600) return 30 * 60; // 30m
  if (thresholdSecWeekly >= 30 * 3600) return 20 * 60; // 20m
  return 0; // <30 => 0
}

// (mant√©m se tu quiseres usar depois; por agora n√£o mexo)
function dailyBreakAllowanceSecPlus3(thresholdSecWeekly) {
  if (thresholdSecWeekly >= 40 * 3600) return 33 * 60; // 33m
  if (thresholdSecWeekly >= 30 * 3600) return 23 * 60; // 23m
  return 0;
}

// 1) recolhe rows + soma work por bucket + soma break por dia
filteredData.forEach((entry, idx) => {
  // ‚úÖ OT s√≥ conta com PayCodes limpos
  if (!isPayCodeAllowedForOT(entry)) {
    secPerRow[idx] = 0;
    return;
  }

  const totalText = entry.totalHoursFormatted || entry.totalHours || '00:00:00';
  const secsRaw = parseTimeToSeconds(totalText);
  secPerRow[idx] = secsRaw;

  const person  = String(entry.personNumber || '').trim();
  const weekStr = String(entry.week || '').trim();
  const dateStr = String(entry.date || '').trim();
  if (!person || !weekStr || !dateStr || secsRaw <= 0) return;

  // ‚úÖ chave do bucket (Week ou Period)
  const bucketKey = (typeof window.getOtBucketKey === 'function')
  ? window.getOtBucketKey(entry)
  : `${person}|W${weekStr}`;


  const keyDay = `${person}|${weekStr}|${dateStr}`;
  if (!bucketByDay[keyDay]) bucketByDay[keyDay] = bucketKey;

  // threshold semanal (mesma fun√ß√£o da Home)
  const typeLC = String((typeof getEmployeeType === 'function' ? getEmployeeType(entry) : '') || '').toLowerCase();
  const weeklyThresholdRaw = getWeeklyThresholdSecForRow(person, entry.employee || '', typeLC);
  const weeklyThresholdSec = (Number.isFinite(weeklyThresholdRaw) && weeklyThresholdRaw > 0)
    ? weeklyThresholdRaw
    : (40 * 3600);

    if (!perBucket[bucketKey]) {
    perBucket[bucketKey] = {
      totalWorkSec       : 0,            // s√≥ trabalho (sem break)
      breakEffectiveSec  : 0,            // break CAPADO (somado por dia)
      totalForOTSec      : 0,            // work + breakEffective
      weeksSet           : new Set(),    // ‚úÖ NOVO: weeks realmente presentes no bucket
      weeklyThresholdSec : weeklyThresholdSec, // usado p/ allowance di√°ria
      bucketThresholdSec : 0,            // ‚úÖ recalculado a seguir
      rows               : []
    };
  }

  // ‚úÖ regista week e recalcula thresholds de forma inteligente
  const wk = perBucket[bucketKey];

  wk.weeksSet.add(String(weekStr));
  wk.weeklyThresholdSec = Math.max(wk.weeklyThresholdSec || 0, weeklyThresholdSec);

  const mult = getBucketMultiplier(bucketKey); // usa wk.weeksSet.size quando for P
  wk.bucketThresholdSec = wk.weeklyThresholdSec * mult;


  const isBreakRow = isPaidBreakEntry(entry);

  if (isBreakRow) {
    breakDayTotals[keyDay] = (breakDayTotals[keyDay] || 0) + secsRaw;
  } else {
    perBucket[bucketKey].totalWorkSec += secsRaw;
  }

  perBucket[bucketKey].rows.push({
    idx,
    secsRaw,
    isBreakRow,
    keyDay
  });
});

// 2) calcula break efetivo (CAPADO) por dia e soma ao bucket
const breakRemainingByKeyDay = {};

Object.entries(breakDayTotals).forEach(([keyDay, rawSec]) => {
  const bucketKey = bucketByDay[keyDay];
  if (!bucketKey) return;

  const wk = perBucket[bucketKey];
  if (!wk) return;

  // ‚úÖ allowance baseada no THRESHOLD SEMANAL (contrato), n√£o no do per√≠odo
  const weeklyThresholdSec = wk.weeklyThresholdSec || (40 * 3600);
  const allowance = dailyBreakAllowanceSec(weeklyThresholdSec);

  const effective = allowance > 0 ? Math.min(rawSec, allowance) : 0;

  breakRemainingByKeyDay[keyDay] = effective;
  wk.breakEffectiveSec += effective;
});

// 3) fecha totalForOTSec = work + break efetivo
Object.values(perBucket).forEach(wk => {
  wk.totalForOTSec = (wk.totalWorkSec || 0) + (wk.breakEffectiveSec || 0);
});

// 4) distribui OT por bucket pelas linhas (break usa tempo efetivo)
Object.values(perBucket).forEach(wk => {
  const thresholdBucket = (Number.isFinite(wk.bucketThresholdSec) && wk.bucketThresholdSec > 0)
    ? wk.bucketThresholdSec
    : (40 * 3600);

  let otLeft = Math.max(0, (wk.totalForOTSec || 0) - thresholdBucket);
  if (otLeft <= 0) return;

  for (const row of wk.rows) {
    if (otLeft <= 0) break;

    let rowEffective = row.secsRaw;

    if (row.isBreakRow) {
      const left = breakRemainingByKeyDay[row.keyDay] || 0;
      rowEffective = Math.min(row.secsRaw, left);
      breakRemainingByKeyDay[row.keyDay] = Math.max(0, left - rowEffective);
    }

    if (rowEffective <= 0) continue;

    const portion = Math.min(rowEffective, otLeft);
    otPerRow[row.idx] += portion;
    otLeft -= portion;
  }
});

  // =====================================================================
  //  AGREGADOS: POR PESSOA, POR DEPARTAMENTO, POR TASK
  // =====================================================================
  const personAgg = {}; // personNumber -> {employee, group, totalSec, otSec}
  const deptAgg   = {}; // group -> {group, totalSec, otSec}
  const taskAgg   = {}; // task  -> {task, totalSec, otSec}

  filteredData.forEach((entry, idx) => {
  // ‚úÖ estas folhas precisam estar "limpas" por PayCode
  if (!isPayCodeAllowedForOT(entry)) return;

  const person = entry.personNumber || '';
  const name   = entry.employee || '';
  const task   = entry.task || 'N/A';
  const group  = getEmployeeGroup(entry);

  const secs  = secPerRow[idx];
  const otSec = otPerRow[idx];

  // Pessoa
  if (!personAgg[person]) {
    personAgg[person] = {
      employee    : name,
      personNumber: person,
      group,
      totalSec    : 0,
      otSec       : 0
    };
  }
  personAgg[person].totalSec += secs;
  personAgg[person].otSec    += otSec;

  // Departamento
  if (!deptAgg[group]) {
    deptAgg[group] = { group, totalSec: 0, otSec: 0 };
  }
  deptAgg[group].totalSec += secs;
  deptAgg[group].otSec    += otSec;

  // Task
  if (!taskAgg[task]) {
    taskAgg[task] = { task, totalSec: 0, otSec: 0 };
  }
  taskAgg[task].totalSec += secs;
  taskAgg[task].otSec    += otSec;
});

  // =====================================================================
  //  SHEET 2: OT_by_Person
  // =====================================================================
  const wsPersonData = [[
    'Employee',
    'Person Number',
    'Group',
    'Total Hours (h)',
    'Over Time (h)',
    'OT %'
  ]];

  Object.values(personAgg)
    .sort((a, b) => b.otSec - a.otSec)
    .forEach(p => {
      const totalH = secondsToHours(p.totalSec);
      const otH    = secondsToHours(p.otSec);
      const pct    = totalH > 0 ? (otH / totalH) * 100 : 0;

      wsPersonData.push([
        p.employee,
        p.personNumber,
        p.group,
        Number(totalH.toFixed(2)),
        Number(otH.toFixed(2)),
        Number(pct.toFixed(2))
      ]);
    });

  const wsPerson = XLSX.utils.aoa_to_sheet(wsPersonData);
  XLSX.utils.book_append_sheet(wb, wsPerson, 'OT_by_Person');
  styleSheet(wsPerson);

  // =====================================================================
  //  SHEET 3: OT_by_Department
  // =====================================================================
  const wsDeptData = [[
    'Group',
    'Total Hours (h)',
    'Over Time (h)',
    'OT %'
  ]];

  Object.values(deptAgg)
    .sort((a, b) => b.otSec - a.otSec)
    .forEach(d => {
      const totalH = secondsToHours(d.totalSec);
      const otH    = secondsToHours(d.otSec);
      const pct    = totalH > 0 ? (otH / totalH) * 100 : 0;

      wsDeptData.push([
        d.group,
        Number(totalH.toFixed(2)),
        Number(otH.toFixed(2)),
        Number(pct.toFixed(2))
      ]);
    });

  const wsDept = XLSX.utils.aoa_to_sheet(wsDeptData);
  XLSX.utils.book_append_sheet(wb, wsDept, 'OT_by_Department');
  styleSheet(wsDept);

  // =====================================================================
  //  SHEET 4: OT_by_Task
  // =====================================================================
  const wsTaskData = [[
    'Task',
    'Total Hours (h)',
    'Over Time (h)',
    'OT %'
  ]];

  Object.values(taskAgg)
    .sort((a, b) => b.otSec - a.otSec)
    .forEach(t => {
      const totalH = secondsToHours(t.totalSec);
      const otH    = secondsToHours(t.otSec);
      const pct    = totalH > 0 ? (otH / totalH) * 100 : 0;

      wsTaskData.push([
        t.task,
        Number(totalH.toFixed(2)),
        Number(otH.toFixed(2)),
        Number(pct.toFixed(2))
      ]);
    });

  const wsTask = XLSX.utils.aoa_to_sheet(wsTaskData);
  XLSX.utils.book_append_sheet(wb, wsTask, 'OT_by_Task');
  styleSheet(wsTask);

  // =====================================================================
  //  SHEET 5: OT_Insights
  // =====================================================================
  const topPersons = Object.values(personAgg)
    .filter(p => p.otSec > 0)
    .sort((a, b) => b.otSec - a.otSec)
    .slice(0, 10);

  const wsInsightData = [[
    'Rank',
    'Employee',
    'Person Number',
    'Group',
    'Total OT (h)',
    'Total Hours (h)',
    'OT %'
  ]];

  topPersons.forEach((p, idx) => {
    const totalH = secondsToHours(p.totalSec);
    const otH    = secondsToHours(p.otSec);
    const pct    = totalH > 0 ? (otH / totalH) * 100 : 0;

    wsInsightData.push([
      idx + 1,
      p.employee,
      p.personNumber,
      p.group,
      Number(otH.toFixed(2)),
      Number(totalH.toFixed(2)),
      Number(pct.toFixed(2))
    ]);
  });

  const wsInsights = XLSX.utils.aoa_to_sheet(wsInsightData);
  XLSX.utils.book_append_sheet(wb, wsInsights, 'OT_Insights');
  styleSheet(wsInsights);

  // =====================================================================
  //  SHEET 6: Dashboard_KPI
  // =====================================================================
  let totalAllSec = 0;
  let totalOTSec  = 0;

  Object.values(personAgg).forEach(p => {
    totalAllSec += p.totalSec;
    totalOTSec  += p.otSec;
  });

  const totalAllH = secondsToHours(totalAllSec);
  const totalOTH  = secondsToHours(totalOTSec);
  const otFrac    = totalAllSec > 0 ? (totalOTSec / totalAllSec) : 0;

  const top5Persons = Object.values(personAgg)
    .sort((a, b) => b.otSec - a.otSec)
    .slice(0, 5);

  const top5Tasks = Object.values(taskAgg)
    .sort((a, b) => b.otSec - a.otSec)
    .slice(0, 5);

  const topGroups = Object.values(deptAgg)
    .sort((a, b) => b.otSec - a.otSec);

  const dashData = [];

  // KPI principais
  dashData.push(['KPI', 'Value']);
  dashData.push(['Total Hours (h)', Number(totalAllH.toFixed(2))]);
  dashData.push(['Total OT (h)', Number(totalOTH.toFixed(2))]);
  dashData.push(['OT %', otFrac]); // formatado como % no Excel

  dashData.push(['', '']);
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Break Overspending KPIs (igual √† Home)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let totalBreakSec = 0;
  let over30Sec = 0;
  let over33Sec = 0;

  const breakByPersonDay = new Map(); // person|date -> total break sec

  filteredData.forEach(e => {
    if (!isPaidBreakEntry(e)) return;

    const person = String(e.personNumber || '').trim();
    const date   = String(e.date || '').trim();
    if (!person || !date) return;

    const sec = parseTimeToSeconds(e.totalHoursFormatted || e.totalHours || '00:00:00');
    totalBreakSec += sec;

    const key = `${person}|${date}`;
    breakByPersonDay.set(key, (breakByPersonDay.get(key) || 0) + sec);
  });

  breakByPersonDay.forEach(daySec => {
    if (daySec > 30 * 60) over30Sec += (daySec - 30 * 60);
    if (daySec > 33 * 60) over33Sec += (daySec - 33 * 60);
  });

  dashData.push(['Break KPIs', '']);
  dashData.push(['Total Paid Break', totalBreakSec / 86400]);        // Excel time
  dashData.push(['Over Spending >30m', over30Sec / 86400]);          // Excel time
  dashData.push(['Over Spending >33m', over33Sec / 86400]);          // Excel time
  dashData.push(['Over >33m %', totalBreakSec > 0 ? (over33Sec / totalBreakSec) : 0]); // %
  dashData.push(['', '']);

  // OT por Grupo
  dashData.push(['OT by Group', '']);
  dashData.push(['Group', 'OT (h)']);
  topGroups.forEach(g => {
    dashData.push([
      g.group,
      Number(secondsToHours(g.otSec).toFixed(2))
    ]);
  });

  dashData.push(['', '']);

  // Top 5 ‚Äì OT por Pessoa
  dashData.push(['Top 5 ‚Äì OT by Person', '']);
  dashData.push(['Employee', 'OT (h)']);
  top5Persons.forEach(p => {
    dashData.push([
      p.employee,
      Number(secondsToHours(p.otSec).toFixed(2))
    ]);
  });

  dashData.push(['', '']);

  // Top 5 ‚Äì OT por Task
  dashData.push(['Top 5 ‚Äì OT by Task', '']);
  dashData.push(['Task', 'OT (h)']);
  top5Tasks.forEach(t => {
    dashData.push([
      t.task,
      Number(secondsToHours(t.otSec).toFixed(2))
    ]);
  });

  const wsDash = XLSX.utils.aoa_to_sheet(dashData);
  styleSheet(wsDash);

  // Formata√ß√£o especial para OT %
const dashRange = XLSX.utils.decode_range(wsDash['!ref']);
for (let R = 0; R <= dashRange.e.r; ++R) {
  const addrLabel = XLSX.utils.encode_cell({ r: R, c: 0 });
  const addrVal   = XLSX.utils.encode_cell({ r: R, c: 1 });
  const cLabel    = wsDash[addrLabel];
  const cVal      = wsDash[addrVal];

  if (cLabel && cVal) {
    // % cells
    if ((cLabel.v === 'OT %' || cLabel.v === 'Over >33m %') && typeof cVal.v === 'number') {
      cVal.t = 'n';
      cVal.z = '0.00%';
    }

    // time cells
    if (
      (cLabel.v === 'Total Paid Break' ||
       cLabel.v === 'Over Spending >30m' ||
       cLabel.v === 'Over Spending >33m') &&
      typeof cVal.v === 'number'
    ) {
      cVal.t = 'n';
      cVal.z = '[hh]:mm:ss';
    }
  }
}

  XLSX.utils.book_append_sheet(wb, wsDash, 'Dashboard_KPI');

  // ======================================================
//  SHEET 7: Overtime Detail (formatado como tempo real)
// ======================================================
(function () {
  if (!filteredData || !filteredData.length) return;

  const jsonData = [];

  filteredData.forEach((entry, idx) => {
    const otSec = otPerRow[idx] || 0;
    if (otSec <= 0) return; 

    const otDec  = otSec / 3600;      // decimal
    const otXLS  = otSec / 86400;     // Excel time

    jsonData.push({
      Person     : entry.employee || entry.personNumber || '',
      Date       : entry.date || '',
      Task       : entry.task || '',
            Type       : (typeof getEmployeeType === 'function' ? getEmployeeType(entry) : (entry.type || '')),
      HoursDec   : Number(otDec.toFixed(2)),  // duas casas decimais
      TotalHours : otXLS                      // agora como tempo calcul√°vel
    });
  });

  if (!jsonData.length) return;

  const wsOT = XLSX.utils.json_to_sheet(jsonData);
  styleSheet(wsOT);

  // ------------------------
  // FORMATA√á√ÉO DAS COLUNAS
  // ------------------------
  const range = XLSX.utils.decode_range(wsOT['!ref']);

  for (let R = 1; R <= range.e.r; R++) {

    // HoursDec (coluna E = index 4)
    const addrDec = XLSX.utils.encode_cell({ r: R, c: 4 });
    const cellDec = wsOT[addrDec];
    if (cellDec) {
      cellDec.t = 'n';
      cellDec.z = '0.00';   // duas casas
    }

    // TotalHours (coluna F = index 5)
    const addrTime = XLSX.utils.encode_cell({ r: R, c: 5 });
    const cellTime = wsOT[addrTime];
    if (cellTime) {
      cellTime.t = 'n';
      cellTime.z = '[hh]:mm:ss';  // tempo real calcul√°vel
    }
  }

  XLSX.utils.book_append_sheet(wb, wsOT, 'Overtime Detail');
})();


    // ======================================================
// ‚òÖ SHEET 8 ‚Äì Break Overspending (c√°lculo real em Excel)
// ======================================================
(function () {
  if (!filteredData || !filteredData.length) return;

  // Agrupa por pessoa + data
  const map = new Map();

  filteredData.forEach(entry => {
    const taskName = (entry.task || '').toLowerCase();
    const labour   = String(entry.labourAccount || '');

    // Identificar Break (igual ao Dashboard)
    const isBreak =
      /break/.test(taskName) ||
      labour.endsWith('4010') ||
      /4010\b/.test(taskName) ||
      /1007654010|1007684010/.test(labour);

    if (!isBreak) return;

        const personNumber = String(entry.personNumber || '').trim();
    const personName   = nameByPerson[personNumber] || entry.employee || personNumber || '';
    const date         = entry.date || '';
    if (!personNumber || !date) return;

    // ‚úÖ chave est√°vel: PersonNumber + Date (evita duplicar por varia√ß√µes no nome)
    const key = `${personNumber}|${date}`;

    const prev = map.get(key) || {
      personNumber,
      person: personName,
      date,
      task: entry.task || 'E.Paid Break-4010',
      totalSec: 0
    };


    const secs = parseTimeToSeconds(
      entry.totalHoursFormatted || entry.totalHours || '00:00:00'
    );

    prev.totalSec += secs;

    map.set(key, prev);
  });
const rows = Array.from(map.values());
  if (!rows.length) return;

  // Criar JSON calcul√°vel
    const jsonData = rows.map(r => {
    const baseline30Sec = 30 * 60;
    const baseline33Sec = 33 * 60;
    const consumedSec   = r.totalSec;

    const over30Sec = Math.max(0, consumedSec - baseline30Sec);
    const over33Sec = Math.max(0, consumedSec - baseline33Sec);

    return {
      Person        : r.person,
      Date          : r.date,
      Task          : r.task,
      Standard_30m  : baseline30Sec / 86400,
      Standard_33m  : baseline33Sec / 86400,
      ConsumedBreak : consumedSec   / 86400,
      Over_30m      : over30Sec     / 86400,
      Over_33m      : over33Sec     / 86400
    };
  });


  const wsOS = XLSX.utils.json_to_sheet(jsonData);
  styleSheet(wsOS);

     // Formatos de tempo
  const range = XLSX.utils.decode_range(wsOS['!ref']);
  for (let R = 1; R <= range.e.r; R++) {

    // Standard_30m (coluna D = index 3)
    const addrD = XLSX.utils.encode_cell({ r: R, c: 3 });
    const cellD = wsOS[addrD];
    if (cellD) { cellD.t = 'n'; cellD.z = '[hh]:mm:ss'; }

    // Standard_33m (coluna E = index 4)
    const addrE = XLSX.utils.encode_cell({ r: R, c: 4 });
    const cellE = wsOS[addrE];
    if (cellE) { cellE.t = 'n'; cellE.z = '[hh]:mm:ss'; }

    // ConsumedBreak (coluna F = index 5)
    const addrF = XLSX.utils.encode_cell({ r: R, c: 5 });
    const cellF = wsOS[addrF];
    if (cellF) { cellF.t = 'n'; cellF.z = '[hh]:mm:ss'; }

    // Over_30m (coluna G = index 6)
    const addrG = XLSX.utils.encode_cell({ r: R, c: 6 });
    const cellG = wsOS[addrG];
    if (cellG) { cellG.t = 'n'; cellG.z = '[hh]:mm:ss'; }

    // Over_33m (coluna H = index 7)
    const addrH = XLSX.utils.encode_cell({ r: R, c: 7 });
    const cellH = wsOS[addrH];
    if (cellH) { cellH.t = 'n'; cellH.z = '[hh]:mm:ss'; }
  }


  XLSX.utils.book_append_sheet(wb, wsOS, 'Break Overspending');
})();

  // ======================================================
  applyExcel1904(wb);
XLSX.writeFile(wb, 'budget_tracker_report.xlsx', { cellDates: true });
}

// ---------- helper TYPE dropdown (fora de qualquer outra fun√ß√£o) ----------
function populateTypeDropdown() {
  const typeSelect = document.getElementById('typeFilter');
  if (!typeSelect) return;

  // ‚úÖ agora usa o ENTRY inteiro (para ler personNumber e bater no Master)
  const types = [...new Set((storedData || []).map(e => getEmployeeType(e)))]
    .filter(Boolean)
    .sort((a, b) => {
      // opcional: coloca FT/PT no topo
      const aLC = a.toLowerCase(), bLC = b.toLowerCase();
      const aIsFTPT = aLC.includes('full') || aLC.includes('part');
      const bIsFTPT = bLC.includes('full') || bLC.includes('part');
      if (aIsFTPT !== bIsFTPT) return aIsFTPT ? -1 : 1;
      return a.localeCompare(b);
    });

  typeSelect.innerHTML = '<option value="">All</option>';
  types.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t;         // mant√©m texto original
    opt.textContent = t;
    typeSelect.appendChild(opt);
  });
}

// ---------- downloadBudgetReport ----------
function downloadBudgetReport() {
  /* 1) Seleciona a tabela que est√° na tela */
  const table = document.getElementById('budgetTable');
  if (!table) {
    alert('Tabela Budget n√£o encontrada na p√°gina.');
    return;
  }

  /* 2) Converte a tabela HTML ‚Üí workbook respeitando merges */
  const wb = XLSX.utils.table_to_book(table, {
    sheet: 'Budget Report',   // nome da aba dentro do Excel
    raw  : true               // mant√©m textos exatamente como est√£o (ex.: 07:30)
  });

  /* 3) Faz o download do arquivo */
  XLSX.writeFile(wb, 'budget_tracker_budget_report.xlsx');
}

// ---------- fim ----------
function populateDropdowns() {
  const weekDropdown  = document.getElementById('selectWeek');
  const monthDropdown = document.getElementById('selectMonth');
  const dateDropdown  = document.getElementById('dateFilter');

  const weeks  = [...new Set(storedData.map(entry => entry.week))];
  const months = [...new Set(storedData.map(entry => entry.month))];
  const dates  = [...new Set(storedData.map(entry => entry.date))];

  // Preenche Week
  weekDropdown.innerHTML = '<option value="">Select Week</option>';
  weeks.forEach(week => {
    weekDropdown.innerHTML += `<option value="${week}">Week ${week}</option>`;
  });

  // Preenche Month
  monthDropdown.innerHTML = '<option value="">Select Month</option>';
  months.forEach(month => {
    monthDropdown.innerHTML += `<option value="${month}">${month}</option>`;
  });

  // Preenche Date
  dateDropdown.innerHTML = '<option value="">All</option>';
  dates
    .sort((a, b) => {
      const [da, ma, ya] = a.split('/').map(Number);
      const [db, mb, yb] = b.split('/').map(Number);
      return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
    })
    .forEach(dateStr => {
      const [d, m, y] = dateStr.split('/');
      const iso = `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
      dateDropdown.innerHTML += `<option value="${iso}">${dateStr}</option>`;
    });

  // listeners para filtrar tabela
  weekDropdown.addEventListener('change', filterTable);
  monthDropdown.addEventListener('change', filterTable);
  dateDropdown.addEventListener('change', filterTable);

  // listeners para re-renderizar o dashboard
  weekDropdown.addEventListener('change', () => {
    if (document.getElementById('dashboard').classList.contains('active')) {
      renderDashboard();
    }
  });
  monthDropdown.addEventListener('change', () => {
    if (document.getElementById('dashboard').classList.contains('active')) {
      renderDashboard();
    }
  });
  dateDropdown.addEventListener('change', () => {
    if (document.getElementById('dashboard').classList.contains('active')) {
      renderDashboard();
    }
  });
}

  window.renderDashboard = function () {
    let totalConsumedSec    = 0;
    let totalPlannedSec     = 0;
    const headcountSet      = new Set();
    let missingTasks        = 0;
    const consumedPerWeekSec = {};
    const plannedPerWeekSec  = {};
    const deptTotalsSec     = {};
    const taskTotalsSec     = {};
    const alreadyCounted    = new Set();

    // === NOVO: l√™ valores de semana e m√™s selecionados ===
    const selectedWeek  = document.getElementById('selectWeek').value;  // ex: "3" ou ""
    const selectedMonth = document.getElementById('selectMonth').value; // ex: "May" ou ""

    // Filtragem base: por departamento
    // Filtragem base: por departamento (agora Break tamb√©m via department)
let baseData;

if (currentDepartmentFilter === 'All') {
  baseData = storedData;

} else if (currentDepartmentFilter === 'Break') {
  baseData = (storedData || []).filter(e => {
    const labour = String(e.labourAccount || '').toLowerCase();
    const taskLC = String(e.task || '').toLowerCase();
    const dep    = String(e.department || '');
    return dep === 'Break' || labour.endsWith('4010') || taskLC.includes('break');
  });

} else {
  baseData = (storedData || []).filter(e => String(e.department || '') === String(currentDepartmentFilter));
}


    // === NOVO: aplica filtro por semana, se selecionado ===
if (selectedWeek !== '') {
  baseData = baseData.filter(e => String(e.week) === selectedWeek);
}
// === NOVO: aplica filtro por m√™s, se selecionado ===
if (selectedMonth !== '') {
  baseData = baseData.filter(e => e.month === selectedMonth);
}

// ---------- LINHA ALTERADA (Passo 3) ----------
// ‚úÖ se houver cache (Home), usa cache; sen√£o usa baseData (Dept/Week/Month)
const dashboardData =
  (window.filteredRowsCache && window.filteredRowsCache.length)
    ? window.filteredRowsCache
    : baseData;

// ---------------------------------------------


// 1) soma consumido e planned para cada registro filtrado
dashboardData.forEach(e => {
  // Consumo
  const [h = 0, m = 0, s = 0] =
    (e.totalHoursFormatted || '00:00:00').split(':').map(Number);
  const consumedSec = h * 3600 + m * 60 + s;
  totalConsumedSec += consumedSec;

  // Trend por semana
  const wk = e.week;
  consumedPerWeekSec[wk] = (consumedPerWeekSec[wk] || 0) + consumedSec;

  // KPIs de headcount, missing, dept e task totals
  headcountSet.add(`${e.employee}|${e.date}`);
  if (e.task.endsWith('Missing Task-0000')) missingTasks++;
  if (e.department)
    deptTotalsSec[e.department] = (deptTotalsSec[e.department] || 0) + consumedSec;
  if (e.task && e.task !== 'N/A')
    taskTotalsSec[e.task] = (taskTotalsSec[e.task] || 0) + consumedSec;

  // Planned s√≥ para os dias que aparecem em dashboardData
  const key = `${e.task}|${e.date}`;
  if (!alreadyCounted.has(key)) {
    const plannedDec = (plannedHoursTracker[e.task] || {})[e.date] || 0;
    const plannedSec = Math.round(plannedDec * 3600);
    totalPlannedSec += plannedSec;
    plannedPerWeekSec[wk] = (plannedPerWeekSec[wk] || 0) + plannedSec;
    alreadyCounted.add(key);
  }
});

// 2) soma tamb√©m os planned em dias SEM consumo, mas s√≥ para as mesmas tasks/semana
const visibleTasks = new Set(dashboardData.map(e => e.task));
Object.keys(consumedPerWeekSec).forEach(wk => {
  Object.entries(plannedHoursTracker).forEach(([tsk, datesObj]) => {
    if (!visibleTasks.has(tsk)) return;
    Object.entries(datesObj).forEach(([dateKey, dec]) => {
      if (dateKey === 'budget' || dateKey === 'budgets') return;

      const [d, m, y] = dateKey.split('/').map(Number);
      if (getCustomWeekNumber(new Date(y, m - 1, d)) === Number(wk)) {
        const key2 = `${tsk}|${dateKey}`;
        if (!alreadyCounted.has(key2)) {
          const sec = Math.round(dec * 3600);
          totalPlannedSec += sec;
          plannedPerWeekSec[wk] = (plannedPerWeekSec[wk] || 0) + sec;
          alreadyCounted.add(key2);
        }
      }
    });
  });
});
/* ‚Üë FIM filtro dept planned ‚Üë */

document.getElementById('kpiConsumed').textContent    = formatTime(totalConsumedSec);
document.getElementById('kpiPlanned').textContent     = formatTimeHHMM(totalPlannedSec);
document.getElementById('kpiHeadcount').textContent   = headcountSet.size;
document.getElementById('kpiMissing').textContent     = missingTasks;
document.getElementById('kpiMissing').style.color     = '#c1121f';

// ‚Äî‚Äî‚Äî‚Äî‚Äî Novo: mant√©m o texto fixo e s√≥ adiciona tooltip ‚Äî‚Äî‚Äî‚Äî‚Äî
const dashboardPlannedLabel = document.getElementById('dashboardPlannedLabel');
if (dashboardPlannedLabel) {
  const uniqueTasks = [...new Set(dashboardData.map(e => e.task))];


  // 1) sempre mostra "Planned Hours"
  dashboardPlannedLabel.textContent = 'Planned Hours';
  // opcional: cursor de help
  dashboardPlannedLabel.style.cursor = 'help';

  // 2) se houver exatamente UMA task, coloca no title
  if (uniqueTasks.length === 1) {
    dashboardPlannedLabel.setAttribute('title', uniqueTasks[0]);
  } else {
    dashboardPlannedLabel.removeAttribute('title');
  }
}
// ‚Üë at√© aqui ‚Üë

// ... segue a renderiza√ß√£o dos gr√°ficos ...

    // ‚îÄ‚îÄ‚îÄ TREND CHART ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (window.trendChartObj) window.trendChartObj.destroy();

// 1) Semanas presentes no objeto de consumo
const weeks = Object.keys(consumedPerWeekSec).sort((a, b) => a - b);
const weeksSet = new Set(weeks.map(w => String(w)));

// Helper interno: acumula budget por semana, com filtro opcional de tasks
function accumulateBudgetHours(taskFilterFn) {
  const budgetPerWeek = {}; // { week -> horas }

  Object.entries(plannedHoursTracker).forEach(([tsk, plan]) => {
    if (taskFilterFn && !taskFilterFn(tsk)) return;

    // (b) filtro por Departamento
    if (currentDepartmentFilter !== 'All') {
      const isEcom   = tsk.startsWith('E.');
      const isRetail = tsk.startsWith('R.');
      const isBreak  = /break/i.test(tsk);
      if (
           (currentDepartmentFilter === 'Ecom'   && !isEcom)   ||
           (currentDepartmentFilter === 'Retail' && !isRetail) ||
           (currentDepartmentFilter === 'Break'  && !isBreak)
         ) return;
    }

    // NOVO: suporte a budget por semana (plan.budgets)
    const budgetsObj = plan.budgets || null;

    if (budgetsObj && Object.keys(budgetsObj).length) {
      // cada chave = n√∫mero da semana (ex.: "47", "48", "49")
      Object.entries(budgetsObj).forEach(([weekKey, dec]) => {
        const wk = String(weekKey);
        if (!weeksSet.has(wk)) return; // s√≥ semanas presentes no gr√°fico

        // se houver filtro selectWeek, isso j√° est√° reflectido em weeks/consumedPerWeekSec
        budgetPerWeek[wk] = (budgetPerWeek[wk] || 0) + (dec || 0);
      });
    } else if (typeof plan.budget === 'number') {
      // fallback: estrutura antiga (um √∫nico budget por task)
      // distribui apenas pelas semanas em que a task aparece nos dados vis√≠veis
      const taskWeeks = new Set(
        dashboardData
          .filter(e => e.task === tsk)
          .map(e => String(e.week))
      );
      taskWeeks.forEach(wk => {
        if (!weeksSet.has(wk)) return;
        budgetPerWeek[wk] = (budgetPerWeek[wk] || 0) + plan.budget;
      });
    }
  });

  // soma total (s√≥ semanas que realmente aparecem no gr√°fico)
  const totalHours = weeks.reduce(
    (sum, wk) => sum + (budgetPerWeek[String(wk)] || 0),
    0
  );

  return { budgetPerWeek, totalHours };
}

// 3. Calcula Budget Total (todas as tasks) e Budget (Tasks Vis√≠veis)
const visibleTasksSet = new Set(dashboardData.map(e => e.task));

const {
  budgetPerWeek : budgetPerWeekAll,
  totalHours    : totalBudgetHours
} = accumulateBudgetHours(/* todas as tasks */);

const {
  budgetPerWeek : budgetPerWeekVisible,
  totalHours    : budgetVisibleHours
} = accumulateBudgetHours(tsk => visibleTasksSet.has(tsk));

// ‚úÖ NOVO: se houver filtros na HOME que estreitam as tasks,
// for√ßamos Budget = "Tasks Vis√≠veis" para n√£o misturar tasks no gr√°fico/KPIs.
const homeTaskFilter     = (document.getElementById('taskFilter')?.value || '').trim();
const homeLabourFilter   = (document.getElementById('labourAccountFilter')?.value || '').trim();
const homeEmployeeFilter = (document.getElementById('employeeFilter')?.value || '').trim();
const homeTypeFilter     = (document.getElementById('typeFilter')?.value || '').trim();
const homeDateFilter     = (document.getElementById('dateFilter')?.value || '').trim();
const homePayCodeSingle  = (document.getElementById('payCodeFilter')?.value || '').trim();
const homePayCodeMulti   = (window.selectedPayCodes && window.selectedPayCodes.size > 0);

// ‚ö†Ô∏è estes filtros normalmente estreitam ‚Äúquais tasks entram‚Äù
const forceBudgetVisible =
  !!homeTaskFilter ||
  !!homeLabourFilter ||
  !!homeEmployeeFilter ||
  !!homeTypeFilter ||
  !!homeDateFilter ||
  !!homePayCodeSingle ||
  !!homePayCodeMulti;

// ‚úÖ modo efetivo (respeita o toggle, mas filtros for√ßam Tasks)
const showBudgetTotalEffective = showBudgetTotal && !forceBudgetVisible;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4. KPI ‚ÄúBudget Total / Budget (Tasks)‚Äù
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const hoursToShow     = showBudgetTotalEffective ? totalBudgetHours : budgetVisibleHours;
const budgetBaseHours = hoursToShow; // baseline √∫nico (mas agora consistente com filtros)

const kpiBudgetTotalEl = document.getElementById('kpiBudgetTotal');
const kpiBudgetLabelEl = document.getElementById('kpiBudgetLabel');

if (budgetBaseHours === 0) {
  kpiBudgetTotalEl.textContent = '‚Äî';
  kpiBudgetTotalEl.style.color = '#888';
} else {
  kpiBudgetTotalEl.textContent = formatTimeHHMM(budgetBaseHours * 3600);
  kpiBudgetTotalEl.style.color = showBudgetTotalEffective ? '#004d99' : '#26a269';
}

kpiBudgetLabelEl.textContent = showBudgetTotalEffective
  ? 'Budget Total'
  : 'Budget (Tasks)';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 5. KPI ‚ÄúBudget Remaining‚Äù
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const budgetRemainingSec = budgetBaseHours * 3600 - totalConsumedSec;
const kpiBudgetEl        = document.getElementById('kpiBudget');

if (budgetBaseHours === 0) {
  kpiBudgetEl.textContent = '‚Äî';
  kpiBudgetEl.style.color = '#888';
} else {
  const arrow   = budgetRemainingSec >= 0 ? '‚ñ≤ ' : '‚ñº ';
  const absTime = formatTimeHHMM(Math.abs(budgetRemainingSec));
  kpiBudgetEl.textContent = arrow + absTime;
  kpiBudgetEl.style.color = budgetRemainingSec >= 0 ? '#26a269' : '#c1121f';
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 6. KPI ‚ÄúBudget Utilization‚Äù
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('kpiUtil').previousElementSibling.textContent = 'Budget Utilization';

const budgetUtilPct = budgetBaseHours > 0
  ? (totalConsumedSec / (budgetBaseHours * 3600)) * 100
  : 0;

const utilEl = document.getElementById('kpiUtil');
utilEl.textContent = budgetUtilPct.toFixed(2) + '%';
utilEl.style.color = budgetUtilPct <= 100 ? 'green' : 'red';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 7. Trend Chart (Consumed √ó Planned √ó Budget)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const budgetData = showBudgetTotalEffective
  ? weeks.map(w => budgetPerWeekAll[String(w)] || 0)
  : weeks.map(w => budgetPerWeekVisible[String(w)] || 0);


const trendCtx   = document.getElementById('trendChart').getContext('2d');


window.trendChartObj = new Chart(trendCtx, {
  type : 'bar',
  data : {
    labels   : weeks.map(w => 'W' + w),
    datasets : [
      {
        label           : 'Consumed',
        data            : weeks.map(w => consumedPerWeekSec[w] / 3600),
        backgroundColor : '#007acc'
      },
      {
        label           : 'Planned',
        data            : weeks.map(w => (plannedPerWeekSec[w] || 0) / 3600),
        backgroundColor : '#26a269'
      },
      {
        label           : 'Budget',
        data            : budgetData,
        backgroundColor : '#f5b041',
        borderColor     : '#d68910',
        borderWidth     : 1
      }
    ]
  },
  options : {
    responsive          : true,
    maintainAspectRatio : false,
    scales : {
      x : { title : { display : true, text : 'Week' } },
      y : {
        beginAtZero : true,
        title       : { display : true, text : 'Hours' },
        ticks       : {
          callback : v => {
            const sec = Math.round(v * 3600);
            const hh  = String(Math.floor(sec / 3600)).padStart(2,'0');
            const mm  = String(Math.floor((sec % 3600) / 60)).padStart(2,'0');
            return `${hh}:${mm}`;
          }
        }
      }
    },
    plugins : {
      tooltip : {
        callbacks : {
          label : ctx => {
            const sec = Math.round(ctx.parsed.y * 3600);
            const hh  = String(Math.floor(sec / 3600)).padStart(2,'0');
            const mm  = String(Math.floor((sec % 3600) / 60)).padStart(2,'0');
            return `${ctx.dataset.label}: ${hh}:${mm}`;
          }
        }
      },
      datalabels : {
  display : true,
  anchor  : 'end',   // usa o topo da barra
  align   : 'end',   // alinha bem no limite
  offset  : -5,      // -2 px gruda; ajuste se quiser 0 ou -4
  clamp   : true,    // impede sair do canvas
  font    : { size: 10 },
  color   : '#5c5c5c',
  formatter(value) {           // decimal ‚Üí HH:MM
    const sec = Math.round(value * 3600);
    const hh  = String(Math.floor(sec / 3600)).padStart(2,'0');
    const mm  = String(Math.floor((sec % 3600) / 60)).padStart(2,'0');
    return `${hh}:${mm}`;
  }
}

    }
  },
  plugins : [ ChartDataLabels ]
});




   // dentro do renderDashboard()
if (window.deptChartObj) window.deptChartObj.destroy();
const deptKeys = Object.keys(deptTotalsSec);
const deptCtx = document.getElementById('deptChart').getContext('2d');
window.deptChartObj = new Chart(deptCtx, {
  type: 'bar',
  data: {
    labels: deptKeys,
    datasets: [{
      label: 'Consumed',
      data: deptKeys.map(k => deptTotalsSec[k] / 3600)
    }]
  },
  options: {
    indexAxis: 'y',
    responsive: true,
    maintainAspectRatio: false,
    scales: {
      x: {
        beginAtZero: true,
        ticks: {
          callback: v => {
            const sec = Math.round(v * 3600);
            const hh = String(Math.floor(sec / 3600)).padStart(2, '0');
            const mm = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
            return `${hh}:${mm}`;
          }
        }
      }
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          label: ctx => {
            const hoursDecimal = ctx.parsed.x;
            const totalSec = Math.round(hoursDecimal * 3600);
            const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
            const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
            return `Consumed: ${hh}:${mm}`;
          }
        }
      },
      datalabels: {
        display: true,
        anchor: 'center',
        align: 'center',
        rotation: 0,
        formatter: value => {
          const totalSec = Math.round(value * 3600);
          const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
          const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
          return `${hh}:${mm}`;
        },
        font: { size: 10 },    // peso regular (default)
        color: '#474747'
      }
    }
  },
  plugins: [ ChartDataLabels ]
});


    if (window.tasksChartObj) window.tasksChartObj.destroy();
    const sortedEntries = Object.entries(taskTotalsSec).sort((a, b) => b[1] - a[1]);
    const top5 = sortedEntries.slice(0, 5);
    const otherSec = sortedEntries.slice(5).reduce((s, [, sec]) => s + sec, 0);
    const labelsPie = top5.map(([t]) => t);
    const dataPie   = top5.map(([, sec]) => sec / 3600);
    if (otherSec > 0) {
      labelsPie.push('Other');
      dataPie.push(otherSec / 3600);
    }
    const taskCtx = document.getElementById('tasksChart').getContext('2d');
    window.tasksChartObj = new Chart(taskCtx, {
      type: 'pie',
      data: {
        labels: labelsPie,
        datasets: [{ data: dataPie }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'bottom' },
          tooltip: {
            callbacks: {
              label: ctx => {
                const v = ctx.parsed;
                const totalSec = Math.round(v * 3600);
                const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
                const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
                return `${ctx.label}: ${hh}:${mm}`;
              }
            }
          }
        }
      }
    });

    const allTasks = Object.entries(taskTotalsSec).sort((a, b) => b[1] - a[1]);
    const topN = 33;
    const topTasksBar = allTasks.slice(0, topN);
    const otherSecBar = allTasks.slice(topN).reduce((s, [, sec]) => s + sec, 0);
    const barLabels = topTasksBar.map(([t]) => t);
    const barData   = topTasksBar.map(([, sec]) => sec / 3600);
    if (otherSecBar > 0) {
      barLabels.push('Other');
      barData.push(otherSecBar / 3600);
    }

    if (window.tasksBarChartObj) window.tasksBarChartObj.destroy();
    const barCtx = document.getElementById('tasksBarChart').getContext('2d');
    window.tasksBarChartObj = new Chart(barCtx, {
      type: 'bar',
      data: {
        labels: barLabels,
        datasets: [{ label: 'Hours', data: barData }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            beginAtZero: true,
            ticks: {
              autoSkip: false,
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'Hours'
            },
            ticks: {
              callback: v => {
                const totalSec = Math.round(v * 3600);
                const hh = String(Math.floor(totalSec / 3600)).padStart(2, '0');
                const mm = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
                return `${hh}:${mm}`;
              }
            }
          }
        },
        plugins: {
          legend: { display: true, position: 'top' },
          tooltip: {
            callbacks: {
              label: ctx => {
                const sec = Math.round(ctx.parsed.y * 3600);
                const hh  = String(Math.floor(sec / 3600)).padStart(2, '0');
                const mm  = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
                return `${ctx.dataset.label}: ${hh}:${mm}`;
              }
            }
          },
          datalabels: {
            display: false,
            anchor: 'end',
            align: 'top',
            formatter: value => {
              const totalSec = Math.round(value * 3600);
              const hh       = String(Math.floor(totalSec / 3600)).padStart(2, '0');
              const mm       = String(Math.floor((totalSec % 3600) / 60)).padStart(2, '0');
              return `${hh}:${mm}`;
            },
            font: {
              size: 10
            }
          }
        }
      },
      plugins: [ChartDataLabels]
    });

    if (!toggleListenerAdded) {
      document.getElementById('toggleValues').addEventListener('click', () => {
        showValues = !showValues;
        window.tasksBarChartObj.options.plugins.datalabels.display = showValues;
        window.tasksBarChartObj.update();
      });
      toggleListenerAdded = true;
    }
  };

// 1) listener do codeFilter (delegando para window.filterTable ‚Äî respeita o hook)
(function bindCodeFilter() {
  const el = document.getElementById('codeFilter');
  if (!el) return;

  // ‚úÖ anti-duplica√ß√£o
  if (el.dataset.boundCodeFilter === '1') return;
  el.dataset.boundCodeFilter = '1';

  el.addEventListener('change', () => {
    // ‚úÖ chama o hook se existir; sen√£o usa a fun√ß√£o normal
    if (typeof window.filterTable === 'function') {
      window.filterTable();
    } else if (typeof filterTable === 'function') {
      filterTable();
    }
  });
})();
   
function syncCodeFilterDisabledState(dep) {
  const codeFilterEl = document.getElementById('codeFilter');
  if (!codeFilterEl) return;

  // 1) reativa tudo sempre (evita ficar preso)
  Array.from(codeFilterEl.options).forEach(opt => { opt.disabled = false; });

  // 2) regra: em Break desativa apenas OT (como estavas a querer)
  const isBreak = (dep === 'Break');

  if (isBreak) {
    Array.from(codeFilterEl.options).forEach(opt => {
      const v = String(opt.value || '').toLowerCase();
      const t = String(opt.textContent || '').toLowerCase();

      const isOT =
        v === 'overtime' || v === 'ot' ||
        t.includes('over time') || t.includes('overtime') ||
        t.includes('ot > 40');

      if (isOT) opt.disabled = true;
    });

    // se estava selecionado OT, volta para ALL
    const selectedOpt = codeFilterEl.options[codeFilterEl.selectedIndex];
    if (selectedOpt && selectedOpt.disabled) {
      codeFilterEl.value = '';
      window.currentCodeFilter = '';
    }

    codeFilterEl.title = 'OT > 40h is disabled while Break is selected.';
  } else {
    codeFilterEl.title = '';
  }
}


// 2) Defini√ß√£o da fun√ß√£o filterByDepartment
function filterByDepartment(dep) {
  currentDepartmentFilter = dep;
  window.currentDepartmentFilter = dep; // ‚úÖ garante que √© global e consistente

  if (typeof syncCodeFilterDisabledState === 'function') {
    syncCodeFilterDisabledState(dep);
  }

  if (typeof window.filterTable === 'function') {
    window.filterTable();
  } else {
    filterTable();
  }

  if (document.getElementById('dashboard')?.classList.contains('active')) {
    renderDashboard();
  }

  // ‚úÖ chama no pr√≥ximo tick para garantir que o DOM/cache j√° atualizou
  setTimeout(() => {
    try { if (typeof updateOvertimeLabel === 'function') updateOvertimeLabel(); } catch (e) {}
    try { if (typeof updateMissingTaskCount === 'function') updateMissingTaskCount(); } catch (e) {}
  }, 0);
}



// 3) listeners para os bot√µes do slicer que chamam filterByDepartment
function setActiveDepartmentButton(activeBtn) {
  const btns = document.querySelectorAll('#slicer button[data-department]');
  btns.forEach(b => {
    b.classList.remove('active');
    b.setAttribute('aria-pressed', 'false');
  });

  if (activeBtn) {
    activeBtn.classList.add('active');
    activeBtn.setAttribute('aria-pressed', 'true');
  }
}

document.querySelectorAll('#slicer button[data-department]').forEach(button => {
  button.addEventListener('click', event => {
    const btn = event.currentTarget;
    const department = btn.getAttribute('data-department');

    setActiveDepartmentButton(btn);
    filterByDepartment(department);
  });
});


      function showPasswordModal() {
        document.getElementById('passwordModal').style.display = 'flex';
        document.getElementById('passwordInput').focus();
      }
      function closeModal() {
        document.getElementById('passwordModal').style.display = 'none';
        document.getElementById('errorMessage').style.display = 'none';
        document.getElementById('passwordInput').value = '';
      }
      function showDateModal() {
        document.getElementById('dateModal').style.display = 'flex';
        document.getElementById('clearStartDate').focus();
      }
      function closeDateModal() {
        document.getElementById('dateModal').style.display = 'none';
        document.getElementById('clearStartDate').value = '';
        document.getElementById('clearEndDate').value = '';
      }
      function checkPassword() {
        const passwordInput = document.getElementById('passwordInput').value;
        const correctPassword = "abcd@1234";
        if (passwordInput === correctPassword) {
          closeModal();
          showDateModal();
        } else {
          document.getElementById('errorMessage').style.display = 'block';
        }
      }
      async function clearHistoryByDate() {
  const startDate = new Date(document.getElementById('clearStartDate').value);
  const endDate   = new Date(document.getElementById('clearEndDate').value);

  if (isNaN(startDate) || isNaN(endDate)) {
    alert('Please enter valid start and end dates.');
    return;
  }

  // ‚úÖ deixa o endDate inclusivo (at√© 23:59:59)
  endDate.setHours(23, 59, 59, 999);

  // filtra em mem√≥ria
  storedData = storedData.filter(entry => {
    const entryDate = new Date(String(entry.date || '').split('/').reverse().join('-'));
    return entryDate < startDate || entryDate > endDate;
  });

  try {
    // ‚úÖ regrava o dataset filtrado no IDB
    await idbPutCsvRows(storedData, { replace: true });

    // ‚úÖ modo IDB: garante flag e remove csvData
    localStorage.removeItem('csvData');
    localStorage.setItem('hasIDBData', '1');

  } catch (e) {
    console.warn('IDB save failed ‚Äî fallback to localStorage:', e);

    // fallback: volta a usar localStorage e desliga o modo IDB
    localStorage.setItem('csvData', JSON.stringify(storedData));
    localStorage.removeItem('hasIDBData');
  }

  closeDateModal();
  alert("Selected history cleared.");

  // ‚úÖ zera UI e depois redesenha com o que sobrou
  clearData();

  const aggregatedData = aggregateData(storedData);
  displayResults(aggregatedData);
  updateTotalHours(aggregatedData);
  updateFilteredTotals(aggregatedData);
  updateResult();

  // ‚úÖ refresca filtros/cache + headcount
  populateDropdowns();
  populatePayCodeDropdown();
  populateTypeDropdown();

  filterTable();
  updateHeadcount();

  // (opcional, se usas estes KPIs sempre)
  try { if (typeof updateMissingTaskCount === 'function') updateMissingTaskCount(); } catch(e) {}
  try { if (typeof updateOvertimeLabel === 'function') updateOvertimeLabel(); } catch(e) {}

  // (opcional, se queres manter dashboard/overview alinhados)
  try { if (typeof displayBudgetOverview === 'function') displayBudgetOverview(); } catch(e) {}
  try {
    if (document.getElementById('dashboard')?.classList.contains('active')) {
      renderDashboard();
    }
  } catch(e) {}
}

     function updateHeadcount() {
  const uniqueEmployeeDays = new Set(); // mant√©m (Employee|Date)
  const uniquePeople = new Set();       // pessoas √∫nicas

  // ‚úÖ 1) Fonte principal: cache das linhas vis√≠veis (mais fi√°vel)
  const cache = (window.filteredRowsCache && Array.isArray(window.filteredRowsCache))
    ? window.filteredRowsCache
    : null;

  if (cache && cache.length > 0) {
    cache.forEach(r => {
      const employeeName = String(r.employee || '').trim();
      const dateText     = String(r.date || '').trim();
      const personNumber = String(r.personNumber || '').trim();

      if (!employeeName || !dateText) return;

      // 1) Presen√ßas/dias
      uniqueEmployeeDays.add(`${employeeName}|${dateText}`);

      // 2) Pessoas √∫nicas (prefer√™ncia: personNumber)
      const key = personNumber || employeeName.toLowerCase().replace(/\s+/g, ' ').trim();
      if (key) uniquePeople.add(key);
    });

  } else {
    // ‚úÖ 2) Fallback: se por algum motivo n√£o existir cache, usa a tabela como antes
    const rows = document.querySelectorAll("#resultTable tbody tr");

    rows.forEach(row => {
      if (getComputedStyle(row).display === 'none') return;

      const cells = row.cells;
      if (!cells || cells.length < 5) return; // ignora linhas tipo "No results found"

      const employeeName = (cells[0].textContent || '').trim();
      const dateText     = (cells[4].textContent || '').trim();
      const personNumber = (cells[2].textContent || '').trim();

      if (!employeeName || !dateText) return;

      uniqueEmployeeDays.add(`${employeeName}|${dateText}`);

      const key = personNumber || employeeName.toLowerCase().replace(/\s+/g, ' ').trim();
      if (key) uniquePeople.add(key);
    });
  }

  const headcountSpan = document.getElementById("headcountCount");
  if (!headcountSpan) return;

  const totalDays   = uniqueEmployeeDays.size;
  const totalUnique = uniquePeople.size;

  headcountSpan.textContent = `${totalDays} / ${totalUnique}`;
  headcountSpan.title = `Employee-days: ${totalDays} | Unique people: ${totalUnique}`;

  headcountSpan.style.fontWeight = "bold";
  headcountSpan.style.fontSize   = "1.3em";
  headcountSpan.style.color      = (totalDays === 0) ? "#ff8c00" : "#c1121f";
}

  // ‚úÖ PDF Dashboard: listener √∫nico + anti-duplica√ß√£o (evita duplo download)
function bindDownloadPdfDashboard() {
  const btn = document.getElementById('downloadPdfDashboard');
  if (!btn) return;

  // ‚úÖ anti-duplica√ß√£o
  if (btn.dataset.boundPdfDash === '1') return;
  btn.dataset.boundPdfDash = '1';

  btn.addEventListener('click', function () {
    const dashboard = document.getElementById('dashboard');
    if (!dashboard) return;

    this.style.visibility = 'hidden';

    const oldDisplay = window.tasksBarChartObj?.options?.plugins?.datalabels?.display;

    if (window.tasksBarChartObj) {
      window.tasksBarChartObj.options.plugins.datalabels.display = true;
      window.tasksBarChartObj.update();
    }

    dashboard.classList.add('pdf-scale');
    setTimeout(() => {
      html2pdf()
        .set({
          margin: 0.1,
          filename: 'dashboard_report.pdf',
          image: { type: 'jpeg', quality: 0.98 },
          html2canvas: { scale: 2, useCORS: true },
          jsPDF: { unit: 'in', format: 'a4', orientation: 'landscape' }
        })
        .from(dashboard)
        .save()
        .then(() => {
          dashboard.classList.remove('pdf-scale');
          if (window.tasksBarChartObj && oldDisplay !== undefined) {
            window.tasksBarChartObj.options.plugins.datalabels.display = oldDisplay;
            window.tasksBarChartObj.update();
          }
          this.style.visibility = 'visible';
        });
    }, 350);
  });
}

      // Modal Planned Hours
      // Modal Planned Hours (semana + tabela 7√óN)
function getFirstSundayOfYear(year) {
  const d = new Date(year, 0, 1);
  const offset = (7 - d.getDay()) % 7; 
  return new Date(year, 0, 1 + offset);
}

// ‚úÖ NOVO helper (coloca aqui)
// ‚úÖ ANO AUTOM√ÅTICO PARA A SEMANA DO MODAL
function getYearForWeek(weekNum) {
  // 1) Melhor caso: usa storedData (se houver entradas dessa semana)
  const matches = (storedData || [])
    .filter(e => String(e.week) === String(weekNum) && e.date)
    .sort((a, b) => {
      const [da, ma, ya] = a.date.split('/').map(Number);
      const [db, mb, yb] = b.date.split('/').map(Number);
      return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
    });

  if (matches.length) {
    const [, , y] = matches[0].date.split('/').map(Number);
    return y; // ‚úÖ ano real vindo dos dados
  }

  // 2) Fallback autom√°tico: decide pelo contexto do calend√°rio
  const now = new Date();
  const currentYear  = now.getFullYear();
  const currentMonth = now.getMonth(); // 0=Jan ... 11=Dec

  // Se estamos em Janeiro e o user escolhe semana alta (52/53),
  // provavelmente √© do ano anterior.
  if (currentMonth === 0 && weekNum >= 52) return currentYear - 1;

  // Se estamos em Dezembro e o user escolhe semana baixa (1/2),
  // provavelmente √© do ano seguinte.
  if (currentMonth === 11 && weekNum <= 2) return currentYear + 1;

  // Caso normal: ano corrente
  return currentYear;
}

function getWeekRange(year, weekNumber) {
  const firstSunday = getFirstSundayOfYear(year);
  const start = new Date(firstSunday.getTime() + (weekNumber - 1) * 7 * 86400e3);
  const end   = new Date(start.getTime()      + 6 * 86400e3);
  return [start, end];
}

document.getElementById('openPlannedHoursModal').addEventListener('click', function() {
  // 1) Limpa tabela
  const table = document.getElementById('weeklyPlannedTable');
  const thead = table.querySelector('thead tr');
  const tbody = table.querySelector('tbody');
  thead.innerHTML = '<th style="border:1px solid #ddd; padding:6px;">Task</th>';
  tbody.innerHTML = '';

  // 2) Pega o n√∫mero da semana (prioridade: digitado ‚ûú salvo ‚ûú semana atual)
  const inpWeek   = document.getElementById('modalWeekNumber');
  let weekNum     = parseInt(inpWeek.value, 10);
  const savedWeek = parseInt(localStorage.getItem('plannedModalWeek'), 10);
  const today     = new Date();

  if (isNaN(weekNum) || weekNum < 1 || weekNum > 53) {
    if (!isNaN(savedWeek) && savedWeek >= 1 && savedWeek <= 53) {
      weekNum = savedWeek;
    } else {
      weekNum = getCustomWeekNumber(today);
    }
    inpWeek.value = weekNum;
  }
  localStorage.setItem('plannedModalWeek', weekNum);


  // 3) Calcula intervalo de datas domingo‚Üís√°bado
  const yearForWeek = getYearForWeek(weekNum);
const [startDate, endDate] = getWeekRange(yearForWeek, weekNum);

  const dates = [];
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    dates.push(new Date(d));
  }

  // 4) Monta cabe√ßalho de 7 dias
  dates.forEach(dt => {
    const dd  = String(dt.getDate()).padStart(2, '0');
    const mm  = String(dt.getMonth() + 1).padStart(2, '0');
    const lbl = `${dd}/${mm}`;
    const th  = document.createElement('th');
    th.style       = 'border:1px solid #ddd; padding:6px; text-align:center;';
    th.textContent = lbl;
    thead.appendChild(th);
  });

  // ‚îÄ‚îÄ NOVO: Coluna Budget ao final do cabe√ßalho ‚îÄ‚îÄ
const thBudget = document.createElement('th');
thBudget.style       = 'border:1px solid #ddd; padding:6px; text-align:center;';
thBudget.textContent = 'Budget';
thead.appendChild(thBudget);

// 5) Filtra tasks e gera linhas
const filterValue = document.getElementById('setModalTaskFilter').value.toLowerCase();
const tmpTasks    = new Set();
Object.entries(taskMapping).forEach(([code, name]) => tmpTasks.add(`${name}-${code.slice(-4)}`));
Object.keys(plannedHoursTracker).forEach(t => tmpTasks.add(t));
storedData.forEach(e => tmpTasks.add(e.task));

const pickOnePerBase = new Map();
tmpTasks.forEach(t => {
  const base = t.replace(/-\d{4}$/, '');
  if (!pickOnePerBase.has(base) || /-\d{4}$/.test(t)) {
    pickOnePerBase.set(base, t);
  }
});

const uniqueTasks = Array.from(pickOnePerBase.values())
  .filter(t => t.toLowerCase().includes(filterValue))
  .sort((a, b) => {
    const pA = a.charAt(0), pB = b.charAt(0);
    if (pA !== pB) return pA === 'E' ? -1 : 1;
    const nA = parseInt((a.match(/\d{4}$/) || [])[0], 10) || Infinity;
    const nB = parseInt((b.match(/\d{4}$/) || [])[0], 10) || Infinity;
    return nA - nB;
  });

uniqueTasks.forEach(tsk => {
  const tr = document.createElement('tr');
  tr.innerHTML = `<td style="border:1px solid #ddd; padding:6px;">${tsk}</td>`;

// inputs HH:MM para cada dia
dates.forEach(dt => {
  const key      = dt.toLocaleDateString('en-GB');
  const existing = plannedHoursTracker[tsk]?.[key];
  const inp      = document.createElement('input');
  inp.type        = 'text';
  inp.placeholder = 'HH:MM';
  inp.value       = existing != null
    ? (() => {
        const h = Math.floor(existing);
        const m = Math.round((existing - h) * 60);
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
      })()
    : '';
  inp.dataset.task = tsk;
  inp.dataset.date = key;
  inp.style        = 'width:60px; padding:4px; margin:2px;';

  // ‚Üê‚Äì VALIDA√á√ÉO: for√ßa refocar se formato inv√°lido
 
  inp.addEventListener('keydown', e => {
    if (e.key === 'Tab' || e.key === 'Enter') {
      if (!validateTimeInput(inp)) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  });

  if (existing != null) {
    inp.readOnly = true;
    inp.addEventListener('focus', () => {
      alert(
        'These hours have already been set. To modify them, please use the Edit Hours function and enter the security code.'
      );
      inp.blur();
    });
  }

  const td = document.createElement('td');
  td.style = 'border:1px solid #ddd; padding:0; text-align:center;';
  td.appendChild(inp);
  tr.appendChild(td);
});

 // ‚îÄ‚îÄ NOVO: cell do Budget semanal (agora por semana) ‚îÄ‚îÄ
const budgetInp = document.createElement('input');
budgetInp.type        = 'text';
budgetInp.placeholder = 'HH:MM';

// l√™ o budget s√≥ desta semana
const existingBudget = getBudgetForTaskWeek(tsk, weekNum);
if (existingBudget != null) {
  const h = Math.floor(existingBudget);
  const m = Math.round((existingBudget - h) * 60);
  budgetInp.value = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
}

// ‚Üê‚Äì VALIDA√á√ÉO: for√ßa refocar se formato inv√°lido
budgetInp.addEventListener('keydown', e => {
  if (e.key === 'Tab' || e.key === 'Enter') {
    if (!validateTimeInput(budgetInp)) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
});

budgetInp.dataset.task       = tsk;
budgetInp.dataset.weekBudget = 'true';
budgetInp.style              = 'width:60px; padding:4px; margin:2px;';

const tdBudget = document.createElement('td');
tdBudget.style = 'border:1px solid #ddd; padding:0; text-align:center;';
tdBudget.appendChild(budgetInp);
tr.appendChild(tdBudget);
  tbody.appendChild(tr);
});


  // 6) Exibe modal
  document.getElementById('plannedHoursModal').style.display = 'flex';
});


// ‚îÄ‚îÄ‚îÄ Modal Planned Hours: tabela 7√óN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function populateWeeklyPlannedTable() {
  const table = document.getElementById('weeklyPlannedTable');
  const thead = table.querySelector('thead tr');
  const tbody = table.querySelector('tbody');
  thead.innerHTML = '<th style="border:1px solid #ddd; padding:6px;">Task</th>';
  tbody.innerHTML = '';

  // Descobre a semana selecionada
  const today     = new Date();
  const weekInput = parseInt(document.getElementById('modalWeekNumber').value, 10);
  const weekNum   = (!isNaN(weekInput) && weekInput >= 1 && weekInput <= 53)
                     ? weekInput
                     : getCustomWeekNumber(today);

  // Gera as 7 datas domingo‚Üís√°bado
  const yearForWeek = getYearForWeek(weekNum);
const [startDate, endDate] = getWeekRange(yearForWeek, weekNum);

  const dates = [];
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    dates.push(new Date(d));
  }

  // Cabe√ßalho de dias
  dates.forEach(dt => {
    const dd  = String(dt.getDate()).padStart(2, '0');
    const mm  = String(dt.getMonth() + 1).padStart(2, '0');
    const th  = document.createElement('th');
    th.style       = 'border:1px solid #ddd; padding:6px; text-align:center;';
    th.textContent = `${dd}/${mm}`;
    thead.appendChild(th);
  });

  // ‚îÄ‚îÄ NOVO: adiciona coluna Budget ‚îÄ‚îÄ
  const thBudget = document.createElement('th');
  thBudget.style       = 'border:1px solid #ddd; padding:6px; text-align:center;';
  thBudget.textContent = 'Budget';
  thead.appendChild(thBudget);

  // Lista √∫nica de tasks (mesma l√≥gica de antes)‚Ä¶
  const filterValue = document.getElementById('setModalTaskFilter').value.toLowerCase();
  const tmpTasks    = new Set();
  Object.entries(taskMapping).forEach(([code, name]) => tmpTasks.add(`${name}-${code.slice(-4)}`));
  Object.keys(plannedHoursTracker).forEach(t => tmpTasks.add(t));
  storedData.forEach(e => tmpTasks.add(e.task));

  const pickOne = new Map();
  tmpTasks.forEach(t => {
    const base = t.replace(/-\d{4}$/, '');
    if (!pickOne.has(base) || /-\d{4}$/.test(t)) pickOne.set(base, t);
  });

  const uniqueTasks = Array.from(pickOne.values())
    .filter(t => t.toLowerCase().includes(filterValue))
    .sort((a,b) => {
      const pA = a.charAt(0), pB = b.charAt(0);
      if (pA !== pB) return pA === 'E' ? -1 : 1;
      const nA = parseInt((a.match(/\d{4}$/)||[])[0],10)||Infinity;
      const nB = parseInt((b.match(/\d{4}$/)||[])[0],10)||Infinity;
      return nA - nB;
    });

  // Monta cada linha
  uniqueTasks.forEach(tsk => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td style="border:1px solid #ddd; padding:6px;">${tsk}</td>`;


// Para cada data da semana cria uma c√©lula com <input>
dates.forEach(dt => {
  const key      = dt.toLocaleDateString('en-GB');      // ex.: 14/05/2025
  const existing = plannedHoursTracker[tsk]?.[key];     // valor salvo (decimal)

  /* 1) Cria o input de texto */
  const inp = document.createElement('input');
  inp.type        = 'text';
  inp.placeholder = 'HH:MM';

  // ‚Üí converte decimal ‚Üí "HH:MM" se j√° houver valor gravado
  inp.value = existing != null
    ? (() => {
        const h = Math.floor(existing);            // parte inteira = horas
        const m = Math.round((existing - h) * 60); // resto ‚Üí minutos
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
      })()
    : '';

  inp.dataset.task = tsk;
  inp.dataset.date = key;
  inp.style        = 'width:60px; padding:4px; margin:2px;';

  /* ‚îÄ‚îÄ LISTENERS DE VALIDA√á√ÉO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  // 1. Saiu do campo por clique ‚Üí valida
  inp.addEventListener('blur', () => {
    validateTimeInput(inp);      // alerta + mant√©m foco se inv√°lido
  });

  // 2. Tenta sair com Tab ou Enter ‚Üí bloqueia se inv√°lido
  inp.addEventListener('keydown', e => {
    if (e.key === 'Tab' || e.key === 'Enter') {
      const ok = validateTimeInput(inp);
      if (!ok) {
        e.preventDefault();      // impede avan√ßar
        e.stopPropagation();
      }
    }
  });

  /* ‚îÄ‚îÄ Se j√° existia valor, impede edi√ß√£o direta ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  if (existing != null) {
    inp.readOnly = true;
    inp.addEventListener('focus', () => {
      alert(
        'These hours have already been set. To modify them, ' +
        'please use the Edit Hours function and enter the security code.'
      );
      inp.blur();
    });
  }

  /* 2) Adiciona o input dentro da c√©lula <td> */
  const td = document.createElement('td');
  td.style = 'border:1px solid #ddd; padding:0; text-align:center;';
  td.appendChild(inp);
  tr.appendChild(td);
});

    // ‚îÄ‚îÄ NOVO: input Budget no fim da linha (por semana) ‚îÄ‚îÄ
const budgetInp = document.createElement('input');
budgetInp.type        = 'text';
budgetInp.placeholder = 'HH:MM';

// usa a mesma weekNum calculada no topo da fun√ß√£o
const exBud = getBudgetForTaskWeek(tsk, weekNum);
if (exBud != null) {
  const h = Math.floor(exBud);
  const m = Math.round((exBud - h) * 60);
  budgetInp.value = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
}


budgetInp.dataset.task       = tsk;
budgetInp.dataset.weekBudget = 'true';
budgetInp.style              = 'width:60px; padding:4px; margin:2px;';


const tdBud = document.createElement('td');
tdBud.style = 'border:1px solid #ddd; padding:0; text-align:center;';
tdBud.appendChild(budgetInp);
tr.appendChild(tdBud);
tbody.appendChild(tr);

  });
}



// 6) Listeners leves reaproveitando a fun√ß√£o
document.getElementById('setModalTaskFilter')
  .addEventListener('input', populateWeeklyPlannedTable);

(function bindModalWeekNumber() {
  const el = document.getElementById('modalWeekNumber');
  if (!el) return;

  el.addEventListener('change', () => {
    const v = parseInt(el.value, 10);
    if (!isNaN(v) && v >= 1 && v <= 53) {
      localStorage.setItem('plannedModalWeek', v);
    }
    populateWeeklyPlannedTable();
  });
})();     
      // 1) Cancel: fecha o modal da mesma forma
document.getElementById('cancelPlannedHours').addEventListener('click', function() {
  document.getElementById('plannedHoursModal').style.display = 'none';
});

document.getElementById('confirmPlannedHours')
  .addEventListener('click', function () {

    /* 0. Descobre a semana atual do modal */
    const today     = new Date();
    const weekInput = parseInt(document.getElementById('modalWeekNumber').value, 10);
    const weekNum   = (!isNaN(weekInput) && weekInput >= 1 && weekInput <= 53)
      ? weekInput
      : getCustomWeekNumber(today);

    /* 1. Coleta todos os inputs de hora da tabela */
    const inputs = document.querySelectorAll(
      '#weeklyPlannedTable tbody input[type="text"]'
    );

    /* 2. Valida√ß√£o ‚Äì se encontrar erro, cancela o salvamento */
    for (const inp of inputs) {
      const val = inp.value.trim();

      if (val === '') continue;               // campo vazio √© permitido

      if (!isValidHHMM(val)) {                // formato errado
        alert('There are invalid times. Use HH:MM (e.g., 07:30) or decimal hours (e.g., 7.5).');

        inp.focus();                          // leva usu√°rio ao erro
        return;                               // ‚õî aborta ‚Äì nada ser√° salvo
      }

      // normaliza o campo para HH:MM usando a fun√ß√£o nova
      const dec = convertHHMMToDecimal(val);
      inp.value = decimalToHHMM(dec);
    }

    /* 3. Convers√£o (HH:MM ou decimal) ‚Üí decimal e grava√ß√£o */
    inputs.forEach(inp => {
      const val  = inp.value.trim();
      const task = inp.dataset.task;
      plannedHoursTracker[task] = plannedHoursTracker[task] || {};

      // nada escrito ‚Üí limpa e segue
      if (!val) {
        if (inp.dataset.weekBudget === 'true') {
          // APAGA o budget s√≥ para ESTA semana
          setBudgetForTaskWeek(task, weekNum, null);
        } else {
          const date = inp.dataset.date;
          delete plannedHoursTracker[task][date];
        }
        return;
      }

      const dec = convertHHMMToDecimal(val);
      if (dec == null) return; // seguran√ßa extra (j√° validado antes)

      /* 3a. Coluna ‚ÄúBudget‚Äù (weekBudget) ‚Äì agora por semana */
      if (inp.dataset.weekBudget === 'true') {
        setBudgetForTaskWeek(task, weekNum, dec);   // guarda em horas decimais
        return;                                     // n√£o processa como dia
      }

      /* 3b. Colunas de dia da semana (di√°rias) */
      const date = inp.dataset.date;
      plannedHoursTracker[task][date] = dec;        // guarda em horas decimais
    });

    /* 4. Persiste, atualiza UI, fecha modal */
    localStorage.setItem(
      'plannedHoursTracker',
      JSON.stringify(plannedHoursTracker)
    );
    displayBudgetOverview();
    document.getElementById('plannedHoursModal').style.display = 'none';
  });


document.getElementById('openEditHoursModal').addEventListener('click', function() {
  document.getElementById('editHoursPasswordModal').style.display = 'flex';
  document.getElementById('editHoursPasswordInput').value = '';
  document.getElementById('editHoursErrorMessage').style.display = 'none';
});
      // clique em ‚ÄúOK‚Äù na modal de senha (Edit Hours)
document.getElementById('confirmEditHoursPasswordButton').addEventListener('click', function () {
  const userPassword = document.getElementById('editHoursPasswordInput').value;

  if (userPassword === 'abcd@1234') {
    // esconde a modal de senha
    document.getElementById('editHoursPasswordModal').style.display = 'none';

    /* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
       monta a lista de tasks filtrada
       ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
    const filterValue = document.getElementById('editModalTaskFilter').value.toLowerCase();

    // 1) tasks √∫nicas vindas dos dados
    const tasks = [...new Set(storedData.map(e => e.task))]
      // 2) aplica filtro de texto
      .filter(tsk => tsk.toLowerCase().includes(filterValue))
      // 3) ordena pelo c√≥digo num√©rico no final (-1234, -1404‚Ä¶)
      .sort(ordenarPorCodigo);                // ‚Üê usa a fun√ß√£o criada

    /* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
       preenche o <select> do modal
       ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
    const editModalTask = document.getElementById('editModalTask');
    editModalTask.innerHTML = '';

    if (tasks.length) {
      tasks.forEach(tsk => {
        const option       = document.createElement('option');
        option.value       = tsk;
        option.textContent = tsk;
        editModalTask.appendChild(option);
      });
      editModalTask.selectedIndex = 0;
    } else {
      const option       = document.createElement('option');
      option.value       = '';
      option.textContent = 'Select Task';
      editModalTask.appendChild(option);
    }

    // exibe a modal principal de edi√ß√£o
    document.getElementById('editHoursModal').style.display = 'flex';

  } else {
    // senha incorreta
    document.getElementById('editHoursErrorMessage').style.display = 'block';
  }
});

      document.getElementById('cancelEditHoursPasswordButton').addEventListener('click', function() {
        document.getElementById('editHoursPasswordModal').style.display = 'none';
      });
      document.getElementById('editModalTaskFilter').addEventListener('input', function() {
        let filterValue = this.value.toLowerCase();
        let tasks = [...new Set(storedData.map(entry => entry.task))];
        tasks = tasks.filter(tsk => tsk.toLowerCase().includes(filterValue));
        let editModalTask = document.getElementById('editModalTask');
        editModalTask.innerHTML = '';
        if (tasks.length > 0) {
          tasks.forEach(tsk => {
            let option = document.createElement('option');
            option.value = tsk;
            option.textContent = tsk;
            editModalTask.appendChild(option);
          });
          editModalTask.selectedIndex = 0;
        } else {
          let option = document.createElement('option');
          option.value = '';
          option.textContent = 'Select Task';
          editModalTask.appendChild(option);
        }
      });
      document.getElementById('cancelEditHours').addEventListener('click', function() {
        document.getElementById('editHoursModal').style.display = 'none';
      });
      document.getElementById('confirmEditHours').addEventListener('click', function() {
  let task = document.getElementById('editModalTask').value;
  let selectedDay = document.getElementById('editModalSelectedDay').value;
  let timeInputEl = document.getElementById('editModalDayPlanned');
  let timeInput = timeInputEl.value;

  let dayPlanned = convertHHMMToDecimal(timeInput);

  if (!task || !selectedDay || dayPlanned === null) {
    alert("Please fill in all fields with a valid time in HH:MM format.");
    return;
  }

  // 1) Guarda exatamente como hoje
  let selectedDayFormatted = new Date(selectedDay).toLocaleDateString('en-GB');
  plannedHoursTracker[task] = plannedHoursTracker[task] || {};
  plannedHoursTracker[task][selectedDayFormatted] = dayPlanned;

  localStorage.setItem('plannedHoursTracker', JSON.stringify(plannedHoursTracker));

  // 2) Atualiza a UI (igual ao comportamento atual)
  displayBudgetOverview();

  // 3) Pergunta se quer fazer mais ajustes
  const doMore = window.confirm(
    "Adjustment saved.\n\nDo you want to make more adjustments?"
  );

  if (doMore) {
    // ‚úÖ SIM: mant√©m o modal aberto e limpa o campo das horas
    timeInputEl.value = '';
    timeInputEl.focus();
    timeInputEl.select();
  } else {
    // ‚ùå N√ÉO: fecha o modal como hoje
    document.getElementById('editHoursModal').style.display = 'none';
  }
});

      document.getElementById('modalTaskFilter').addEventListener('input', function() {
        displayBudgetOverview();
      });

      document.querySelectorAll('.nav-tabs button').forEach(button => {
        button.addEventListener('click', (event) => {
          const tabName = event.target.getAttribute('data-tab');
          document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
          document.getElementById(tabName).classList.add('active');
          if (tabName === 'budgetTracker') {
            displayBudgetOverview();
          } else if (tabName === 'dashboard') {
            renderDashboard();
          }
        });
      });
/* =========================================================
   ‚úÖ NOVO: Colunas din√¢micas na Home Table
   - Worker Type (CORE: FT/PT do Employee Master | AGY: Type)
   - Supervisor   (CORE: Supervisor do Employee Master | AGY: Type)
   - Mant√©m layout: ellipsis e largura fixa
   ========================================================= */

// helper: achar √≠ndice de coluna pelo texto do header
function getColumnIndexByHeaderText(tableEl, headerNeedle) {
  if (!tableEl) return -1;

  const ths = tableEl.querySelectorAll('thead th');
  const needle = String(headerNeedle || '').toLowerCase();

  for (let i = 0; i < ths.length; i++) {
    const txt = String(ths[i].textContent || '').trim().toLowerCase();
    if (txt === needle || txt.includes(needle)) return i;
  }
  return -1;
}
// ‚úÖ NOVO: √≠ndice por header EXATO (evita "type" bater em "worker type")
function getColumnIndexByHeaderExactText(tableEl, headerExact) {
  if (!tableEl) return -1;

  const ths = tableEl.querySelectorAll('thead th');
  const needle = String(headerExact || '').trim().toLowerCase();

  for (let i = 0; i < ths.length; i++) {
    const txt = String(ths[i].textContent || '').trim().toLowerCase();
    if (txt === needle) return i; // ‚úÖ s√≥ exact match
  }
  return -1;
}

function ensureWorkerTypeSupervisorColumns() {
  const table = document.getElementById('resultTable');
  if (!table) return;

  const theadRow = table.querySelector('thead tr');
  const tbody    = table.querySelector('tbody');
  if (!theadRow || !tbody) return;

  // acha a coluna Person Number
  const personIdx = getColumnIndexByHeaderText(table, 'person number');
  if (personIdx < 0) return;

  // evita duplicar headers
  const hasWorkerTypeHeader = Array.from(theadRow.children).some(th =>
    String(th.textContent || '').trim().toLowerCase() === 'worker type'
  );
  const hasSupervisorHeader = Array.from(theadRow.children).some(th =>
    String(th.textContent || '').trim().toLowerCase() === 'supervisor'
  );

  // cria headers se n√£o existirem
  if (!hasWorkerTypeHeader) {
    const th = document.createElement('th');
    th.textContent = 'Worker Type';
    th.style.whiteSpace = 'nowrap';
    th.style.maxWidth   = '120px';
    th.style.overflow   = 'hidden';
    th.style.textOverflow = 'ellipsis';
    theadRow.insertBefore(th, theadRow.children[personIdx + 1] || null);
  }

  if (!hasSupervisorHeader) {
    const th = document.createElement('th');
    th.textContent = 'Supervisor';
    th.style.whiteSpace = 'nowrap';
    th.style.maxWidth   = '160px';
    th.style.overflow   = 'hidden';
    th.style.textOverflow = 'ellipsis';
    // Supervisor vem logo a seguir ao Worker Type
    theadRow.insertBefore(th, theadRow.children[personIdx + 2] || null);
  }

  // √≠ndices atualizados (agora j√° com as colunas novas no header)
  // ‚úÖ garante que o Employee Master est√° carregado antes de tentar lookup
if (
  typeof loadEmployeeMasterFromStorage === 'function' &&
  (!window.employeeMasterIndex || !Object.keys(window.employeeMasterIndex).length)
) {
  loadEmployeeMasterFromStorage();
}

const personIdxNow = getColumnIndexByHeaderText(table, 'person number');

// ‚úÖ pega "Type" EXATO (n√£o confunde com "Worker Type")
const typeIdx = getColumnIndexByHeaderExactText(table, 'type');


  // percorre linhas vis√≠veis da tabela
  tbody.querySelectorAll('tr').forEach(tr => {
    const tds = tr.querySelectorAll('td');
    if (!tds || !tds.length) return;

    // ignora linha tipo "No results found"
    if (tds.length < 3) return;

    const personCell = tds[personIdxNow];
    if (!personCell) return;

    const rawPerson = String(personCell.textContent || '').trim();
    const empId = (typeof normalizeEmpId === 'function')
      ? normalizeEmpId(rawPerson)
      : rawPerson.replace(/\D/g, '').trim();

    // ag√™ncia vem da coluna Type (se existir)
    const agencyName = (typeIdx >= 0 && tds[typeIdx])
      ? String(tds[typeIdx].textContent || '').trim()
      : '';

    // CORE = existe no Employee Master
    const rec = (window.employeeMasterIndex && empId)
      ? window.employeeMasterIndex[empId]
      : null;

    const workerTypeText = (rec && rec.workerType)
  ? String(rec.workerType).trim()
  : (agencyName || '‚Äî');

const supervisorText = (rec && rec.supervisor)
  ? String(rec.supervisor).trim()
  : (agencyName || '‚Äî');


    // --- garante c√©lulas (sem duplicar) ---
    // queremos inserir na posi√ß√£o: personIdx+1 e personIdx+2
    const wantIdxWorker = personIdxNow + 1;
    const wantIdxSup    = personIdxNow + 2;

    // se j√° existe a nossa c√©lula (pela class), s√≥ atualiza
    let tdWorker = tr.querySelector('td.btWorkerType');
    let tdSup    = tr.querySelector('td.btSupervisor');

    if (!tdWorker) {
      tdWorker = document.createElement('td');
      tdWorker.className = 'btWorkerType';
      tdWorker.style.whiteSpace   = 'nowrap';
      tdWorker.style.maxWidth     = '120px';
      tdWorker.style.overflow     = 'hidden';
      tdWorker.style.textOverflow = 'ellipsis';

      tr.insertBefore(tdWorker, tr.children[wantIdxWorker] || null);
    }

    if (!tdSup) {
      tdSup = document.createElement('td');
      tdSup.className = 'btSupervisor';
      tdSup.style.whiteSpace   = 'nowrap';
      tdSup.style.maxWidth     = '160px';
      tdSup.style.overflow     = 'hidden';
      tdSup.style.textOverflow = 'ellipsis';

      tr.insertBefore(tdSup, tr.children[wantIdxSup] || null);
    }

    // preenche + tooltip (para ver completo sem alargar tabela)
    tdWorker.textContent = workerTypeText || '';
    tdWorker.title       = workerTypeText || '';

    tdSup.textContent = supervisorText || '';
    tdSup.title       = supervisorText || '';
  });
}

/* ‚úÖ Hook: garante que SEMPRE que filterTable() correr,
   as colunas s√£o criadas/atualizadas (sem mexer na tua l√≥gica) */
(function hookFilterTableForExtraColumns() {
  if (typeof window.filterTable !== 'function') return;

  const _old = window.filterTable;

  window.filterTable = function (...args) {
    const res = _old.apply(this, args);

    // 1) Colunas din√¢micas (Worker Type / Supervisor)
    if (typeof ensureWorkerTypeSupervisorColumns === 'function') {
      ensureWorkerTypeSupervisorColumns();
    }

    // 2) Totais por departamento (base: linhas filtradas/vis√≠veis)
    try {
      const visible =
        (typeof getFilteredData === 'function' ? getFilteredData() : null) ||
        (Array.isArray(window.filteredRowsCache) ? window.filteredRowsCache : null) ||
        [];

      if (typeof updateFilteredTotals === 'function') {
        updateFilteredTotals(visible);
      }
    } catch (e) {
      // n√£o quebra a app se algo estiver undefined
    }

    // 3) KPI Over Time / Over Spending (para n√£o "ficar preso" no Break)
    if (typeof updateOvertimeLabel === 'function') {
      updateOvertimeLabel();
    }

    return res;
  };
})();

on('processFileButton', 'click', processFile);
on('clearDataButton', 'click', clearData);
on('filterByDateButton', 'click', filterByDate);
on('downloadExcelButton', 'click', downloadExcelReportBetweenDates);
on('toggleResultButton', 'click', toggleResult);

on('clearHistoryButton', 'click', showPasswordModal);
on('confirmPasswordButton', 'click', checkPassword);
on('cancelPasswordButton', 'click', closeModal);
on('confirmDateButton', 'click', clearHistoryByDate);
on('cancelDateButton', 'click', closeDateModal);

// ================== PERF: Debounce para filtros de texto ==================
function debounce(fn, wait = 150) {
  let t;
  return function (...args) {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), wait);
  };
}

// chama SEMPRE a vers√£o hookada (window.filterTable), se existir
const scheduleFilterTable = debounce(() => {
  if (typeof window.filterTable === 'function') window.filterTable();
  else if (typeof filterTable === 'function') filterTable();
}, 150);
// ==========================================================================

// üîπ filtros de texto (digitando) ‚Üí debounced
on('employeeFilter', 'input', scheduleFilterTable);
on('taskFilter', 'input', scheduleFilterTable);
on('labourAccountFilter', 'input', scheduleFilterTable);

// üîπ filtros de sele√ß√£o ‚Üí imediatos
on('payCodeFilter', 'change', filterTable);
on('dateFilter', 'change', filterTable);

// ‚úÖ NOVO: listener OT > 40h (Week) ‚Äî mant√©m imediato
const otPeopleEl = document.getElementById('otPeopleFilter');
if (otPeopleEl) otPeopleEl.addEventListener('change', filterTable);


// ================== NOVO: Painel Multi-Select de Pay Code ==================
window.selectedPayCodes = window.selectedPayCodes || new Set();

// Helper: pega todos os Pay Codes existentes (storedData ‚Üí se n√£o tiver, pega da tabela)
function getAllPayCodes() {
  const codes = new Set();

  // 1) Fonte principal: storedData
  if (Array.isArray(storedData)) {
    storedData.forEach(e => {
      const code = (e.payCode || '').trim();
      if (code) codes.add(code);
    });
  }

  // 2) Se por algum motivo n√£o tiver nada, tenta ler da tabela Home
if (!codes.size) {
  const table = document.getElementById('resultTable');
  const idxPay = getColumnIndexByHeaderText(table, 'pay code');

  document.querySelectorAll('#resultTable tbody tr').forEach(row => {
    const cells = row.querySelectorAll('td');
    if (!cells || !cells.length) return;

    const td = (idxPay >= 0) ? cells[idxPay] : null;
    if (!td) return;

    const code = td.textContent.trim();
    if (code) codes.add(code);
  });
}


  return Array.from(codes).sort();
}

// Preenche o corpo do painel (lista de checkboxes)
function populatePayCodeMultiBody() {
  const container = document.getElementById('payCodeMultiBody');
  if (!container) return;

  const codes    = getAllPayCodes();
  const selected = window.selectedPayCodes || new Set();

  container.innerHTML = '';

  if (!codes.length) {
    container.innerHTML =
      '<div style="padding:4px; color:#888;">No Pay Codes found.</div>';
    return;
  }

  codes.forEach(code => {
    const codeLC = code.toLowerCase();
    const id     = `pc_${code.replace(/[^a-zA-Z0-9]/g, '_')}`;

    const label = document.createElement('label');
    label.style.display       = 'flex';
    label.style.alignItems    = 'center';
    label.style.gap           = '4px';
    label.style.marginBottom  = '2px';

    const cb   = document.createElement('input');
    cb.type    = 'checkbox';
    cb.value   = codeLC;
    cb.id      = id;
    if (selected.has(codeLC)) cb.checked = true;

    const span = document.createElement('span');
    span.textContent = code;

    label.appendChild(cb);
    label.appendChild(span);
    container.appendChild(label);
  });
}

// ================== PAY CODE MULTI-SELECT: bindings seguros ==================

// getters (sempre pegam o elemento j√° no DOM)
const getOpenPayCodePanelBtn = () => document.getElementById('openPayCodePanel');
const getPayCodePanelEl      = () => document.getElementById('payCodeMultiPanel');
const getPayCodeClearBtn     = () => document.getElementById('payCodeMultiClear');
const getPayCodeCancelBtn    = () => document.getElementById('payCodeMultiCancel');
const getPayCodeOkBtn        = () => document.getElementById('payCodeMultiOk');

// chama isto depois do DOM estar carregado
function bindPayCodeMultiPanel() {
  const openBtn   = getOpenPayCodePanelBtn();
  const panelEl   = getPayCodePanelEl();
  const clearBtn  = getPayCodeClearBtn();
  const cancelBtn = getPayCodeCancelBtn();
  const okBtn     = getPayCodeOkBtn();

  // se o HTML n√£o tiver esses IDs, sai sem quebrar
  if (!openBtn || !panelEl) return;

  // ‚úÖ anti-duplica√ß√£o
  if (openBtn.dataset.boundPaycode === '1') return;
  openBtn.dataset.boundPaycode = '1';

  // Abrir / fechar painel
  openBtn.addEventListener('click', () => {
    if (typeof populatePayCodeMultiBody === 'function') {
      populatePayCodeMultiBody();
    }

    const isHidden =
      panelEl.style.display === 'none' ||
      panelEl.style.display === '';

    panelEl.style.display = isHidden ? 'block' : 'none';
  });

  // CLEAR
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      window.selectedPayCodes = new Set();

      document
        .querySelectorAll('#payCodeMultiBody input[type="checkbox"]')
        .forEach(cb => cb.checked = false);

      const payCodeSelect = document.getElementById('payCodeFilter');
      if (payCodeSelect) payCodeSelect.value = '';

      if (typeof filterTable === 'function') filterTable();
    });
  }

  // CANCEL
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => {
      panelEl.style.display = 'none';
    });
  }

  // OK
  if (okBtn) {
    okBtn.addEventListener('click', () => {
      const set = new Set();

      document
        .querySelectorAll('#payCodeMultiBody input[type="checkbox"]:checked')
        .forEach(cb => set.add(String(cb.value || '').toLowerCase()));

      window.selectedPayCodes = set;

      // limpa dropdown simples se multi tiver ativo
      if (set.size > 0) {
        const payCodeSelect = document.getElementById('payCodeFilter');
        if (payCodeSelect) payCodeSelect.value = '';
      }

      panelEl.style.display = 'none';
      if (typeof filterTable === 'function') filterTable();
    });
  }
}

// ‚úÖ IMPORTANTE: nada de binds antigos aqui em baixo.
// ================== FIM BLOCO PAY CODE MULTI-SELECT ==================



// ‚úÖ helper √∫nico: chama SEMPRE a vers√£o hookada, se existir
function runFilterTableSafe() {
  if (typeof window.filterTable === 'function') return window.filterTable();
  if (typeof filterTable === 'function') return filterTable();
  return null;
}

// ‚úÖ garante que window.filterTable existe (mesmo que o hook ainda n√£o tenha rodado)
if (typeof window.filterTable !== 'function' && typeof filterTable === 'function') {
  window.filterTable = filterTable;
}

// üîπ NOVO: filtro TYPE din√¢mico (SAFE)
on('typeFilter', 'change', () => {
  if (typeof window.filterTable === 'function') window.filterTable();
  else if (typeof filterTable === 'function') filterTable();
});

// SAFE: bot√µes que podem n√£o existir em certas p√°ginas/layouts
on('downloadBudgetReport', 'click', downloadBudgetReport);

on('toggleBudgetMode', 'click', () => {
  showBudgetTotal = !showBudgetTotal;
  renderDashboard();
});

// ‚úÖ NOVO: rec√°lculo autom√°tico quando o modo AGY muda (weekly ‚Üî period)
(function bindAgyOtModeAutoRecalc() {
  if (window.__agyOtModeAutoRecalcBound) return;
  window.__agyOtModeAutoRecalcBound = true;

  document.addEventListener('agyOtModeChanged', () => {
    if (typeof window.filterTable === 'function') window.filterTable();
    else if (typeof filterTable === 'function') filterTable();
  });

  // Helper global p/ UI e console
  window.setAgyOtMode = function (mode) {
    window.agyOtMode = mode;
    localStorage.setItem('agyOtMode', mode);
    document.dispatchEvent(new Event('agyOtModeChanged'));
  };
})();

(async function bootstrapDataFromIDB() {
  // ‚úÖ 0) Carrega storedData do IndexedDB (fallback: migra do localStorage 1x)
  try {
    if (typeof idbGetAllCsvRows === 'function') {
      const rows = await idbGetAllCsvRows();

      if (Array.isArray(rows) && rows.length > 0) {
        storedData = rows.map(r => {
          if (r && typeof r === 'object' && 'id' in r) {
            const { id, ...rest } = r;
            return rest;
          }
          return r;
        });

      } else {
        const raw = localStorage.getItem('csvData');
        if (raw) {
          const arr = JSON.parse(raw) || [];
          storedData = Array.isArray(arr) ? arr : [];

          await idbPutCsvRows(storedData, { replace: true });
          localStorage.removeItem('csvData');
        } else {
          storedData = [];
        }
      }
    } else {
      storedData = JSON.parse(localStorage.getItem('csvData')) || [];
    }
  } catch (e) {
    console.warn('IDB load failed ‚Äî fallback to localStorage:', e);
    storedData = JSON.parse(localStorage.getItem('csvData')) || [];
  }

  populateDropdowns();

  if (storedData.length > 0) {
    const inicial = aggregateData(storedData);
    displayResults(inicial);
    updateTotalHours(inicial);
    updateFilteredTotals(inicial);
    updateHeadcount();
    updateMissingTaskCount();
    displayBudgetOverview();
    populateTypeDropdown();

    // üîπ Recalcula tabela + cache de linhas vis√≠veis
    if (typeof window.filterTable === 'function') window.filterTable();
    else if (typeof filterTable === 'function') filterTable();

    updateOvertimeLabel();
    populateOTPeopleDropdown();
  } else {
    updateOvertimeLabel();
  }

  populatePayCodeDropdown();
  bindPayCodeMultiPanel();
  bindDownloadPdfDashboard();
  populateComparisonTaskFilters();
  populateComparisonDayDropdown();
  renderComparisonCharts();
})();

//document.getElementById('ecomTaskFilter').addEventListener('change', renderComparisonCharts);
//document.getElementById('retailTaskFilter').addEventListener('change', renderComparisonCharts);

on('toggleComparisonPanel', 'click', function () {
  const panel = document.getElementById('comparisonPanel');
  if (!panel) return;

  const wasHidden = (panel.style.display === 'none' || panel.style.display === '');
  panel.style.display = wasHidden ? 'block' : 'none';

  if (wasHidden) {
    populateComparisonTaskFilters();
    renderComparisonCharts();
  }
});

on('closeComparisonPanel', 'click', function () {
  const panel = document.getElementById('comparisonPanel');
  if (panel) panel.style.display = 'none';
});

// ‚îÄ‚îÄ listener do ‚Äú‚úñ‚Äù do detalhe di√°rio ‚îÄ‚îÄ
on('closeDailyDetailBtn', 'click', closeDailyDetail);
    });


  
// ordena pelo n√∫mero de 4 d√≠gitos que aparece no fim do nome da task
function ordenarPorCodigo(a, b) {
  const nA = parseInt((a.match(/\d{4}$/) || [])[0]) || Infinity;
  const nB = parseInt((b.match(/\d{4}$/) || [])[0]) || Infinity;
  return nA - nB;           // menor ‚Üí maior
}
/* =========================================================
   ‚òÖ NOVO ‚Äì Missing Budgets (tabela + toggle + drag)
   ========================================================= */
// ‚òÖ Missing Budgets (tabela + toggle + drag) ‚Äî SAFE INIT (n√£o crasha se IDs n√£o existirem)
(function initMissingBudgetsBox() {
  const box = document.getElementById('missingBudgetBox');
  if (!box) return; // ‚úÖ se n√£o existe no HTML, n√£o quebra o resto do JS

  const boxBody  = box.querySelector('.mb-body');
  const btnShow  = document.getElementById('showMissingBudgets');
  const btnClose = document.getElementById('closeMissingBudgets');

  // se faltarem pe√ßas do UI, n√£o crasha
  if (!boxBody || !btnShow || !btnClose) return;

  /* 1. Tasks que t√™m budget e consumo 0 nos filtros atuais */
  function getMissingBudgetTasks() {
    const visibleTasks = new Set(
      getFilteredData().map(e => e.task)
    );

    const list = [];

    const selectedWeek  = document.getElementById('selectWeek')?.value || '';
    const selectedMonth = document.getElementById('selectMonth')?.value || '';

    Object.entries(plannedHoursTracker).forEach(([tsk, obj]) => {
      const budgets = obj.budgets || {};
      if (!Object.keys(budgets).length) return;

      if (currentDepartmentFilter === 'Ecom'   && !tsk.startsWith('E.')) return;
      if (currentDepartmentFilter === 'Retail' && !tsk.startsWith('R.')) return;
      if (currentDepartmentFilter === 'Break'  && !/break/i.test(tsk))   return;

      let sumHours = 0;

      Object.entries(budgets).forEach(([weekKey, dec]) => {
        const wk = parseInt(weekKey, 10);
        if (isNaN(wk)) return;

        if (selectedWeek && String(wk) !== String(selectedWeek)) return;

        if (selectedMonth) {
          const selMonthLC = String(selectedMonth).trim().toLowerCase();
          let matchesMonth = false;

          for (const dateStr of Object.keys(obj)) {
            if (dateStr === 'budget' || dateStr === 'budgets') continue;

            const [d, m, y] = dateStr.split('/').map(Number);
            if (getCustomWeekNumber(new Date(y, m - 1, d)) !== wk) continue;

            const monthNameLC = new Date(y, m - 1, d)
              .toLocaleString('en-GB', { month: 'long' })
              .toLowerCase();

            if (monthNameLC === selMonthLC) { matchesMonth = true; break; }
          }

          if (!matchesMonth) return;
        }

        sumHours += (dec || 0);
      });

      if (sumHours <= 0) return;
      if (visibleTasks.has(tsk)) return;

      list.push({ task: tsk, hours: sumHours });
    });

    list.sort((a, b) => b.hours - a.hours);
    return list;
  }

  /* 2. Preenche a caixinha com a tabela */
  function populateMissingBudgetBox() {
    const list = getMissingBudgetTasks();

    const rows = list
      .map(r =>
        `<tr><td>${r.task}</td><td style="text-align:right;">${formatTimeHHMM(r.hours*3600)}</td></tr>`
      )
      .join('');

    const totalSec = list.reduce((sum, r) => sum + r.hours * 3600, 0);

    boxBody.innerHTML = `
      <table>
        <thead>
          <tr><th>Task</th><th style="text-align:right;">Budget</th></tr>
        </thead>
        <tbody>
          ${rows || '<tr><td colspan="2" style="text-align:center;color:#888;">Nenhum</td></tr>'}
          ${list.length ? `
            <tr class="mb-total">
              <th>Total</th>
              <th style="text-align:right;">${formatTimeHHMM(totalSec)}</th>
            </tr>` : ''}
        </tbody>
      </table>`;
  }

  /* 3. Toggle mostrar / ocultar */
  function toggleMissingBudgetBox() {
    if (box.style.display === '' || box.style.display === 'none') {
      populateMissingBudgetBox();
      box.style.display = 'block';
    } else {
      box.style.display = 'none';
    }
  }

  btnShow.addEventListener('click', toggleMissingBudgetBox);
  btnClose.addEventListener('click', toggleMissingBudgetBox);

  /* 4. Arrastar pela barra azul */
  (function makeDraggable() {
    const header = box.querySelector('.mb-header');
    if (!header) return;

    let offsetX = 0, offsetY = 0, dragging = false;

    header.addEventListener('mousedown', e => {
      dragging = true;
      box.classList.add('grabbing');
      const r = box.getBoundingClientRect();
      offsetX = e.clientX - r.left;
      offsetY = e.clientY - r.top;
      e.preventDefault();
    });

    document.addEventListener('mousemove', e => {
      if (!dragging) return;
      box.style.left  = (e.clientX - offsetX) + 'px';
      box.style.top   = (e.clientY - offsetY) + 'px';
      box.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      dragging = false;
      box.classList.remove('grabbing');
    });
  })();
})();


// ‚Üê fecha o DOMContentLoaded
// =========================================================
// EMPLOYEE MASTER (FT/PT) ‚Äî Upload + Storage + Status
// =========================================================

const EMP_MASTER_STORAGE_KEY = 'employeeMaster_v1';

// cache global (r√°pido para lookup)
window.employeeMasterIndex = window.employeeMasterIndex || {}; // { empId: {...} }
window.employeeMasterMeta  = window.employeeMasterMeta  || null; // { updatedAtIso, count }

// --- helpers ---
function normalizeEmpId(raw) {
  // mant√©m s√≥ d√≠gitos (mais seguro)
  return String(raw || '').replace(/\D/g, '').trim();
}

function parseFlexibleHmsToSeconds(raw) {
  const v = String(raw || '').trim();
  if (!v) return 0;

  // ex: "40:00:00" ou "20:00" ou "14:00"
  if (v.includes(':')) {
    const parts = v.split(':').map(p => Number(p || 0));
    const h = parts[0] || 0;
    const m = parts[1] || 0;
    const s = parts[2] || 0;
    return Math.round(h * 3600 + m * 60 + s);
  }

  // fallback: decimal hours
  const dec = Number(v.replace(',', '.'));
  if (!Number.isFinite(dec) || dec < 0) return 0;
  return Math.round(dec * 3600);
}

function detectDelimiterFromLine(line) {
  const s = String(line || '');
  if (s.includes('\t')) return '\t';
  if (s.includes(';'))  return ';';
  if (s.includes(','))  return ',';
  return '\t';
}

// parser simples por delimitador (com suporte b√°sico a aspas)
function splitLineWithDelimiter(line, delimiter) {
  const out = [];
  let cur = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }

    if (!inQuotes && ch === delimiter) {
      out.push(cur);
      cur = '';
      continue;
    }

    cur += ch;
  }

  out.push(cur);
  return out.map(x => String(x || '').trim());
}

// caso o ficheiro seja CSV com v√≠rgulas e o nome venha "Last, First" sem aspas,
// este fallback junta as partes iniciais at√© ficar com 5 colunas.
function fixCommaCsvIfNeeded(cols) {
  if (!Array.isArray(cols)) return cols;

  // esperamos 5 colunas:
  // Full Name | Emp ID | Supervisor Name | Exp Weekly Hours | Worker Type
  if (cols.length === 5) return cols;

  if (cols.length > 5) {
    const tail = cols.slice(cols.length - 4); // ID, Supervisor, Hours, Type
    const head = cols.slice(0, cols.length - 4); // nome pode ter v√≠rgulas
    const fullName = head.join(',').trim();
    return [fullName, ...tail];
  }

  return cols;
}

function parseEmployeeMasterText(text) {
  const rawLines = String(text || '').split(/\r?\n/).map(l => l.trim());
  const lines = rawLines.filter(l => l.length > 0);
  if (!lines.length) return [];

  const delimiter = detectDelimiterFromLine(lines[0]);

  // detectar header
  let startIndex = 0;
  const firstColsRaw = splitLineWithDelimiter(lines[0], delimiter);
  const firstCols = (delimiter === ',') ? fixCommaCsvIfNeeded(firstColsRaw) : firstColsRaw;

  const headerLike =
    String(firstCols[0] || '').toLowerCase().includes('full') &&
    String(firstCols[1] || '').toLowerCase().includes('emp');

  if (headerLike) startIndex = 1;

  const records = [];

  for (let i = startIndex; i < lines.length; i++) {
    const line = lines[i];

    let colsRaw = splitLineWithDelimiter(line, delimiter);
    let cols = (delimiter === ',') ? fixCommaCsvIfNeeded(colsRaw) : colsRaw;

    // safety: precisamos pelo menos de 5
    if (!cols || cols.length < 5) continue;

    const fullName   = String(cols[0] || '').trim();
    const empId      = normalizeEmpId(cols[1]);
    const supervisor = String(cols[2] || '').trim();
    const expHours   = String(cols[3] || '').trim();
    const workerType = String(cols[4] || '').trim();

    if (!empId) continue;

    records.push({
      fullName,
      empId,
      supervisor,
      expWeeklyHoursRaw: expHours,
      expWeeklySeconds: parseFlexibleHmsToSeconds(expHours),
      workerType
    });
  }

  return records;
}

function saveEmployeeMasterToStorage(records) {
  const byEmpId = {};
  records.forEach(r => {
    byEmpId[r.empId] = {
      fullName: r.fullName,
      supervisor: r.supervisor,
      workerType: r.workerType,
      expWeeklyHoursRaw: r.expWeeklyHoursRaw,
      expWeeklySeconds: r.expWeeklySeconds
    };
  });

  const payload = {
    version: 1,
    updatedAtIso: new Date().toISOString(),
    count: Object.keys(byEmpId).length,
    byEmpId
  };

  localStorage.setItem(EMP_MASTER_STORAGE_KEY, JSON.stringify(payload));

  // atualiza cache global
  window.employeeMasterIndex = byEmpId;
  window.employeeMasterMeta  = { updatedAtIso: payload.updatedAtIso, count: payload.count };
}

function loadEmployeeMasterFromStorage() {
  try {
    const raw = localStorage.getItem(EMP_MASTER_STORAGE_KEY);
    if (!raw) return;

    const obj = JSON.parse(raw);
    if (!obj || !obj.byEmpId) return;

    window.employeeMasterIndex = obj.byEmpId || {};
    window.employeeMasterMeta  = { updatedAtIso: obj.updatedAtIso, count: obj.count };
  } catch (e) {
    // se estiver corrompido, ignora
    window.employeeMasterIndex = {};
    window.employeeMasterMeta  = null;
  }
}

// ‚úÖ NOVO: carrega o master imediatamente (antes da tabela/filters rodarem)
loadEmployeeMasterFromStorage();


// =========================================================
// ‚úÖ HELPERS: Worker Type + Supervisor (CORE via Master | AGY via Type)
// =========================================================
function isCoreTypeText(typeText) {
  return String(typeText || '').toLowerCase().includes('core');
}

function getWorkerTypeAndSupervisor(personNumber, typeText) {
  const typeRaw = String(typeText || '').trim();

  // AGY / n√£o-CORE: ambos v√™m do "Type" (nome da ag√™ncia)
  if (!isCoreTypeText(typeRaw)) {
    return {
      workerType: typeRaw || '‚Äî',
      supervisor: typeRaw || '‚Äî'
    };
  }

  // CORE: vem do Employee Master
  const empId = (typeof normalizeEmpId === 'function')
    ? normalizeEmpId(personNumber)
    : String(personNumber || '').replace(/\D/g, '').trim();

  const rec = (window.employeeMasterIndex && empId)
    ? window.employeeMasterIndex[empId]
    : null;

    return {
    workerType: (rec && rec.workerType) ? rec.workerType : (typeRaw || '‚Äî'),
    supervisor: (rec && rec.supervisor) ? rec.supervisor : (typeRaw || '‚Äî')
  };
}

function updateEmployeeMasterStatusUI() {
  const el = document.getElementById('employeeMasterStatus');
  if (!el) return;

  const meta = window.employeeMasterMeta;
  const count = meta?.count || 0;

  if (!count) {
    el.textContent = 'No master file loaded.';
    return;
  }

  const dt = meta.updatedAtIso ? new Date(meta.updatedAtIso) : null;
  const nice = dt && !isNaN(dt.getTime())
    ? dt.toLocaleString('en-GB')
    : 'Unknown';

  el.textContent = `Loaded: ${count} employees | Last update: ${nice}`;
}

function handleEmployeeMasterUpload() {
  const input = document.getElementById('employeeMasterInput');
  if (!input || !input.files || !input.files.length) {
    alert('Please select the Employee Master file.');
    return;
  }

  const file = input.files[0];
  const reader = new FileReader();

  reader.onload = function (event) {
    const text = event.target.result || '';
    const records = parseEmployeeMasterText(text);

    if (!records.length) {
      alert('No valid records found in the Employee Master file.');
      return;
    }

    // overwrite total (como combin√°mos)
    saveEmployeeMasterToStorage(records);
    updateEmployeeMasterStatusUI();

    // reset input (opcional)
    input.value = '';
  };

  reader.readAsText(file);
}
function on(id, evt, handler, opts) {
  const el = document.getElementById(id);
  if (!el) return false;
  el.addEventListener(evt, handler, opts);
  return true;
}

// init (UI + listeners)
document.addEventListener('DOMContentLoaded', () => {
  updateEmployeeMasterStatusUI();

  // ‚úÖ garante que a tabela j√° existe antes de repintar (evita corrida)
  setTimeout(() => {
    if (typeof ensureWorkerTypeSupervisorColumns === 'function') {
      ensureWorkerTypeSupervisorColumns();
    }
  }, 0);

  const btn = document.getElementById('employeeMasterUploadBtn');
  if (btn) btn.addEventListener('click', handleEmployeeMasterUpload);

  // opcional: auto-upload quando selecionar ficheiro
  const input = document.getElementById('employeeMasterInput');
  if (input) {
    input.addEventListener('change', () => {
      // handleEmployeeMasterUpload();
    });
  }
});
/* =========================================================
   üîí Anti-curiosos (bloqueia atalhos comuns)
   - Ctrl+U (View Source)
   - Ctrl+Shift+I (DevTools)
   - F12, Ctrl+Shift+J, Ctrl+Shift+C (varia√ß√µes DevTools)
   - Bloqueia tamb√©m bot√£o direito (opcional)
   ========================================================= */
(function blockDevShortcuts() {
  // 1) Bloqueia bot√£o direito (menu contexto)
  document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  }, true);

  // 2) Bloqueia atalhos de teclado
  document.addEventListener('keydown', (e) => {
    const key = String(e.key || '').toLowerCase();

    const isCtrlU       = e.ctrlKey && !e.shiftKey && key === 'u';
    const isCtrlShiftI  = e.ctrlKey &&  e.shiftKey && key === 'i';
    const isCtrlShiftJ  = e.ctrlKey &&  e.shiftKey && key === 'j';
    const isCtrlShiftC  = e.ctrlKey &&  e.shiftKey && key === 'c';
    const isF12         = (e.key === 'F12') || (e.keyCode === 123);

    if (isCtrlU || isCtrlShiftI || isCtrlShiftJ || isCtrlShiftC || isF12) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }, true);
})();

</script>
</body>
</html>
